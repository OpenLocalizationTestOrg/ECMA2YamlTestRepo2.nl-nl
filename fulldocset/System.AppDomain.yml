### YamlMime:ManagedReference
items:
- uid: System.AppDomain
  id: AppDomain
  children:
  - System.AppDomain.ActivationContext
  - System.AppDomain.AppendPrivatePath(System.String)
  - System.AppDomain.ApplicationIdentity
  - System.AppDomain.ApplicationTrust
  - System.AppDomain.ApplyPolicy(System.String)
  - System.AppDomain.AssemblyLoad
  - System.AppDomain.AssemblyResolve
  - System.AppDomain.BaseDirectory
  - System.AppDomain.ClearPrivatePath
  - System.AppDomain.ClearShadowCopyPath
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.CreateDomain(System.String)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  - System.AppDomain.CreateInstance(System.String,System.String)
  - System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CurrentDomain
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  - System.AppDomain.DomainManager
  - System.AppDomain.DomainUnload
  - System.AppDomain.DynamicDirectory
  - System.AppDomain.Evidence
  - System.AppDomain.ExecuteAssembly(System.String)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssembly(System.String,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssemblyByName(System.String)
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.FirstChanceException
  - System.AppDomain.FriendlyName
  - System.AppDomain.GetAssemblies
  - System.AppDomain.GetCurrentThreadId
  - System.AppDomain.GetData(System.String)
  - System.AppDomain.GetType
  - System.AppDomain.Id
  - System.AppDomain.InitializeLifetimeService
  - System.AppDomain.IsCompatibilitySwitchSet(System.String)
  - System.AppDomain.IsDefaultAppDomain
  - System.AppDomain.IsFinalizingForUnload
  - System.AppDomain.IsFullyTrusted
  - System.AppDomain.IsHomogenous
  - System.AppDomain.Load(System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName)
  - System.AppDomain.Load(System.String)
  - System.AppDomain.Load(System.Byte[],System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  - System.AppDomain.MonitoringIsEnabled
  - System.AppDomain.MonitoringSurvivedMemorySize
  - System.AppDomain.MonitoringSurvivedProcessMemorySize
  - System.AppDomain.MonitoringTotalAllocatedMemorySize
  - System.AppDomain.MonitoringTotalProcessorTime
  - System.AppDomain.PermissionSet
  - System.AppDomain.ProcessExit
  - System.AppDomain.ReflectionOnlyAssemblyResolve
  - System.AppDomain.ReflectionOnlyGetAssemblies
  - System.AppDomain.RelativeSearchPath
  - System.AppDomain.ResourceResolve
  - System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  - System.AppDomain.SetCachePath(System.String)
  - System.AppDomain.SetData(System.String,System.Object)
  - System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  - System.AppDomain.SetDynamicBase(System.String)
  - System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  - System.AppDomain.SetShadowCopyFiles
  - System.AppDomain.SetShadowCopyPath(System.String)
  - System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  - System.AppDomain.SetupInformation
  - System.AppDomain.ShadowCopyFiles
  - System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  - System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.AppDomain.ToString
  - System.AppDomain.TypeResolve
  - System.AppDomain.UnhandledException
  - System.AppDomain.Unload(System.AppDomain)
  langs:
  - csharp
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
  type: Class
  summary: "Hiermee geeft u een toepassingsdomein, een geïsoleerde omgeving waarin toepassingen worden uitgevoerd. Deze klasse kan niet worden overgenomen."
  remarks: "Toepassingsdomeinen, vertegenwoordigd door AppDomain-objecten, zorgt voor isolatie, verwijderen en beveiliging grenzen voor het uitvoeren van beheerde code.      -Toepassingsdomeinen gebruiken voor het isoleren van taken die naar beneden een proces meenemen mogelijk. Als de status van het AppDomain dat als een taak wordt uitgevoerd instabiel wordt, kan het AppDomain zonder dat het proces te worden verwijderd. Dit is belangrijk bij een proces moet worden uitgevoerd gedurende lange periodes zonder opnieuw te starten. U kunt ook toepassingsdomeinen gebruiken voor het isoleren van taken die gegevens niet delen.      -Als een assembly geladen in het standaardtoepassingsdomein is, kan niet uit het geheugen verwijderd tijdens het proces wordt uitgevoerd. Als u een tweede toepassingsdomein om te laden en uitvoeren van de assembly opent, is de assembly echter verwijderd als dat toepassingsdomein verwijderd wordt. Deze techniek gebruiken om te beperken van de werkset van langlopende processen die gebruikmaken van tijd tot tijd grote dll&quot;s.       Meerdere toepassingsdomeinen kunnen uitvoeren in een enkel proces; Er is echter niet een-op-een correlatie tussen toepassingsdomeinen en threads. Meerdere threads kunnen deel uitmaken van een domein één toepassing en tijdens een opgegeven thread niet tot een domein één toepassing op elk gewenst beperkt wordt een thread wordt uitgevoerd in een domein één toepassing.       Toepassingsdomeinen worden gemaakt met de <xref:System.AppDomain.CreateDomain%2A>methode.</xref:System.AppDomain.CreateDomain%2A> AppDomain-exemplaren worden gebruikt om te laden en uitvoeren van de assembly&quot;s (<xref:System.Reflection.Assembly>).</xref:System.Reflection.Assembly> Wanneer een AppDomain niet langer in gebruik is, kan het worden verwijderd.       De klasse AppDomain implementeert een reeks gebeurtenissen die toepassingen te kunnen reageren wanneer een assembly is geladen, wanneer een toepassingsdomein worden verwijderd of wanneer er een niet-verwerkte uitzondering gegenereerd.       Zie voor meer informatie over het gebruik van toepassingsdomeinen [toepassingsdomeinen](~/add/includes/ajax-current-ext-md.md).       Deze klasse implementeert de <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, en <xref:System.Security.IEvidenceFactory>interfaces.</xref:System.Security.IEvidenceFactory> </xref:System._AppDomain> </xref:System.MarshalByRefObject>       U moet nooit een wrapper extern kan worden gebruikt voor een object van het AppDomain maken. Een externe verwijzing naar dat AppDomain, methoden, zoals weergegeven in dat geval kan publiceren <xref:System.AppDomain.CreateInstance%2A>voor externe toegang en effectief vernietigen codetoegangsbeveiliging voor dit AppDomain.</xref:System.AppDomain.CreateInstance%2A> Kwaadwillende clients verbinding maken met de knooppunten AppDomain kunnen toegang krijgen tot alle het AppDomain zelf toegang tot heeft bronnen. Maak geen wrappers extern kan worden gebruikt voor elk type die uitgebreider is dan <xref:System.MarshalByRefObject>en die worden geïmplementeerd met methoden die door schadelijke clients kunnen worden gebruikt voor het overslaan van het beveiligingssysteem.</xref:System.MarshalByRefObject>      > [!CAUTION] > De standaardwaarde voor de <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>eigenschap is `false`.</xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName> Deze instelling is niet veilig voor services. Om te voorkomen dat services gedeeltelijk vertrouwde code downloaden, kunt u deze eigenschap instellen op `true`."
  example:
  - "This example shows how to create a new AppDomain, instantiate a type in that new AppDomain, and communicate with that type’s object. In addition, this example shows how to unload the AppDomain causing the object to be garbage collected.  \n  \n [!code-vb[AppDomainX#1](~/add/codesnippet/visualbasic/t-system.appdomain_1.vb)]\n [!code-cs[AppDomainX#1](~/add/codesnippet/csharp/t-system.appdomain_1.cs)]\n [!code-cpp[AppDomainX#1](~/add/codesnippet/cpp/t-system.appdomain_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System._AppDomain
  - System.Security.IEvidenceFactory
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.AppDomain.ActivationContext
  id: ActivationContext
  parent: System.AppDomain
  langs:
  - csharp
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee wordt de activeringscontext voor het huidige toepassingsdomein."
  syntax:
    content: public ActivationContext ActivationContext { get; }
    return:
      type: System.ActivationContext
      description: "Een object met de activeringscontext voor het huidige toepassingsdomein of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als het domein geen activeringscontext heeft."
  overload: System.AppDomain.ActivationContext*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AppendPrivatePath(System.String)
  id: AppendPrivatePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De opgegeven mapnaam toegevoegd aan de lijst persoonlijk pad."
  remarks: "Het gebruik van deze eigenschap wordt niet aanbevolen, omdat deze het Zoek pad voor assembly&quot;s wijzigen mogelijk nadat ze al geladen zijn. Gebruik de <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>eigenschap in plaats daarvan.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>       De persoonlijk pad of een relatief zoekpad, is het pad ten opzichte van de basismap waar de assembly-omzetter-tests voor persoonlijke assembly&quot;s."
  syntax:
    content: public void AppendPrivatePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "De naam van de map moet worden toegevoegd aan de persoonlijk pad."
  overload: System.AppDomain.AppendPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.ApplicationIdentity
  id: ApplicationIdentity
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt de identiteit van de toepassing in het toepassingsdomein."
  syntax:
    content: public ApplicationIdentity ApplicationIdentity { get; }
    return:
      type: System.ApplicationIdentity
      description: "Een object dat de toepassing in het toepassingsdomein te identificeren."
  overload: System.AppDomain.ApplicationIdentity*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u informatie over de machtigingen te krijgen tot een toepassing en of de toepassing heeft een vertrouwensniveau die kan worden uitgevoerd."
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "Een object dat de machtiging en vertrouwensrelatie informatie voor de toepassing in het toepassingsdomein ingekapseld."
  overload: System.AppDomain.ApplicationTrust*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplyPolicy(System.String)
  id: ApplyPolicy(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Retourneert de assembly weergavenaam nadat het beleid is toegepast."
  remarks: "De methode heeft een assembly ApplyPolicy weergavenaam en retourneert de weergavenaam na het beleid. Dit is handig als u hebt een assembly te laden met behulp van beleid, omdat het kenmerk alleen-reflectie context beleid niet van toepassing."
  syntax:
    content: public string ApplyPolicy (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De assembly-naam, weergegeven in de vorm die is geleverd door de &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt; eigenschap."
    return:
      type: System.String
      description: "Een tekenreeks met de assembly weergavenaam nadat het beleid is toegepast."
  overload: System.AppDomain.ApplyPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyLoad
  id: AssemblyLoad
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Treedt op wanneer een assembly geladen is."
  remarks: "De <xref:System.AssemblyLoadEventHandler>delegeren voor deze gebeurtenis geeft aan welke assembly is geladen.</xref:System.AssemblyLoadEventHandler>       U moet de vereiste machtigingen hebben voor het registreren van een gebeurtenis-handler voor deze gebeurtenis, of een <xref:System.Security.SecurityException>gegenereerd.</xref:System.Security.SecurityException>       Zie voor meer informatie over het verwerken van gebeurtenissen [gebeurtenissen](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyLoad event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_AssemblyLoad#1](~/add/codesnippet/csharp/e-system.appdomain.assem_1_1.cs)]\n [!code-vb[AppDomain_AssemblyLoad#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_1_1.vb)]\n [!code-cpp[AppDomain_AssemblyLoad#1](~/add/codesnippet/cpp/e-system.appdomain.assem_1_1.cpp)]"
  syntax:
    content: public event AssemblyLoadEventHandler AssemblyLoad;
    return:
      type: System.AssemblyLoadEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyResolve
  id: AssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Deze gebeurtenis treedt op wanneer de resolutie van een assembly is mislukt."
  remarks: "Het is de verantwoordelijkheid van de <xref:System.ResolveEventHandler>voor deze gebeurtenis om te retourneren van de assembly die is opgegeven door de <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>eigenschap, of null retourneren als de assembly wordt niet herkend.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> </xref:System.ResolveEventHandler> De assembly moet worden geladen in een uitvoeringscontext; Als deze in de context van het kenmerk alleen-reflectie is geladen, wordt de belasting van deze gebeurtenis wordt gegenereerd, waardoor mislukt.       Zie voor instructies over het gebruik van deze gebeurtenis [het omzetten van Assembly laadt](~/add/includes/ajax-current-ext-md.md).       Vanaf de [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], wordt de <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>eigenschap retourneert de assembly die de belasting van de assembly die niet kan omgezet worden aangevraagd.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> De lader van de worden kan een afhankelijkheid van de aanvragende assembly niet laden omdat de aanvragende assembly en een afhankelijkheid ervan bevindt zich niet in het Zoek pad. De identiteit van de aanvragende assembly weten kan nuttig zijn in het zoeken naar de afhankelijkheid of bij het identificeren van de juiste versie als meer dan één versie van de afhankelijkheid beschikbaar is. Zie voor meer informatie <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>      > [!IMPORTANT] > Vanaf de [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], wordt de <xref:System.ResolveEventHandler>gebeurtenis wordt geactiveerd voor alle assembly&quot;s, met inbegrip van de resource-assembly&quot;s.</xref:System.ResolveEventHandler> In eerdere versies is de gebeurtenis niet geactiveerd voor resource-assembly&quot;s. Als het besturingssysteem is gelokaliseerd, de handler kan worden aangeroepen meermaals: eenmaal voor elke cultuur in de terugvalketen.       Voor deze gebeurtenis, de <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>eigenschap retourneert de assemblynaam voordat beleid wordt toegepast.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>      > [!IMPORTANT] > Als meer dan één gebeurtenis-handler is geregistreerd voor deze gebeurtenis, worden de gebeurtenis handlersarecalled in volgorde totdat een gebeurtenis-handler een waarde retourneert niet `null`. Volgende gebeurtenis-handlers worden genegeerd.       Zie voor meer informatie over het verwerken van gebeurtenissen [gebeurtenissen](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cpp[AssemblyResolve#1](~/add/codesnippet/cpp/e-system.appdomain.assem_0_1.cpp)]\n [!code-cs[AssemblyResolve#1](~/add/codesnippet/csharp/e-system.appdomain.assem_0_1.cs)]\n [!code-vb[AssemblyResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_0_1.vb)]"
  syntax:
    content: public event ResolveEventHandler AssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.BaseDirectory
  id: BaseDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u de basismap die de assembly-omzetter gebruikt voor de probe voor assembly&quot;s."
  remarks: "Deze eigenschap komt overeen met de <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>eigenschap.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> Het kan ook worden opgehaald met behulp van de <xref:System.AppDomain.GetData%2A>methode met de tekenreeks &quot;APPBASE&quot;.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain. The example then uses the BaseDirectory property to obtain the base directory path, for display to the console.  \n  \n [!code-cs[ADSetup#1](~/add/codesnippet/csharp/p-system.appdomain.based_1.cs)]\n [!code-cpp[ADSetup#1](~/add/codesnippet/cpp/p-system.appdomain.based_1.cpp)]\n [!code-vb[ADSetup#1](~/add/codesnippet/visualbasic/p-system.appdomain.based_1.vb)]"
  syntax:
    content: public string BaseDirectory { get; }
    return:
      type: System.String
      description: "De basismap die de assembly-omzetter gebruikt voor de probe voor assembly&quot;s."
  overload: System.AppDomain.BaseDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.ClearPrivatePath
  id: ClearPrivatePath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee stelt u het pad dat de locatie van de persoonlijke assembly&quot;s op de lege tekenreeks (&quot;&quot;)."
  remarks: "Persoonlijk pad is een pad relatief ten opzichte van de basismap die de common language runtime zoekt naar te zoeken persoonlijke assembly&quot;s.       Zie voor meer informatie <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use the ClearPrivatePath method to remove all entries from the list of private paths to search when assemblies are loaded.  \n  \n This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADClearPrivatePath#1](~/add/codesnippet/cpp/m-system.appdomain.clear_1.cpp)]\n [!code-cs[ADClearPrivatePath#1](~/add/codesnippet/csharp/m-system.appdomain.clear_1.cs)]\n [!code-vb[ADClearPrivatePath#1](~/add/codesnippet/visualbasic/m-system.appdomain.clear_1.vb)]"
  syntax:
    content: public void ClearPrivatePath ();
    parameters: []
  overload: System.AppDomain.ClearPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.ClearShadowCopyPath
  id: ClearShadowCopyPath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee stelt u de lijst met mappen met schaduwkopieën assembly&quot;s op de lege tekenreeks (&quot;&quot;)."
  remarks: "Het shadow copy-pad is een lijst met mappen waarin shadow gekopieerd assembly&quot;s worden opgeslagen.       Zie voor meer informatie <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>en [Shadow kopiëren assembly&quot;s](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>"
  syntax:
    content: public void ClearShadowCopyPath ();
    parameters: []
  overload: System.AppDomain.ClearShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  id: CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van een opgegeven COM-type. Parameters geeft de naam van een bestand met een assembly met het type en de naam van het type."
  remarks: "Gebruik deze methode om objecten te maken op afstand zonder te laden van het type lokaal.       De geretourneerde waarde mag niet-ingepakte voor toegang tot het juiste object zijn.       Een<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName> kenmerk met een waarde van `true` moet expliciet of standaard worden toegepast op de COM-type voor deze methode voor het maken van een exemplaar van dat type; anders <xref:System.TypeLoadException>gegenereerd.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  example:
  - "The following sample demonstrates  \n  \n [!code-cs[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/csharp/m-system.appdomain.creat_4_1.cs)]\n [!code-vb[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_4_1.vb)]\n [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/cpp/m-system.appdomain.creat_4_1.cpp)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De naam van een bestand met een assembly die het aangevraagde type definieert."
    - id: typeName
      type: System.String
      description: "De naam van het aangevraagde type."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Een object dat een wrapper voor het nieuwe exemplaar dat is opgegeven door <code> typeName </code>. De retourwaarde moet niet-ingepakte voor toegang tot het juiste object."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Het type kan niet worden geladen."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Er is geen openbare parameterloze constructor is gevonden."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>is een abstracte klasse.       - of - dit lid is aangeroepen met een mechanisme voor late binding."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyName</code>een lege tekenreeks (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Het COM-object waarnaar wordt verwezen is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van een opgegeven COM-type. Parameters geeft de naam van een bestand met een assembly met het type en de naam van het type."
  remarks: "Gebruik deze methode om objecten te maken op afstand zonder te laden van het type lokaal.       De geretourneerde waarde mag niet-ingepakte voor toegang tot het juiste object zijn.       Een <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>kenmerk met een waarde van `true` moet expliciet of standaard worden toegepast op de COM-type voor deze methode voor het maken van een exemplaar van dat type; anders <xref:System.TypeLoadException>gegenereerd.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De naam van een bestand met een assembly die het aangevraagde type definieert."
    - id: typeName
      type: System.String
      description: "De naam van het aangevraagde type."
    - id: hashValue
      type: System.Byte[]
      description: "Hiermee geeft u de waarde van de berekende hash-code."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Hiermee geeft u het hashalgoritme dat door het assembly-manifest."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Een object dat een wrapper voor het nieuwe exemplaar dat is opgegeven door <code> typeName </code>. De retourwaarde moet niet-ingepakte voor toegang tot het juiste object."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Het type kan niet worden geladen."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Er is geen openbare parameterloze constructor is gevonden."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>is niet gevonden."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>is een abstracte klasse.       - of - dit lid is aangeroepen met een mechanisme voor late binding."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyFile</code>is een lege tekenreeks (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>is geen geldige assembly."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Het COM-object waarnaar wordt verwezen is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String)
  id: CreateDomain(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw toepassingsdomein met de opgegeven naam."
  remarks: "De `friendlyName` parameter is bedoeld om het domein op een manier die relevant zijn voor mensen te identificeren. Deze tekenreeks moet geschikt is voor weergave in de gebruikersinterfaces.       Deze methode-overload gebruikt de <xref:System.AppDomainSetup>informatie van het standaardtoepassingsdomein.</xref:System.AppDomainSetup>"
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_1_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_1_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_1_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName);
    parameters:
    - id: friendlyName
      type: System.String
      description: "De beschrijvende naam van het domein."
    return:
      type: System.AppDomain
      description: "Het toepassingsdomein gemaakte."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  id: CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw toepassingsdomein met de opgegeven naam met behulp van de opgegeven gegevens."
  remarks: "This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the CreateDomain overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_0_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_0_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_0_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "De beschrijvende naam van het domein. Deze beschrijvende naam kan worden weergegeven in de gebruikersinterface voor het identificeren van het domein. Zie voor meer informatie <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Blijkt dat de identiteit van de code die wordt uitgevoerd in het toepassingsdomein vaststelt. Doorgeven <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> gebruiken het bewijs van het huidige toepassingsdomein."
    return:
      type: System.AppDomain
      description: "Het toepassingsdomein gemaakte."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw toepassingsdomein met de opgegeven naam, bewijs en informatie over de installatie van de toepassing domein."
  remarks: "If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/f22a5c12-7605-4011-8d1c-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/f22a5c12-7605-4011-8d1c-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/f22a5c12-7605-4011-8d1c-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);
    parameters:
    - id: friendlyName
      type: System.String
      description: "De beschrijvende naam van het domein. Deze beschrijvende naam kan worden weergegeven in de gebruikersinterface voor het identificeren van het domein. Zie voor meer informatie <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Blijkt dat de identiteit van de code die wordt uitgevoerd in het toepassingsdomein vaststelt. Doorgeven <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> gebruiken het bewijs van het huidige toepassingsdomein."
    - id: info
      type: System.AppDomainSetup
      description: "Een object dat informatie over de initialisatie van de toepassing domein bevat."
    return:
      type: System.AppDomain
      description: "Het toepassingsdomein gemaakte."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw toepassingsdomein met behulp van de opgegeven naam, bewijs, informatie over de installatie van de toepassing domein, standaard machtigingen zijn ingesteld en matrix van volledig vertrouwde assembly&quot;s."
  remarks: "U moet instellen de <xref:System.AppDomainSetup.ApplicationBase%2A>eigenschap van de <xref:System.AppDomainSetup>-object dat u opgeeft voor `info`.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ApplicationBase%2A> Anders wordt er een uitzondering gegenereerd.       Als `securityInfo` is niet opgegeven, wordt het bewijs van het huidige toepassingsdomein gebruikt.       De informatie die is opgegeven voor `grantSet` en `fullTrustAssemblies` gebruikt voor het maken een <xref:System.Security.Policy.ApplicationTrust>object voor het nieuwe toepassingsdomein.</xref:System.Security.Policy.ApplicationTrust>"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);
    parameters:
    - id: friendlyName
      type: System.String
      description: "De beschrijvende naam van het domein. Deze beschrijvende naam kan worden weergegeven in de gebruikersinterface voor het identificeren van het domein. Zie voor meer informatie, de beschrijving van <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Blijkt dat de identiteit van de code die wordt uitgevoerd in het toepassingsdomein vaststelt. Doorgeven <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> gebruiken het bewijs van het huidige toepassingsdomein."
    - id: info
      type: System.AppDomainSetup
      description: "Een object dat informatie over de initialisatie van de toepassing domein bevat."
    - id: grantSet
      type: System.Security.PermissionSet
      description: "Een standaard machtigingenset is verleend op alle assembly&quot;s geladen in het nieuwe toepassingsdomein waarvoor geen specifiek verleent."
    - id: fullTrustAssemblies
      type: System.Security.Policy.StrongName[]
      description: "Een matrix van sterke namen voor assembly&quot;s die moeten worden beschouwd als volledig vertrouwd in het nieuwe toepassingsdomein."
    return:
      type: System.AppDomain
      description: "Het toepassingsdomein gemaakte."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het toepassingsdomein is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.       - of - de <xref:System.AppDomainSetup.ApplicationBase*>eigenschap niet is ingesteld op de <xref href=&quot;System.AppDomainSetup&quot;> </xref> -object dat is opgegeven voor <code> info </code>.</xref:System.AppDomainSetup.ApplicationBase*>"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw toepassingsdomein met de opgegeven naam, met behulp van bewijs, base toepassingspad relatief zoekpad en een parameter die aangeeft of een schaduwkopie van een assembly in het toepassingsdomein worden geladen."
  remarks: "If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/9bed52ed-b275-4e3a-b9e6-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/9bed52ed-b275-4e3a-b9e6-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/9bed52ed-b275-4e3a-b9e6-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    parameters:
    - id: friendlyName
      type: System.String
      description: "De beschrijvende naam van het domein. Deze beschrijvende naam kan worden weergegeven in de gebruikersinterface voor het identificeren van het domein. Zie voor meer informatie <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Blijkt dat de identiteit van de code die wordt uitgevoerd in het toepassingsdomein vaststelt. Doorgeven <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> gebruiken het bewijs van het huidige toepassingsdomein."
    - id: appBasePath
      type: System.String
      description: "De basismap die de assembly-omzetter gebruikt voor de probe voor assembly&quot;s. Zie voor meer informatie <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "Het pad ten opzichte van de basismap waar de assembly-omzetter moet probe voor persoonlijke assembly&quot;s. Zie voor meer informatie <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "Als <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, een schaduwkopie van een assembly is geladen in het toepassingsdomein van deze."
    return:
      type: System.AppDomain
      description: "Het toepassingsdomein gemaakte."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw toepassingsdomein met de opgegeven naam, met behulp van bewijs, base toepassingspad relatief zoekpad en een parameter die aangeeft of een schaduwkopie van een assembly in het toepassingsdomein worden geladen. Hiermee geeft u een callback-methode wordt aangeroepen wanneer het toepassingsdomein is geïnitialiseerd en een matrix met tekenreeksargumenten om door te geven van de callback-methode."
  remarks: "The method represented by `adInit` is executed in the context of the newly created application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
    parameters:
    - id: friendlyName
      type: System.String
      description: "De beschrijvende naam van het domein. Deze beschrijvende naam kan worden weergegeven in de gebruikersinterface voor het identificeren van het domein. Zie voor meer informatie <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Blijkt dat de identiteit van de code die wordt uitgevoerd in het toepassingsdomein vaststelt. Doorgeven <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> gebruiken het bewijs van het huidige toepassingsdomein."
    - id: appBasePath
      type: System.String
      description: "De basismap die de assembly-omzetter gebruikt voor de probe voor assembly&quot;s. Zie voor meer informatie <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "Het pad ten opzichte van de basismap waar de assembly-omzetter moet probe voor persoonlijke assembly&quot;s. Zie voor meer informatie <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>een schaduwkopie van een assembly in het toepassingsdomein geladen."
    - id: adInit
      type: System.AppDomainInitializer
      description: "Een <xref href=&quot;System.AppDomainInitializer&quot;> </xref> gemachtigde die vertegenwoordigt een callback-methode aan te roepen wanneer de nieuwe <xref href=&quot;System.AppDomain&quot;> </xref> -object is geïnitialiseerd."
    - id: adInitArgs
      type: System.String[]
      description: "Een matrix van tekenreeksargumenten worden doorgegeven aan de callback die wordt vertegenwoordigd door `adInit`, wanneer de nieuwe <xref href=&quot;System.AppDomain&quot;> </xref> -object is geïnitialiseerd."
    return:
      type: System.AppDomain
      description: "Het toepassingsdomein gemaakte."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  id: CreateInstance(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly."
  remarks: "Deze methode roept de standaardconstructor voor `typeName`.       Zie <xref:System.Reflection.AssemblyName>voor de indeling van `assemblyName`.</xref:System.Reflection.AssemblyName>       Een poging om aan te roepen CreateInstance het toepassingsdomein van een doel dat niet het huidige toepassingsdomein leidt tot een succesvolle belasting van de assembly in domein van de doeltoepassing. Omdat een <xref:System.Reflection.Assembly>is niet <xref:System.MarshalByRefObject>, wanneer deze methode om terug te keren probeert de <xref:System.Reflection.Assembly>voor de geladen assembly aan het huidige toepassingsdomein de common language runtime wordt geprobeerd de assembly laadt in het huidige toepassingsdomein en de belasting kan mislukken.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> De assembly die wordt geladen in het huidige toepassingsdomein kan afwijken van de assembly die eerst is geladen als de Padinstellingen voor de twee toepassingsdomeinen verschillen."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Een object dat een wrapper voor het nieuwe exemplaar dat is opgegeven door <code> typeName </code>. De retourwaarde moet niet-ingepakte voor toegang tot het juiste object."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyName</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Geen overeenkomende openbare constructor is gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Dit exemplaar is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  id: CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly. Een parameter geeft u een matrix van activatiekenmerken."
  remarks: "Deze methode roept de standaardconstructor voor `typeName`.       Zie <xref:System.Reflection.AssemblyName>voor de indeling van `assemblyName`.</xref:System.Reflection.AssemblyName>       Een poging om aan te roepen <xref:System.AppDomain.CreateInstance%2A>op een doel toepassingsdomein dat niet het huidige toepassingsdomein leidt ertoe dat een geslaagde belasting van de assembly in domein van de doeltoepassing.</xref:System.AppDomain.CreateInstance%2A> Omdat een <xref:System.Reflection.Assembly>is niet <xref:System.MarshalByRefObject>, wanneer deze methode om terug te keren probeert de <xref:System.Reflection.Assembly>voor de geladen assembly aan het huidige toepassingsdomein de common language runtime wordt geprobeerd de assembly laadt in het huidige toepassingsdomein en de belasting kan mislukken.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> De assembly die wordt geladen in het huidige toepassingsdomein kan afwijken van de assembly die eerst is geladen als de Padinstellingen voor de twee toepassingsdomeinen verschillen."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> -object dat de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Een object dat een wrapper voor het nieuwe exemplaar dat is opgegeven door <code> typeName </code>. De retourwaarde moet niet-ingepakte voor toegang tot het juiste object."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyName</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Geen overeenkomende openbare constructor is gevonden."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Dit exemplaar is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly. Parameters geeft u een binder, bindende vlaggen, constructorargumenten, cultuur-specifieke informatie gebruikt om te interpreteren argumenten en optionele activering kenmerken."
  remarks: "Zie <xref:System.Reflection.AssemblyName>voor de indeling van `assemblyName`.</xref:System.Reflection.AssemblyName>       Een poging om aan te roepen <xref:System.AppDomain.CreateInstance%2A>op een doel toepassingsdomein dat niet het huidige toepassingsdomein leidt ertoe dat een geslaagde belasting van de assembly in domein van de doeltoepassing.</xref:System.AppDomain.CreateInstance%2A> Omdat een <xref:System.Reflection.Assembly>is niet <xref:System.MarshalByRefObject>, wanneer deze methode om terug te keren probeert de <xref:System.Reflection.Assembly>voor de geladen assembly aan het huidige toepassingsdomein de common language runtime wordt geprobeerd de assembly laadt in het huidige toepassingsdomein en de belasting kan mislukken.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> De assembly die wordt geladen in het huidige toepassingsdomein kan afwijken van de assembly die eerst is geladen als de Padinstellingen voor de twee toepassingsdomeinen verschillen."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    - id: ignoreCase
      type: System.Boolean
      description: "Een Boolean die aangeeft of een hoofdlettergevoelige zoekopdracht uitvoeren of niet."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Een combinatie van nul of meer bits vlaggen die invloed hebben op het zoeken naar de `typeName` constructor. Als `bindingAttr` is aan nul in een hoofdlettergevoelige zoekactie voor openbare constructors wordt uitgevoerd."
    - id: binder
      type: System.Reflection.Binder
      description: "Een object waarmee de binding, afdwingen van het argument van het type, aanroepen van leden, en het ophalen van <xref:System.Reflection.MemberInfo>objecten met behulp van reflectie.</xref:System.Reflection.MemberInfo> Als `binder` is null, de binder standaard wordt gebruikt."
    - id: args
      type: System.Object[]
      description: "De argumenten worden doorgegeven aan de constructor. Deze matrix van argumenten moet overeenkomen met in aantal volgorde, en typt u de parameters van de constructor aan te roepen. Als de standaardconstructor verdient de voorkeur, `args` moet een lege matrix of null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Cultuur-specifieke informatie die het afdwingen van beheerst `args` voor de formele typen is gedeclareerd voor de `typeName` constructor. Als `culture` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, wordt de <xref:System.Globalization.CultureInfo>voor de huidige thread wordt gebruikt.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> -object dat de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Een object dat een wrapper voor het nieuwe exemplaar dat is opgegeven door <code> typeName </code>. De retourwaarde moet niet-ingepakte voor toegang tot het juiste object."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - <code>assemblyName</code> is gecompileerd met een latere versie van de common language runtime dan de versie die momenteel zijn geladen."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Er is geen overeenkomende constructor gevonden."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Dit exemplaar is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly. Parameters geeft u een binder, bindende vlaggen, constructorargumenten, cultuur-specifieke informatie gebruikt om te interpreteren argumenten activatiekenmerken en autorisatie voor het maken van het type."
  remarks: "Zie <xref:System.Reflection.AssemblyName>voor de indeling van `assemblyName`.</xref:System.Reflection.AssemblyName>       Een poging om aan te roepen <xref:System.AppDomain.CreateInstance%2A>op een doel toepassingsdomein dat niet het huidige toepassingsdomein leidt ertoe dat een geslaagde belasting van de assembly in domein van de doeltoepassing.</xref:System.AppDomain.CreateInstance%2A> Omdat een <xref:System.Reflection.Assembly>is niet <xref:System.MarshalByRefObject>, wanneer deze methode om terug te keren probeert de <xref:System.Reflection.Assembly>voor de geladen assembly aan het huidige toepassingsdomein de common language runtime wordt geprobeerd de assembly laadt in het huidige toepassingsdomein en de belasting kan mislukken.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> De assembly die wordt geladen in het huidige toepassingsdomein kan afwijken van de assembly die eerst is geladen als de Padinstellingen voor de twee toepassingsdomeinen verschillen."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    - id: ignoreCase
      type: System.Boolean
      description: "Een Boolean die aangeeft of een hoofdlettergevoelige zoekopdracht uitvoeren of niet."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Een combinatie van nul of meer bits vlaggen die invloed hebben op het zoeken naar de `typeName` constructor. Als `bindingAttr` is aan nul in een hoofdlettergevoelige zoekactie voor openbare constructors wordt uitgevoerd."
    - id: binder
      type: System.Reflection.Binder
      description: "Een object waarmee de binding, afdwingen van het argument van het type, aanroepen van leden, en het ophalen van <xref:System.Reflection.MemberInfo>objecten met behulp van reflectie.</xref:System.Reflection.MemberInfo> Als `binder` is null, de binder standaard wordt gebruikt."
    - id: args
      type: System.Object[]
      description: "De argumenten worden doorgegeven aan de constructor. Deze matrix van argumenten moet overeenkomen met in aantal volgorde, en typt u de parameters van de constructor aan te roepen. Als de standaardconstructor verdient de voorkeur, `args` moet een lege matrix of null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Cultuur-specifieke informatie die het afdwingen van beheerst `args` voor de formele typen is gedeclareerd voor de `typeName` constructor. Als `culture` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, wordt de <xref:System.Globalization.CultureInfo>voor de huidige thread wordt gebruikt.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> -object dat de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informatie die wordt gebruikt voor het maken van autoriseren `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Een object dat een wrapper voor het nieuwe exemplaar dat is opgegeven door <code> typeName </code>. De retourwaarde moet niet-ingepakte voor toegang tot het juiste object."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyName</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Er is geen overeenkomende constructor gevonden."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Wanneer het verouderde CAS-beleid niet is ingeschakeld, <code> securityAttributes </code> moet<xref uid=&quot;langword_csharp_null.&quot; name=&quot;null.&quot; href=&quot;&quot;></xref>"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Dit exemplaar is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  id: CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type. Parameters geeft u de assembly waarin het type is gedefinieerd en de naam van het type."
  remarks: "Dit is een methode voor uw gemak die <xref:System.AppDomain.CreateInstance%2A>en <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> combineert</xref:System.AppDomain.CreateInstance%2A> Deze methode roept de standaardconstructor voor `typeName`.       Zie <xref:System.Reflection.AssemblyName>voor de indeling van `assemblyName`.</xref:System.Reflection.AssemblyName> Zie de <xref:System.Type.FullName%2A?displayProperty=fullName>eigenschap voor de indeling van `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Als u een vroege gebonden aanroep van een methode `M` van een object van het type `T1` die is geretourneerd door CreateInstanceAndUnwrap en deze methode maakt een vroege gebonden aanroep van een methode van een object van het type `T2` in een assembly `C` dan de huidige assembly of de assembly met `T1`, assembly `C` wordt in het huidige toepassingsdomein geladen. Deze laden gebeurt zelfs als de vroege gebonden aanroep `T1.M()` is aangebracht in de hoofdtekst van een <xref:System.Reflection.Emit.DynamicMethod>, of in andere dynamisch gegenereerde code.</xref:System.Reflection.Emit.DynamicMethod> Als het huidige domein het standaarddomein assembly is `C` kan niet worden verwijderd totdat het proces is beëindigd. Als het huidige domein later probeert assembly te laden `C`, de belasting kan mislukken."
  example:
  - "The following code example shows the simplest way to execute code in another application domain. The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>. The `Worker` class defines a method that displays the name of the application domain in which it is executing. The example creates instances of `Worker` in the default application domain and in a new application domain.  \n  \n> [!NOTE]\n>  The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.  \n  \n [!code-cpp[CreateInstanceAndUnwrap2#1](~/add/codesnippet/cpp/m-system.appdomain.creat_2_1.cpp)]\n [!code-cs[CreateInstanceAndUnwrap2#1](~/add/codesnippet/csharp/m-system.appdomain.creat_2_1.cs)]\n [!code-vb[CreateInstanceAndUnwrap2#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_2_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    return:
      type: System.Object
      description: "Een exemplaar van het object dat is opgegeven door <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Geen overeenkomende openbare constructor is gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyName</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type. Parameters geeft u de assembly waarin het type is gedefinieerd, de naam van het type en een matrix van activatiekenmerken."
  remarks: "Dit is een methode voor uw gemak die <xref:System.AppDomain.CreateInstance%2A>en <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> combineert</xref:System.AppDomain.CreateInstance%2A> Deze methode roept de standaardconstructor voor `typeName`.       Zie <xref:System.Reflection.AssemblyName>voor de indeling van `assemblyName`.</xref:System.Reflection.AssemblyName> Zie de <xref:System.Type.FullName%2A?displayProperty=fullName>eigenschap voor de indeling van `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Als u een vroege gebonden aanroep van een methode `M` van een object van het type `T1` die is geretourneerd door <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, en dat de methode een vroege gebonden aanroep van een methode van een object van het type maakt `T2` in een assembly `C` dan de huidige assembly of de assembly met `T1`, assembly `C` is geladen in het huidige toepassingsdomein.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Deze laden gebeurt zelfs als de vroege gebonden aanroep `T1.M()` is aangebracht in de hoofdtekst van een <xref:System.Reflection.Emit.DynamicMethod>, of in andere dynamisch gegenereerde code.</xref:System.Reflection.Emit.DynamicMethod> Als het huidige domein het standaarddomein assembly is `C` kan niet worden verwijderd totdat het proces is beëindigd. Als het huidige domein later probeert assembly te laden `C`, de belasting kan mislukken."
  example:
  - >-
    [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/ec186439-6d54-4090-82e0-_1.cpp)]
     [!code-cs[ADDyno#1](~/add/codesnippet/csharp/ec186439-6d54-4090-82e0-_1.cs)]
     [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/ec186439-6d54-4090-82e0-_1.vb)]
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> -object dat de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    return:
      type: System.Object
      description: "Een exemplaar van het object dat is opgegeven door <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Geen overeenkomende openbare constructor is gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyName</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly, die aangeeft of het geval van de naam van het type wordt genegeerd. de kenmerken van de binding en de binder die worden gebruikt voor het selecteren van het type moet worden gemaakt; de argumenten van de constructor; de cultuur; en de kenmerken voor activering."
  remarks: "Dit is een methode voor uw gemak die <xref:System.AppDomain.CreateInstance%2A>en <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> combineert</xref:System.AppDomain.CreateInstance%2A>       Zie <xref:System.Reflection.AssemblyName>voor de indeling van `assemblyName`.</xref:System.Reflection.AssemblyName> Zie de <xref:System.Type.FullName%2A?displayProperty=fullName>eigenschap voor de indeling van `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Als u een vroege gebonden aanroep van een methode `M` van een object van het type `T1` die is geretourneerd door <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, en dat de methode een vroege gebonden aanroep van een methode van een object van het type maakt `T2` in een assembly `C` dan de huidige assembly of de assembly met `T1`, assembly `C` is geladen in het huidige toepassingsdomein.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Deze laden gebeurt zelfs als de vroege gebonden aanroep `T1.M()` is aangebracht in de hoofdtekst van een <xref:System.Reflection.Emit.DynamicMethod>, of in andere dynamisch gegenereerde code.</xref:System.Reflection.Emit.DynamicMethod> Als het huidige domein het standaarddomein assembly is `C` kan niet worden verwijderd totdat het proces is beëindigd. Als het huidige domein later probeert assembly te laden `C`, de belasting kan mislukken."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/7b1dcc86-9680-463d-b78c-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/7b1dcc86-9680-463d-b78c-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/7b1dcc86-9680-463d-b78c-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    - id: ignoreCase
      type: System.Boolean
      description: "Een Boolean die aangeeft of een hoofdlettergevoelige zoekopdracht uitvoeren of niet."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Een combinatie van nul of meer bits vlaggen die invloed hebben op het zoeken naar de `typeName` constructor. Als `bindingAttr` is aan nul in een hoofdlettergevoelige zoekactie voor openbare constructors wordt uitgevoerd."
    - id: binder
      type: System.Reflection.Binder
      description: "Een object waarmee de binding, afdwingen van het argument van het type, aanroepen van leden, en het ophalen van <xref:System.Reflection.MemberInfo>objecten met behulp van reflectie.</xref:System.Reflection.MemberInfo> Als `binder` is null, de binder standaard wordt gebruikt."
    - id: args
      type: System.Object[]
      description: "De argumenten worden doorgegeven aan de constructor. Deze matrix van argumenten moet overeenkomen met in aantal volgorde, en typt u de parameters van de constructor aan te roepen. Als de standaardconstructor verdient de voorkeur, `args` moet een lege matrix of null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Een cultuur-specifieke object dat wordt gebruikt om te bepalen van het afdwingen van typen. Als `culture` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, wordt de <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> voor de huidige thread wordt gebruikt."
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> object. Hiermee worden de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    return:
      type: System.Object
      description: "Een exemplaar van het object dat is opgegeven door <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Er is geen overeenkomende constructor gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - <code>assemblyName</code> is gecompileerd met een latere versie van de common language runtime dan de versie die momenteel zijn geladen."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type. Parameters voor het opgeven van het type en hoe deze wordt gevonden en gemaakt."
  remarks: "Dit is een methode voor uw gemak die <xref:System.AppDomain.CreateInstance%2A>en <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> combineert</xref:System.AppDomain.CreateInstance%2A>       Zie <xref:System.Reflection.AssemblyName>voor de indeling van `assemblyName`.</xref:System.Reflection.AssemblyName> Zie de <xref:System.Type.FullName%2A?displayProperty=fullName>eigenschap voor de indeling van `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Als u een vroege gebonden aanroep van een methode `M` van een object van het type `T1` die is geretourneerd door <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, en dat de methode een vroege gebonden aanroep van een methode van een object van het type maakt `T2` in een assembly `C` dan de huidige assembly of de assembly met `T1`, assembly `C` is geladen in het huidige toepassingsdomein.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Deze laden gebeurt zelfs als de vroege gebonden aanroep `T1.M()` is aangebracht in de hoofdtekst van een <xref:System.Reflection.Emit.DynamicMethod>, of in andere dynamisch gegenereerde code.</xref:System.Reflection.Emit.DynamicMethod> Als het huidige domein het standaarddomein assembly is `C` kan niet worden verwijderd totdat het proces is beëindigd. Als het huidige domein later probeert assembly te laden `C`, de belasting kan mislukken."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/8e0d44ad-3def-4658-8d9d-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/8e0d44ad-3def-4658-8d9d-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/8e0d44ad-3def-4658-8d9d-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    - id: ignoreCase
      type: System.Boolean
      description: "Een Boolean die aangeeft of een hoofdlettergevoelige zoekopdracht uitvoeren of niet."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Een combinatie van nul of meer bits vlaggen die invloed hebben op het zoeken naar de `typeName` constructor. Als `bindingAttr` is aan nul in een hoofdlettergevoelige zoekactie voor openbare constructors wordt uitgevoerd."
    - id: binder
      type: System.Reflection.Binder
      description: "Een object waarmee de binding, afdwingen van het argument van het type, aanroepen van leden, en het ophalen van <xref:System.Reflection.MemberInfo>objecten met behulp van reflectie.</xref:System.Reflection.MemberInfo> Als `binder` is null, de binder standaard wordt gebruikt."
    - id: args
      type: System.Object[]
      description: "De argumenten worden doorgegeven aan de constructor. Deze matrix van argumenten moet overeenkomen met in aantal volgorde, en typt u de parameters van de constructor aan te roepen. Als de standaardconstructor verdient de voorkeur, `args` moet een lege matrix of null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Een cultuur-specifieke object dat wordt gebruikt om te bepalen van het afdwingen van typen. Als `culture` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, wordt de <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> voor de huidige thread wordt gebruikt."
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> -object dat de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informatie die wordt gebruikt voor het maken van autoriseren `typeName`."
    return:
      type: System.Object
      description: "Een exemplaar van het object dat is opgegeven door <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Er is geen overeenkomende constructor gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyName</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  id: CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly-bestand."
  remarks: "De standaardconstructor voor `typeName` wordt aangeroepen.       Zie voor meer informatie de <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>methode.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Wanneer de methode CreateInstanceFrom wordt gebruikt voor het maken van een instantie in een doeldomein toepassing, behalve het toepassingsdomein waarvan de oproep is gemaakt, is de assembly is geladen in het domein van de doeltoepassing. Echter, als de instantie niet-ingepakte in de aanroepende toepassingsdomein is, met de niet-ingepakte instantie op bepaalde manieren kan veroorzaken de assembly moet worden geladen in het toepassingsdomein van de aanroepende. Bijvoorbeeld, nadat het exemplaar is niet-ingepakte, de type-informatie kan worden aangevraagd, om de bijbehorende methoden aanroepen laat-gebonden. Als de assembly geladen in de aanroepende toepassingsdomein is, kunnen uitzonderingen optreden.      -Als een andere versie van dezelfde assembly eerder is geladen in het toepassingsdomein van de aanroepende, of als het pad van het laden van de aanroepende toepassingsdomein verschilt van die van het domein van de doeltoepassing, uitzonderingen, zoals <xref:System.MissingMethodException>kan zich voordoen.</xref:System.MissingMethodException>      -Als de aanroepende toepassingsdomein vroeg gebonden aanroepen naar het exemplaartype worden <xref:System.InvalidCastException>kan worden gegenereerd wanneer er een poging wordt gedaan voor het casten van het exemplaar.</xref:System.InvalidCastException>"
  example:
  - "The following example shows how to use the CreateInstanceFrom method overload to create an instance of an object in a target application domain and call its methods.  \n  \n The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries. The example builds a path to the currently executing assembly, creates a target application domain, and uses the CreateInstanceFrom method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.  \n  \n> [!NOTE]\n>  The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method is used to load the assembly.  \n  \n After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:  \n  \n-   Invoking a method with late binding, using reflection. This requires type information, which causes the assembly to be loaded into the application domain of the caller. (In this example, it is already loaded.)  \n  \n-   Casting the object to an interface known to both the caller and the callee. If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.  \n  \n-   Using the object directly when its type is known to the caller. The assembly must be loaded into the application domain of the caller.  \n  \n Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain. That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain. See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cs[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/csharp/m-system.appdomain.creat_3_1.cs)]\n [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/cpp/m-system.appdomain.creat_3_1.cpp)]\n [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_3_1.vb)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De naam, inclusief het pad, van een bestand met een assembly die het aangevraagde type definieert. De assembly is geladen met de <xref:System.Reflection.Assembly.LoadFrom*>methode.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Een object dat een wrapper voor het nieuwe exemplaar of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als <code> typeName </code> is niet gevonden. De retourwaarde moet niet-ingepakte voor toegang tot het juiste object."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>is niet gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>is niet gevonden in <code>assemblyFile</code>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Er is geen openbare parameterloze constructor gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyFile</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Dit exemplaar is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly-bestand."
  remarks: "De standaardconstructor voor `typeName` wordt aangeroepen.       Zie voor meer informatie over deze methode de <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>methode.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Wanneer de <xref:System.AppDomain.CreateInstanceFrom%2A>methode wordt gebruikt voor het maken van een instantie in een doeldomein toepassing, behalve het toepassingsdomein van waaruit de aanroep, de assembly is geladen in het domein van de doeltoepassing.</xref:System.AppDomain.CreateInstanceFrom%2A> Echter, als de instantie niet-ingepakte in de aanroepende toepassingsdomein is, met de niet-ingepakte instantie op bepaalde manieren kan veroorzaken de assembly moet worden geladen in het toepassingsdomein van de aanroepende. Bijvoorbeeld, nadat het exemplaar is niet-ingepakte, de type-informatie kan worden aangevraagd, om de bijbehorende methoden aanroepen laat-gebonden. Als de assembly geladen in de aanroepende toepassingsdomein is, kunnen uitzonderingen optreden.      -Als een andere versie van dezelfde assembly eerder is geladen in het toepassingsdomein van de aanroepende, of als het pad van het laden van de aanroepende toepassingsdomein verschilt van die van het domein van de doeltoepassing, uitzonderingen, zoals <xref:System.MissingMethodException>kan zich voordoen.</xref:System.MissingMethodException>      -Als de aanroepende toepassingsdomein vroeg gebonden aanroepen naar het exemplaartype worden <xref:System.InvalidCastException>kan worden gegenereerd wanneer er een poging wordt gedaan voor het casten van het exemplaar.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De naam, inclusief het pad, van een bestand met een assembly die het aangevraagde type definieert. De assembly is geladen met de <xref:System.Reflection.Assembly.LoadFrom*>methode.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> -object dat de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Een object dat een wrapper voor het nieuwe exemplaar of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als <code> typeName </code> is niet gevonden. De retourwaarde moet niet-ingepakte voor toegang tot het juiste object."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>is niet gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>is niet gevonden in <code>assemblyFile</code>."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Geen overeenkomende openbare constructor is gevonden."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyFile</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Dit exemplaar is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly-bestand."
  remarks: "Zie voor meer informatie de <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>methode.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Wanneer de <xref:System.AppDomain.CreateInstanceFrom%2A>methode wordt gebruikt voor het maken van een instantie in een doeldomein toepassing, behalve het toepassingsdomein van waaruit de aanroep, de assembly is geladen in het domein van de doeltoepassing.</xref:System.AppDomain.CreateInstanceFrom%2A> Echter, als de instantie niet-ingepakte in de aanroepende toepassingsdomein is, met de niet-ingepakte instantie op bepaalde manieren kan veroorzaken de assembly moet worden geladen in het toepassingsdomein van de aanroepende. Bijvoorbeeld, nadat het exemplaar is niet-ingepakte, de type-informatie kan worden aangevraagd, om de bijbehorende methoden aanroepen laat-gebonden. Als de assembly geladen in de aanroepende toepassingsdomein is, kunnen uitzonderingen optreden.      -Als een andere versie van dezelfde assembly eerder is geladen in het toepassingsdomein van de aanroepende, of als het pad van het laden van de aanroepende toepassingsdomein verschilt van die van het domein van de doeltoepassing, uitzonderingen, zoals <xref:System.MissingMethodException>kan zich voordoen.</xref:System.MissingMethodException>      -Als de aanroepende toepassingsdomein vroeg gebonden aanroepen naar het exemplaartype worden <xref:System.InvalidCastException>kan worden gegenereerd wanneer er een poging wordt gedaan voor het casten van het exemplaar.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De naam, inclusief het pad, van een bestand met een assembly die het aangevraagde type definieert. De assembly is geladen met de <xref:System.Reflection.Assembly.LoadFrom*>methode.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    - id: ignoreCase
      type: System.Boolean
      description: "Een Boolean die aangeeft of een hoofdlettergevoelige zoekopdracht uitvoeren of niet."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Een combinatie van nul of meer bits vlaggen die invloed hebben op het zoeken naar de `typeName` constructor. Als `bindingAttr` is aan nul in een hoofdlettergevoelige zoekactie voor openbare constructors wordt uitgevoerd."
    - id: binder
      type: System.Reflection.Binder
      description: "Een object waarmee de binding, afdwingen van het argument van het type, aanroepen van leden, en het ophalen van <xref:System.Reflection.MemberInfo>objecten via reflectie.</xref:System.Reflection.MemberInfo> Als `binder` is null, de binder standaard wordt gebruikt."
    - id: args
      type: System.Object[]
      description: "De argumenten worden doorgegeven aan de constructor. Deze matrix van argumenten moet overeenkomen met in aantal volgorde, en typt u de parameters van de constructor aan te roepen. Als de standaardconstructor verdient de voorkeur, `args` moet een lege matrix of null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Cultuur-specifieke informatie die het afdwingen van beheerst `args` voor de formele typen is gedeclareerd voor de `typeName` constructor. Als `culture` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, wordt de <xref:System.Globalization.CultureInfo>voor de huidige thread wordt gebruikt.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> -object dat de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Een object dat een wrapper voor het nieuwe exemplaar of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als <code> typeName </code> is niet gevonden. De retourwaarde moet niet-ingepakte voor toegang tot het juiste object."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>is niet gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>is niet gevonden in <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Geen overeenkomende openbare constructor is gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>is geen geldige assembly.       - of - <code>assemblyFile</code> is gecompileerd met een latere versie van de common language runtime dan de versie die momenteel zijn geladen."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Dit exemplaar is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly-bestand."
  remarks: "Zie voor meer informatie over deze methode de <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>methode.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Wanneer de <xref:System.AppDomain.CreateInstanceFrom%2A>methode wordt gebruikt voor het maken van een instantie in een doeldomein toepassing, behalve het toepassingsdomein van waaruit de aanroep, de assembly is geladen in het domein van de doeltoepassing.</xref:System.AppDomain.CreateInstanceFrom%2A> Echter, als de instantie niet-ingepakte in de aanroepende toepassingsdomein is, met de niet-ingepakte instantie op bepaalde manieren kan veroorzaken de assembly moet worden geladen in het toepassingsdomein van de aanroepende. Bijvoorbeeld, nadat het exemplaar is niet-ingepakte, de type-informatie kan worden aangevraagd, om de bijbehorende methoden aanroepen laat-gebonden. Als de assembly geladen in de aanroepende toepassingsdomein is, kunnen uitzonderingen optreden.      -Als een andere versie van dezelfde assembly eerder is geladen in het toepassingsdomein van de aanroepende, of als het pad van het laden van de aanroepende toepassingsdomein verschilt van die van het domein van de doeltoepassing, uitzonderingen, zoals <xref:System.MissingMethodException>kan zich voordoen.</xref:System.MissingMethodException>      -Als de aanroepende toepassingsdomein vroeg gebonden aanroepen naar het exemplaartype worden <xref:System.InvalidCastException>kan worden gegenereerd wanneer er een poging wordt gedaan voor het casten van het exemplaar.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De naam, inclusief het pad, van een bestand met een assembly die het aangevraagde type definieert. De assembly is geladen met de <xref:System.Reflection.Assembly.LoadFrom*>methode.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    - id: ignoreCase
      type: System.Boolean
      description: "Een Boolean die aangeeft of een hoofdlettergevoelige zoekopdracht uitvoeren of niet."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Een combinatie van nul of meer bits vlaggen die invloed hebben op het zoeken naar de `typeName` constructor. Als `bindingAttr` is aan nul in een hoofdlettergevoelige zoekactie voor openbare constructors wordt uitgevoerd."
    - id: binder
      type: System.Reflection.Binder
      description: "Een object waarmee de binding, afdwingen van het argument van het type, aanroepen van leden, en het ophalen van <xref:System.Reflection.MemberInfo>objecten via reflectie.</xref:System.Reflection.MemberInfo> Als `binder` is null, de binder standaard wordt gebruikt."
    - id: args
      type: System.Object[]
      description: "De argumenten worden doorgegeven aan de constructor. Deze matrix van argumenten moet overeenkomen met in aantal volgorde, en typt u de parameters van de constructor aan te roepen. Als de standaardconstructor verdient de voorkeur, `args` moet een lege matrix of null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Cultuur-specifieke informatie die het afdwingen van beheerst `args` voor de formele typen is gedeclareerd voor de `typeName` constructor. Als `culture` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, wordt de <xref:System.Globalization.CultureInfo>voor de huidige thread wordt gebruikt.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> -object dat de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informatie die wordt gebruikt voor het maken van autoriseren `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Een object dat een wrapper voor het nieuwe exemplaar of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als <code> typeName </code> is niet gevonden. De retourwaarde moet niet-ingepakte voor toegang tot het juiste object."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Wanneer het verouderde CAS-beleid niet is ingeschakeld, <code> securityAttributes </code> moet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>is niet gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>is niet gevonden in <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Geen overeenkomende openbare constructor is gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyFile</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Dit exemplaar is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  id: CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly-bestand."
  remarks: "Dit is een methode voor uw gemak die <xref:System.AppDomain.CreateInstanceFrom%2A>en <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> combineert</xref:System.AppDomain.CreateInstanceFrom%2A> Deze methode roept de standaardconstructor voor `typeName`.       Zie voor meer informatie de <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>methode.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De bestandsnaam en pad van de assembly waarin het aangevraagde type."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    return:
      type: System.Object
      description: "Het gevraagde object of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als <code> typeName </code> is niet gevonden."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Er is geen openbare parameterloze constructor gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyName</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly-bestand."
  remarks: "Dit is een methode voor uw gemak die <xref:System.AppDomain.CreateInstanceFrom%2A>en <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> combineert</xref:System.AppDomain.CreateInstanceFrom%2A> Deze methode roept de standaardconstructor voor `typeName`.       Zie voor meer informatie over deze methode de <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>methode.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De bestandsnaam en pad van de assembly waarin het aangevraagde type."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly (Zie de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap)."
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> -object dat de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    return:
      type: System.Object
      description: "Het gevraagde object of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als <code> typeName </code> is niet gevonden."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Er is geen openbare parameterloze constructor gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyName</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type gedefinieerd in de opgegeven assembly-bestand opgeven of het geval van de naam van het type wordt genegeerd. de kenmerken van de binding en de binder die worden gebruikt voor het selecteren van het type moet worden gemaakt; de argumenten van de constructor; de cultuur; en de kenmerken voor activering."
  remarks: "Dit is een methode voor uw gemak die <xref:System.AppDomain.CreateInstanceFrom%2A>en <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> combineert</xref:System.AppDomain.CreateInstanceFrom%2A>       Zie voor meer informatie over deze methode de <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>methode.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De bestandsnaam en pad van de assembly waarin het aangevraagde type."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    - id: ignoreCase
      type: System.Boolean
      description: "Een Boolean die aangeeft of een hoofdlettergevoelige zoekopdracht uitvoeren of niet."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Een combinatie van nul of meer bits vlaggen die invloed hebben op het zoeken naar de `typeName` constructor. Als `bindingAttr` is aan nul in een hoofdlettergevoelige zoekactie voor openbare constructors wordt uitgevoerd."
    - id: binder
      type: System.Reflection.Binder
      description: "Een object waarmee de binding, afdwingen van het argument van het type, aanroepen van leden, en het ophalen van <xref:System.Reflection.MemberInfo>objecten via reflectie.</xref:System.Reflection.MemberInfo> Als `binder` is null, de binder standaard wordt gebruikt."
    - id: args
      type: System.Object[]
      description: "De argumenten worden doorgegeven aan de constructor. Deze matrix van argumenten moet overeenkomen met in aantal volgorde, en typt u de parameters van de constructor aan te roepen. Als de standaardconstructor verdient de voorkeur, `args` moet een lege matrix of null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Cultuur-specifieke informatie die het afdwingen van beheerst `args` voor de formele typen is gedeclareerd voor de `typeName` constructor. Als `culture` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, wordt de <xref:System.Globalization.CultureInfo>voor de huidige thread wordt gebruikt.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> -object dat de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    return:
      type: System.Object
      description: "Het gevraagde object of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als <code> typeName </code> is niet gevonden."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Geen overeenkomende openbare constructor is gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - <code>assemblyName</code> is gecompileerd met een nieuwere versie van de common language runtime de versie die is momenteel geladen."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Maakt een nieuw exemplaar van het opgegeven type is gedefinieerd in de opgegeven assembly-bestand."
  remarks: "Dit is een methode voor uw gemak die <xref:System.AppDomain.CreateInstanceFrom%2A>en <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> combineert</xref:System.AppDomain.CreateInstanceFrom%2A>       Zie voor meer informatie over deze methode de <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>methode.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De bestandsnaam en pad van de assembly waarin het aangevraagde type."
    - id: typeName
      type: System.String
      description: "De volledig gekwalificeerde naam van het aangevraagde type, met inbegrip van de naamruimte, maar niet de assembly die wordt geretourneerd door de &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; eigenschap."
    - id: ignoreCase
      type: System.Boolean
      description: "Een Boolean die aangeeft of een hoofdlettergevoelige zoekopdracht uitvoeren of niet."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Een combinatie van nul of meer bits vlaggen die invloed hebben op het zoeken naar de `typeName` constructor. Als `bindingAttr` is aan nul in een hoofdlettergevoelige zoekactie voor openbare constructors wordt uitgevoerd."
    - id: binder
      type: System.Reflection.Binder
      description: "Een object waarmee de binding, afdwingen van het argument van het type, aanroepen van leden, en het ophalen van <xref:System.Reflection.MemberInfo>objecten via reflectie.</xref:System.Reflection.MemberInfo> Als `binder` is null, de binder standaard wordt gebruikt."
    - id: args
      type: System.Object[]
      description: "De argumenten worden doorgegeven aan de constructor. Deze matrix van argumenten moet overeenkomen met in aantal volgorde, en typt u de parameters van de constructor aan te roepen. Als de standaardconstructor verdient de voorkeur, `args` moet een lege matrix of null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Cultuur-specifieke informatie die het afdwingen van beheerst `args` voor de formele typen is gedeclareerd voor de `typeName` constructor. Als `culture` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, wordt de <xref:System.Globalization.CultureInfo>voor de huidige thread wordt gebruikt.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Een matrix met een of meer kenmerken die aan het activering deelnemen kunnen. Normaal gesproken een matrix met één <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> -object dat de URL die is vereist voor het activeren van een extern object.       Deze parameter is gerelateerd aan objecten client geactiveerd. Activering van de client is een oudere technologie die voor achterwaartse compatibiliteit wordt bewaard, maar wordt niet aanbevolen voor de ontwikkeling van nieuwe. Gedistribueerde toepassingen gebruik in plaats daarvan Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informatie die wordt gebruikt voor het maken van autoriseren `typeName`."
    return:
      type: System.Object
      description: "Het gevraagde object of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als <code> typeName </code> is niet gevonden."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De aanroeper kan geen activatiekenmerken opgeven voor een object dat niet van overgenomen is <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>is niet gevonden."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>is niet gevonden in <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Geen overeenkomende openbare constructor is gevonden."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "De aanroeper is niet gemachtigd deze constructor niet aanroepen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyName</code> is gecompileerd met een latere versie."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.CurrentDomain
  id: CurrentDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee wordt het huidige toepassingsdomein voor de huidige <xref href=&quot;System.Threading.Thread&quot;> </xref>."
  remarks: ''
  example:
  - "The following code example creates a new application domain. The CurrentDomain property is used to obtain an <xref:System.AppDomain> object that represents the current application domain. The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.curre_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.curre_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.curre_1.cs)]"
  syntax:
    content: public static AppDomain CurrentDomain { get; }
    return:
      type: System.AppDomain
      description: "Het huidige toepassingsdomein."
  overload: System.AppDomain.CurrentDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam en -modus."
  remarks: "Deze methode mag alleen worden gebruikt voor het definiëren van een dynamische assembly in het huidige toepassingsdomein. Zie voor meer informatie de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Tijdens de ontwikkeling van code die dynamische assembly&quot;s verzendt, wordt aanbevolen dat u een overbelasting van de <xref:System.AppDomain.DefineDynamicAssembly%2A>methode waarmee bewijs en machtigingen, geef het bewijs dat u wilt dat de dynamische assembly hebben en opnemen <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inclusief <xref:System.Security.Permissions.SecurityPermissionFlag>in de `refusedPermissions` parameter zorgt ervoor dat de MSIL is geverifieerd.</xref:System.Security.Permissions.SecurityPermissionFlag> Een beperking van deze techniek is dat ook wordt veroorzaakt <xref:System.Security.SecurityException>gegenereerd gebruikt in combinatie met de code die volledig vertrouwen vereist.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the DefineDynamicAssembly method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/ec69fa93-4aea-4fc8-90e1-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/ec69fa93-4aea-4fc8-90e1-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/ec69fa93-4aea-4fc8-90e1-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De toegangsmodus voor de dynamische assembly."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en -modus."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met witruimte of een slash vooruit of achteruit bevat."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam, toegangsmodus en aangepaste kenmerken."
  remarks: "Gebruik deze methode-overload om kenmerken die niet goed werken tenzij deze worden toegepast wanneer een dynamische assembly wordt gemaakt. Bijvoorbeeld, beveiligingskenmerken zoals <xref:System.Security.SecurityTransparentAttribute>en <xref:System.Security.SecurityCriticalAttribute>werken niet goed werken als ze worden toegevoegd nadat een dynamische assembly is gemaakt.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Deze methode mag alleen voor het definiëren van een dynamische assembly in het huidige toepassingsdomein worden gebruikt. Zie voor meer informatie over deze beperking, de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>       Deze methode-overload is opgenomen in de [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>. The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.  \n  \n The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute. The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters. The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.  \n  \n The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the DefineDynamicAssembly method as the only element of an array.  \n  \n The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.  \n  \n [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/cpp/02b9ff71-a699-4692-a2ae-_1.cpp)]\n [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/visualbasic/02b9ff71-a699-4692-a2ae-_1.vb)]\n [!code-cs[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/csharp/02b9ff71-a699-4692-a2ae-_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De toegangsmodus voor de dynamische assembly."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Een inventariseerbare lijst met kenmerken moeten worden toegepast op de assembly of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er geen kenmerken zijn."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met spaties of bevat een slash vooruit of terug."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam, toegangsmodus en bewijs."
  remarks: "Alleen volledig vertrouwde aanroepfuncties kunnen voorzien van hun `evidence` bij het definiëren van een dynamische <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> De runtime koppelt de <xref:System.Security.Policy.Evidence>via het beveiligingsbeleid om te bepalen van de verleende machtigingen.</xref:System.Security.Policy.Evidence> Gedeeltelijk vertrouwde aanroepfuncties moeten een null-waarde opgeven `evidence`. Als `evidence` is `null`, de runtime kopieert de machtigingensets, dat wil zeggen, de huidige verlenen en weigeren sets, van de aanroeper <xref:System.Reflection.Assembly>naar de dynamische <xref:System.Reflection.Assembly>wordt gedefinieerd en beleid worden gemarkeerd als opgelost.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Als de dynamische <xref:System.Reflection.Assembly>is opgeslagen op schijf, krijgen volgende belasting verleent op basis van beleidsregels die zijn gekoppeld aan de locatie waar de <xref:System.Reflection.Assembly>is opgeslagen.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Deze methode mag alleen worden gebruikt voor het definiëren van een dynamische assembly in het huidige toepassingsdomein. Zie voor meer informatie de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Tijdens de ontwikkeling van code die dynamische assembly&quot;s verzendt, wordt aanbevolen dat u een overbelasting van de <xref:System.AppDomain.DefineDynamicAssembly%2A>methode waarmee bewijs en machtigingen, geef het bewijs dat u wilt dat de dynamische assembly hebben en opnemen <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inclusief <xref:System.Security.Permissions.SecurityPermissionFlag>in de `refusedPermissions` parameter zorgt ervoor dat de MSIL is geverifieerd.</xref:System.Security.Permissions.SecurityPermissionFlag> Een beperking van deze techniek is dat ook wordt veroorzaakt <xref:System.Security.SecurityException>gegenereerd gebruikt in combinatie met de code die volledig vertrouwen vereist.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.  \n  \n First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.  \n  \n The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`. During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly. The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly. The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/1d1d705b-aac9-4233-8756-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/1d1d705b-aac9-4233-8756-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/1d1d705b-aac9-4233-8756-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De modus waarin de dynamische assembly wordt geopend."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Het bewijs dat is opgegeven voor de dynamische assembly. Het bewijs wordt gebruikt als de uiteindelijke set bewijs gebruikt voor het omzetten van het beleid ongewijzigd."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met witruimte of een slash vooruit of achteruit bevat."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam, toegangsmodus en opslagmap."
  remarks: "Deze methode mag alleen worden gebruikt voor het definiëren van een dynamische assembly in het huidige toepassingsdomein. Zie voor meer informatie de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Tijdens de ontwikkeling van code die dynamische assembly&quot;s verzendt, wordt aanbevolen dat u een overbelasting van de <xref:System.AppDomain.DefineDynamicAssembly%2A>methode waarmee bewijs en machtigingen, geef het bewijs dat u wilt dat de dynamische assembly hebben en opnemen <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inclusief <xref:System.Security.Permissions.SecurityPermissionFlag>in de `refusedPermissions` parameter zorgt ervoor dat de MSIL is geverifieerd.</xref:System.Security.Permissions.SecurityPermissionFlag> Een beperking van deze techniek is dat ook wordt veroorzaakt <xref:System.Security.SecurityException>gegenereerd gebruikt in combinatie met de code die volledig vertrouwen vereist.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/f3a30d18-28ff-4503-b1c6-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/f3a30d18-28ff-4503-b1c6-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/f3a30d18-28ff-4503-b1c6-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De modus waarin de dynamische assembly wordt geopend."
    - id: dir
      type: System.String
      description: "De naam van de map waarin de assembly moet worden opgeslagen. Als `dir` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, de map wordt standaard ingesteld op de huidige map."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met witruimte of een slash vooruit of achteruit bevat."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definieert een dynamische assembly met de opgegeven naam, toegangsmodus en aangepaste kenmerken, en het gebruik van de opgegeven bron voor de beveiligingscontext."
  remarks: "Gebruik deze methode-overload om kenmerken die niet goed werken tenzij deze worden toegepast wanneer een dynamische assembly wordt gemaakt. Bijvoorbeeld, beveiligingskenmerken zoals <xref:System.Security.SecurityTransparentAttribute>en <xref:System.Security.SecurityCriticalAttribute>werken niet goed werken als ze worden toegevoegd nadat een dynamische assembly is gemaakt.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Deze methode mag alleen voor het definiëren van een dynamische assembly in het huidige toepassingsdomein worden gebruikt. Zie voor meer informatie over deze beperking, de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes, System.Security.SecurityContextSource securityContextSource);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De toegangsmodus voor de dynamische assembly."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Een inventariseerbare lijst met kenmerken moeten worden toegepast op de assembly of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er geen kenmerken zijn."
    - id: securityContextSource
      type: System.Security.SecurityContextSource
      description: "De bron van de beveiligingscontext."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met spaties of bevat een slash vooruit of terug."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De waarde van <code> securityContextSource </code> is niet een van de opsommingswaarden."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam, toegangsmodus, opslagmap en bewijs."
  remarks: "Alleen volledig vertrouwde aanroepfuncties kunnen voorzien van hun `evidence` bij het definiëren van een dynamische <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> De runtime koppelt de <xref:System.Security.Policy.Evidence>via het beveiligingsbeleid om te bepalen van de verleende machtigingen.</xref:System.Security.Policy.Evidence> Gedeeltelijk vertrouwde aanroepfuncties moeten een null-waarde opgeven `evidence`. Als `evidence` is `null`, de runtime kopieert de machtigingensets, dat wil zeggen, de huidige verlenen en weigeren sets, van de aanroeper <xref:System.Reflection.Assembly>naar de dynamische <xref:System.Reflection.Assembly>wordt gedefinieerd en beleid worden gemarkeerd als opgelost.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Als de dynamische <xref:System.Reflection.Assembly>is opgeslagen op schijf, krijgen volgende belasting verleent op basis van beleidsregels die zijn gekoppeld aan de locatie waar de <xref:System.Reflection.Assembly>is opgeslagen.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Deze methode mag alleen worden gebruikt voor het definiëren van een dynamische assembly in het huidige toepassingsdomein. Zie voor meer informatie de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Tijdens de ontwikkeling van code die dynamische assembly&quot;s verzendt, wordt aanbevolen dat u een overbelasting van de <xref:System.AppDomain.DefineDynamicAssembly%2A>methode waarmee bewijs en machtigingen, geef het bewijs dat u wilt dat de dynamische assembly hebben en opnemen <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inclusief <xref:System.Security.Permissions.SecurityPermissionFlag>in de `refusedPermissions` parameter zorgt ervoor dat de MSIL is geverifieerd.</xref:System.Security.Permissions.SecurityPermissionFlag> Een beperking van deze techniek is dat ook wordt veroorzaakt <xref:System.Security.SecurityException>gegenereerd gebruikt in combinatie met de code die volledig vertrouwen vereist.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/2cf98986-7843-48cf-a73f-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/2cf98986-7843-48cf-a73f-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/2cf98986-7843-48cf-a73f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De modus waarin de dynamische assembly wordt geopend."
    - id: dir
      type: System.String
      description: "De naam van de map waarin de assembly moet worden opgeslagen. Als `dir` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, de map wordt standaard ingesteld op de huidige map."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Het bewijs dat is opgegeven voor de dynamische assembly. Het bewijs wordt gebruikt als de uiteindelijke set bewijs gebruikt voor het omzetten van het beleid ongewijzigd."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met witruimte of een slash vooruit of achteruit bevat."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam, toegangsmodus en machtigingsaanvragen."
  remarks: "De machtigingsaanvragen dat is opgegeven voor `requiredPermissions`, `optionalPermissions`, en `refusedPermissions` niet worden gebruikt tenzij de dynamische assembly heeft opgeslagen en opnieuw in het geheugen worden geladen. Machtigingsaanvragen opgeven voor een tijdelijke assembly die niet eerder is opgeslagen op schijf, gebruik een overbelasting van de <xref:System.AppDomain.DefineDynamicAssembly%2A>methode die wordt opgegeven bewijs als goed als aangevraagde machtigingen en geef een <xref:System.Security.Policy.Evidence>object.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Tijdens de ontwikkeling van code die dynamische assembly&quot;s verzendt, wordt aanbevolen dat u een overbelasting van de <xref:System.AppDomain.DefineDynamicAssembly%2A>methode waarmee bewijs en machtigingen, geef het bewijs dat u wilt dat de dynamische assembly hebben en opnemen <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inclusief <xref:System.Security.Permissions.SecurityPermissionFlag>in de `refusedPermissions` parameter zorgt ervoor dat de MSIL is geverifieerd.</xref:System.Security.Permissions.SecurityPermissionFlag> Een beperking van deze techniek is dat ook wordt veroorzaakt <xref:System.Security.SecurityException>gegenereerd gebruikt in combinatie met de code die volledig vertrouwen vereist.</xref:System.Security.SecurityException>       Deze methode mag alleen worden gebruikt voor het definiëren van een dynamische assembly in het huidige toepassingsdomein. Zie voor meer informatie de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/be48f0dd-e58f-4a8c-bdad-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/be48f0dd-e58f-4a8c-bdad-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/be48f0dd-e58f-4a8c-bdad-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De modus waarin de dynamische assembly wordt geopend."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "De vereiste machtigingen aanvragen."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "De optionele machtigingen aanvragen."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "De geweigerde machtigingen aanvragen."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met witruimte of een slash vooruit of achteruit bevat."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam, toegangsmodus, opslagmap en optie voor adreslijstsynchronisatie."
  remarks: "Gebruik deze methode-overload om kenmerken die niet goed werken tenzij deze worden toegepast wanneer een dynamische assembly wordt gemaakt. Bijvoorbeeld, beveiligingskenmerken zoals <xref:System.Security.SecurityTransparentAttribute>en <xref:System.Security.SecurityCriticalAttribute>werken niet goed werken als ze worden toegevoegd nadat een dynamische assembly is gemaakt.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Als `isSynchronized` is `true`, de volgende methoden van de resulterende <xref:System.Reflection.Emit.AssemblyBuilder>worden gesynchroniseerd: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, en <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Als twee van deze methoden worden genoemd in verschillende threads, wordt een blokkeren totdat de andere is voltooid."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De modus waarin de dynamische assembly wordt geopend."
    - id: dir
      type: System.String
      description: "De naam van de map waarin de dynamische assembly moet worden opgeslagen. Als `dir` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, de huidige map wordt gebruikt."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>het maken van modules, typen en leden van de dynamische assembly; synchroniseren anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Een inventariseerbare lijst met kenmerken moeten worden toegepast op de assembly of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er geen kenmerken zijn."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met spaties of bevat een slash vooruit of terug."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam, toegangsmodus, bewijs en machtigingsaanvragen."
  remarks: "De machtigingsaanvragen dat is opgegeven voor `requiredPermissions`, `optionalPermissions`, en `refusedPermissions` worden alleen gebruikt als `evidence` ook is opgegeven, of als de dynamische assembly wordt opgeslagen en opnieuw in het geheugen worden geladen.      > [!NOTE] > Tijdens de ontwikkeling van code die dynamische assembly&quot;s verzendt, wordt aanbevolen dat u opneemt <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Inclusief <xref:System.Security.Permissions.SecurityPermissionFlag>in de `refusedPermissions` parameter zorgt ervoor dat de MSIL is geverifieerd.</xref:System.Security.Permissions.SecurityPermissionFlag> Een beperking van deze techniek is dat ook wordt veroorzaakt <xref:System.Security.SecurityException>gegenereerd gebruikt in combinatie met de code die volledig vertrouwen vereist.</xref:System.Security.SecurityException>       Alleen volledig vertrouwde aanroepfuncties kunnen voorzien van hun `evidence` bij het definiëren van een dynamische <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> De runtime koppelt de <xref:System.Security.Policy.Evidence>via het beveiligingsbeleid om te bepalen van de verleende machtigingen.</xref:System.Security.Policy.Evidence> Gedeeltelijk vertrouwde aanroepfuncties moeten een null-waarde opgeven `evidence`. Als `evidence` is `null`, de runtime kopieert de machtigingensets, dat wil zeggen, de huidige verlenen en weigeren sets, van de aanroeper <xref:System.Reflection.Assembly>naar de dynamische <xref:System.Reflection.Assembly>wordt gedefinieerd en beleid worden gemarkeerd als opgelost.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Als de dynamische <xref:System.Reflection.Assembly>is opgeslagen op schijf, krijgen volgende belasting verleent op basis van beleidsregels die zijn gekoppeld aan de locatie waar de <xref:System.Reflection.Assembly>is opgeslagen.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Deze methode mag alleen worden gebruikt voor het definiëren van een dynamische assembly in het huidige toepassingsdomein. Zie voor meer informatie de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/7d7c7162-9e00-4b91-93d0-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/7d7c7162-9e00-4b91-93d0-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/7d7c7162-9e00-4b91-93d0-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De modus waarin de dynamische assembly wordt geopend."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Het bewijs dat is opgegeven voor de dynamische assembly. Het bewijs wordt gebruikt als de uiteindelijke set bewijs gebruikt voor het omzetten van het beleid ongewijzigd."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "De vereiste machtigingen aanvragen."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "De optionele machtigingen aanvragen."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "De geweigerde machtigingen aanvragen."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met witruimte of een slash vooruit of achteruit bevat."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam, toegangsmodus, opslagmap en machtigingsaanvragen."
  remarks: "De machtigingsaanvragen dat is opgegeven voor `requiredPermissions`, `optionalPermissions`, en `refusedPermissions` niet worden gebruikt tenzij de dynamische assembly heeft opgeslagen en opnieuw in het geheugen worden geladen. Machtigingsaanvragen opgeven voor een tijdelijke assembly die niet eerder is opgeslagen op schijf, gebruik een overbelasting van de <xref:System.AppDomain.DefineDynamicAssembly%2A>methode die wordt opgegeven bewijs als goed als aangevraagde machtigingen en geef een <xref:System.Security.Policy.Evidence>object.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Tijdens de ontwikkeling van code die dynamische assembly&quot;s verzendt, wordt aanbevolen dat u een overbelasting van de <xref:System.AppDomain.DefineDynamicAssembly%2A>methode waarmee bewijs en machtigingen, geef het bewijs dat u wilt dat de dynamische assembly hebben en opnemen <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> Inclusief <xref:System.Security.Permissions.SecurityPermissionFlag>in de `refusedPermissions` parameter zorgt ervoor dat de MSIL is geverifieerd.</xref:System.Security.Permissions.SecurityPermissionFlag> Een beperking van deze techniek is dat ook wordt veroorzaakt <xref:System.Security.SecurityException>gegenereerd gebruikt in combinatie met de code die volledig vertrouwen vereist.</xref:System.Security.SecurityException>       Deze methode mag alleen worden gebruikt voor het definiëren van een dynamische assembly in het huidige toepassingsdomein. Zie voor meer informatie de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0fc3676e-96ff-42c6-ad25-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0fc3676e-96ff-42c6-ad25-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0fc3676e-96ff-42c6-ad25-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De modus waarin de dynamische assembly wordt geopend."
    - id: dir
      type: System.String
      description: "De naam van de map waarin de assembly moet worden opgeslagen. Als `dir` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, de map wordt standaard ingesteld op de huidige map."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "De vereiste machtigingen aanvragen."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "De optionele machtigingen aanvragen."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "De geweigerde machtigingen aanvragen."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met witruimte of een slash vooruit of achteruit bevat."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam, toegangsmodus opslagmap, bewijs en machtigingsaanvragen."
  remarks: "De machtigingsaanvragen dat is opgegeven voor `requiredPermissions`, `optionalPermissions`, en `refusedPermissions` worden alleen gebruikt als `evidence` ook is opgegeven, of als de dynamische assembly wordt opgeslagen en opnieuw in het geheugen worden geladen.      > [!NOTE] > Tijdens de ontwikkeling van code die dynamische assembly&quot;s verzendt, wordt aanbevolen dat u opneemt <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Inclusief <xref:System.Security.Permissions.SecurityPermissionFlag>in de `refusedPermissions` parameter zorgt ervoor dat de MSIL is geverifieerd.</xref:System.Security.Permissions.SecurityPermissionFlag> Een beperking van deze techniek is dat ook wordt veroorzaakt <xref:System.Security.SecurityException>gegenereerd gebruikt in combinatie met de code die volledig vertrouwen vereist.</xref:System.Security.SecurityException>       Alleen volledig vertrouwde aanroepfuncties kunnen voorzien van hun `evidence` bij het definiëren van een dynamische <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> De runtime koppelt de <xref:System.Security.Policy.Evidence>via het beveiligingsbeleid om te bepalen van de verleende machtigingen.</xref:System.Security.Policy.Evidence> Gedeeltelijk vertrouwde aanroepfuncties moeten een null-waarde opgeven `evidence`. Als `evidence` is `null`, de runtime kopieert de machtigingensets, dat wil zeggen, de huidige verlenen en weigeren sets, van de aanroeper <xref:System.Reflection.Assembly>naar de dynamische <xref:System.Reflection.Assembly>wordt gedefinieerd en beleid worden gemarkeerd als opgelost.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Als de dynamische <xref:System.Reflection.Assembly>is opgeslagen op schijf, krijgen volgende belasting verleent op basis van beleidsregels die zijn gekoppeld aan de locatie waar de <xref:System.Reflection.Assembly>is opgeslagen.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Deze methode mag alleen worden gebruikt voor het definiëren van een dynamische assembly in het huidige toepassingsdomein. Zie voor meer informatie de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0baa3466-02cf-4d9c-bb66-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0baa3466-02cf-4d9c-bb66-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0baa3466-02cf-4d9c-bb66-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De modus waarin de dynamische assembly wordt geopend."
    - id: dir
      type: System.String
      description: "De naam van de map waarin de assembly moet worden opgeslagen. Als `dir` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, de map wordt standaard ingesteld op de huidige map."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Het bewijs dat is opgegeven voor de dynamische assembly. Het bewijs wordt gebruikt als de uiteindelijke set bewijs gebruikt voor het omzetten van het beleid ongewijzigd."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "De vereiste machtigingen aanvragen."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "De optionele machtigingen aanvragen."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "De geweigerde machtigingen aanvragen."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met witruimte of een slash vooruit of achteruit bevat."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam, toegangsmodus opslagmap, bewijs, machtigingsaanvragen en optie voor adreslijstsynchronisatie."
  remarks: "De machtigingsaanvragen dat is opgegeven voor `requiredPermissions`, `optionalPermissions`, en `refusedPermissions` worden alleen gebruikt als `evidence` ook is opgegeven, of als de dynamische assembly wordt opgeslagen en opnieuw in het geheugen worden geladen.      > [!NOTE] > Tijdens de ontwikkeling van code die dynamische assembly&quot;s verzendt, wordt aanbevolen dat u opneemt <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>in `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Inclusief <xref:System.Security.Permissions.SecurityPermissionFlag>in de `refusedPermissions` parameter zorgt ervoor dat de MSIL is geverifieerd.</xref:System.Security.Permissions.SecurityPermissionFlag> Een beperking van deze techniek is dat ook wordt veroorzaakt <xref:System.Security.SecurityException>gegenereerd gebruikt in combinatie met de code die volledig vertrouwen vereist.</xref:System.Security.SecurityException>       Alleen volledig vertrouwde aanroepfuncties kunnen hun bewijs opgeven bij het definiëren van een dynamische <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> De runtime koppelt de <xref:System.Security.Policy.Evidence>via het beveiligingsbeleid om te bepalen van de verleende machtigingen.</xref:System.Security.Policy.Evidence> Gedeeltelijk vertrouwde aanroepfuncties dient `null` voor de `evidence` parameter. Als `evidence` is `null`, de runtime kopieert de machtigingensets, dat wil zeggen, de huidige verlenen en weigeren sets, van de aanroeper <xref:System.Reflection.Assembly>naar de dynamische <xref:System.Reflection.Assembly>wordt gedefinieerd en beleid worden gemarkeerd als opgelost.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Als de dynamische <xref:System.Reflection.Assembly>is opgeslagen op schijf, krijgen volgende belasting verleent op basis van beleidsregels die zijn gekoppeld aan de locatie waar de <xref:System.Reflection.Assembly>is opgeslagen.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Als `isSynchronized` is `true`, de volgende methoden van de resulterende <xref:System.Reflection.Emit.AssemblyBuilder>worden gesynchroniseerd: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, en <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Als twee van deze methoden worden genoemd in verschillende threads, wordt een blokkeren totdat de andere is voltooid."
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/84dd3b17-5601-467b-b1e3-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/84dd3b17-5601-467b-b1e3-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/84dd3b17-5601-467b-b1e3-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De modus waarin de dynamische assembly wordt geopend."
    - id: dir
      type: System.String
      description: "De naam van de map waarin de dynamische assembly moet worden opgeslagen. Als `dir` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, de map wordt standaard ingesteld op de huidige map."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Het bewijs dat is opgegeven voor de dynamische assembly. Het bewijs wordt gebruikt als de uiteindelijke set bewijs gebruikt voor het omzetten van het beleid ongewijzigd."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "De vereiste machtigingen aanvragen."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "De optionele machtigingen aanvragen."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "De geweigerde machtigingen aanvragen."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>het maken van modules, typen en leden van de dynamische assembly; synchroniseren anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met witruimte of een slash vooruit of achteruit bevat."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee definieert u een dynamische assembly met de opgegeven naam toegangsmodus, opslagmap, bewijs, machtigingsaanvragen, optie voor adreslijstsynchronisatie en aangepaste kenmerken."
  remarks: "Gebruik deze methode-overload om kenmerken die niet goed werken tenzij deze worden toegepast wanneer een dynamische assembly wordt gemaakt. Bijvoorbeeld, beveiligingskenmerken zoals <xref:System.Security.SecurityTransparentAttribute>en <xref:System.Security.SecurityCriticalAttribute>werken niet goed werken als ze worden toegevoegd nadat een dynamische assembly is gemaakt.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       De machtigingsaanvragen dat is opgegeven voor de `requiredPermissions`, `optionalPermissions`, en `refusedPermissions` parameters worden alleen gebruikt als de `evidence` ook parameter wordt opgegeven, of als de dynamische assembly wordt opgeslagen en opnieuw in het geheugen worden geladen.      > [!NOTE] > Wanneer u code die u dynamische assembly&quot;s verzendt ontwikkelt, raden we aan dat u ook de <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>vlag de `refusedPermissions` parameter.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Het opnemen van deze vlag zorgt ervoor dat de Microsoft tussentaal (MSIL) kan worden gecontroleerd. Deze techniek detecteert de onbedoelde generatie van niet-verifieerbare code, die anders is het zeer moeilijk te detecteren. Een beperking van deze techniek is dat ook wordt veroorzaakt <xref:System.Security.SecurityException>gegenereerd wanneer deze worden gebruikt met code die volledig vertrouwen is vereist.</xref:System.Security.SecurityException>       Alleen volledig vertrouwde aanroepfuncties kunnen bewijs opgeven bij het definiëren van een dynamische <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> De runtime het <xref:System.Security.Policy.Evidence>via het beveiligingsbeleid om te bepalen van de verleende machtigingen.</xref:System.Security.Policy.Evidence> Gedeeltelijk vertrouwde aanroepfuncties dient `null` voor de `evidence` parameter. Als `evidence` is `null`, de runtime set machtigingen op (die is, de huidige verlenen en weigeren sets) uit de assembly van de aanroeper gekopieerd naar de dynamische assembly die wordt gedefinieerd en het beleid wordt gemarkeerd als opgelost.       Als de dynamische assembly is opgeslagen op schijf, volgende belasting krijgt verleent op basis van beleidsregels die zijn gekoppeld aan de locatie waar de dynamische assembly is opgeslagen.       Als `isSynchronized` is `true`, de volgende methoden van de resulterende <xref:System.Reflection.Emit.AssemblyBuilder>worden gesynchroniseerd: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, en <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Als twee van deze methoden worden genoemd in verschillende threads, wordt een blokkeren totdat de andere is voltooid.       Deze methode-overload is opgenomen in de [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "De unieke id van de dynamische assembly."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "De modus waarin de dynamische assembly wordt geopend."
    - id: dir
      type: System.String
      description: "De naam van de map waarin de dynamische assembly moet worden opgeslagen. Als `dir` is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, de huidige map wordt gebruikt."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Het bewijs dat is opgegeven voor de dynamische assembly. Het bewijs wordt gebruikt als de uiteindelijke set bewijs gebruikt voor het omzetten van het beleid ongewijzigd."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "De vereiste machtigingen aanvragen."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "De optionele machtigingen aanvragen."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "De geweigerde machtigingen aanvragen."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>het maken van modules, typen en leden van de dynamische assembly; synchroniseren anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Een inventariseerbare lijst met kenmerken moeten worden toegepast op de assembly of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er geen kenmerken zijn."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Een dynamische assembly met de opgegeven naam en functies."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - of - de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap van <code> name </code> begint met spaties of bevat een slash vooruit of terug."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  id: DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  langs:
  - csharp
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De code wordt uitgevoerd in een ander toepassingsdomein die wordt geïdentificeerd door de opgegeven gemachtigde."
  remarks: '`callBackDelegate`kan een marshal-by-value, geef <xref:System.MarshalByRefObject>, of <xref:System.ContextBoundObject>.</xref:System.ContextBoundObject> </xref:System.MarshalByRefObject>'
  example:
  - "The following sample demonstrates using a static DoCallBack method.  \n  \n [!code-vb[AppDomain_DoCallBack#1](~/add/codesnippet/visualbasic/m-system.appdomain.docal_1.vb)]\n [!code-cpp[AppDomain_DoCallBack#1](~/add/codesnippet/cpp/m-system.appdomain.docal_1.cpp)]\n [!code-cs[AppDomain_DoCallBack#1](~/add/codesnippet/csharp/m-system.appdomain.docal_1.cs)]  \n  \n The following sample demonstrates using the DoCallBack method by value.  \n  \n [!code-vb[AppDomain_DoCallBack#2](~/add/codesnippet/visualbasic/m-system.appdomain.docal_2.vb)]\n [!code-cs[AppDomain_DoCallBack#2](~/add/codesnippet/csharp/m-system.appdomain.docal_2.cs)]\n [!code-cpp[AppDomain_DoCallBack#2](~/add/codesnippet/cpp/m-system.appdomain.docal_2.cpp)]  \n  \n The following sample demonstrates using the DoCallBack method by reference.  \n  \n [!code-cpp[AppDomain_DoCallBack#3](~/add/codesnippet/cpp/m-system.appdomain.docal_3.cpp)]\n [!code-cs[AppDomain_DoCallBack#3](~/add/codesnippet/csharp/m-system.appdomain.docal_3.cs)]\n [!code-vb[AppDomain_DoCallBack#3](~/add/codesnippet/visualbasic/m-system.appdomain.docal_3.vb)]"
  syntax:
    content: public void DoCallBack (CrossAppDomainDelegate callBackDelegate);
    parameters:
    - id: callBackDelegate
      type: System.CrossAppDomainDelegate
      description: "Een gemachtigde die geeft een methode aan te roepen."
  overload: System.AppDomain.DoCallBack*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBackDelegate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.DomainManager
  id: DomainManager
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u de domein-manager die werd geleverd door de host als het toepassingsdomein is geïnitialiseerd."
  remarks: "Een niet-beheerde host van de common language runtime (CLR) kan een manager domein bieden. Het domeinbeheer kunt deelnemen aan het initialiseren van het nieuwe toepassingsdomein en geef andere beheerders, zoals een <xref:System.Security.HostSecurityManager>, die deel uitmaken van de bewerkingen van het toepassingsdomein.</xref:System.Security.HostSecurityManager>"
  syntax:
    content: public AppDomainManager DomainManager { get; }
    return:
      type: System.AppDomainManager
      description: "Een object dat het domeinbeheer dat is geleverd door de host als het toepassingsdomein is geïnitialiseerd, vertegenwoordigt of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als geen domeinbeheer dat is opgegeven."
  overload: System.AppDomain.DomainManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DomainUnload
  id: DomainUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Deze gebeurtenis treedt op wanneer een <xref href=&quot;System.AppDomain&quot;> </xref> moet worden verwijderd."
  remarks: "De <xref:System.EventHandler>delegeren voor deze gebeurtenis beëindiging activiteiten uitvoeren kunt voordat het toepassingsdomein verwijderd is.</xref:System.EventHandler>       Elk toepassingsdomein uitvoeren moet wanneer deze verwijderd wordt verwerking moet een gebeurtenis-handler voor deze gebeurtenis te registreren. Een gedeelde gebeurtenis-handler moet niet worden gebruikt, omdat de <xref:System.EventHandler>gemachtigde vormt geen identificatie van het domein dat wordt ongedaan gemaakt.</xref:System.EventHandler>      > [!NOTE] > Deze gebeurtenis wordt nooit geactiveerd in het standaardtoepassingsdomein.       Maak geen veronderstellingen over de thread die de gebeurtenis wordt geactiveerd op. De gebeurtenis kan worden geactiveerd op een andere thread dan de naam de <xref:System.AppDomain.Unload%2A>methode.</xref:System.AppDomain.Unload%2A>       Zie voor meer informatie over het verwerken van gebeurtenissen [gebeurtenissen](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler DomainUnload;
    return:
      type: System.EventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DynamicDirectory
  id: DynamicDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u de map die de assembly-omzetter gebruikt voor de probe voor dynamisch gemaakte assembly&quot;s."
  remarks: "Om in te stellen de dynamische map, wijs een basismap van het pad naar de <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>eigenschap van de <xref:System.AppDomainSetup>-object dat wordt gebruikt voor het maken van nieuw toepassingsdomein.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> Het basisobject in Active directory-pad dat u aan de eigenschap toewijst wordt gewijzigd door toevoeging van een submap waarvan de eenvoudige naam de hash-code van de tekenreeks die u toewijst is aan de <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>zodat de indeling van de basismap van de eigenschap *oorspronkelijke pad*\\\\*hash-code*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> De dynamische map is een submap van deze basismap. De eenvoudige naam is de waarde van de <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>eigenschap, zodat de indeling *oorspronkelijke pad*\\\\*hash-code*\\\\*toepassingsnaam*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>"
  example:
  - "The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to \"C:\\DynamicAssemblyDir\". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain, using the <xref:System.AppDomainSetup> object. The example uses the DynamicDirectory property to retrieve the name of the directory, so it can create the directory. (The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomain.dynam_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomain.dynam_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.dynam_1.vb)]"
  syntax:
    content: public string DynamicDirectory { get; }
    return:
      type: System.String
      description: "De map die de assembly-omzetter gebruikt om te zoeken naar dynamisch gemaakt assembly&quot;s."
  overload: System.AppDomain.DynamicDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.Evidence
  id: Evidence
  parent: System.AppDomain
  langs:
  - csharp
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Haalt de <xref href=&quot;System.Security.Policy.Evidence&quot;> </xref> gekoppeld aan dit toepassingsdomein."
  syntax:
    content: public System.Security.Policy.Evidence Evidence { get; }
    return:
      type: System.Security.Policy.Evidence
      description: "De gegevens die zijn gekoppeld aan het toepassingsdomein van deze."
  overload: System.AppDomain.Evidence*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String)
  id: ExecuteAssembly(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De assembly die is opgenomen in het opgegeven bestand worden uitgevoerd."
  remarks: "De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       Deze methode maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread.       Deze methode wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> U kunt ook uitvoeren met assembly&quot;s met de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode die wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Maken van de <xref:System.AppDomain>gebruiken om te laden en uitvoeren, de <xref:System.AppDomain.CreateDomain%2A>methode.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  example:
  - "The following sample demonstrates using one of the overloads of ExecuteAssembly on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_0_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_0_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_0_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De naam van het bestand met de assembly uit te voeren."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>is niet gevonden."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyFile</code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De assembly die zijn opgenomen in het opgegeven bestand met de opgegeven bewijs worden uitgevoerd."
  remarks: "De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       De <xref:System.AppDomain.ExecuteAssembly%2A>methode geen maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread.</xref:System.AppDomain.ExecuteAssembly%2A>       Deze methode wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> U kunt ook uitvoeren met assembly&quot;s met de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode die wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/8a3b95e3-eb51-4f5b-bb93-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/8a3b95e3-eb51-4f5b-bb93-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/8a3b95e3-eb51-4f5b-bb93-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De naam van het bestand met de assembly uit te voeren."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Aanwijzingen voor het laden van de assembly."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>is niet gevonden."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyFile</code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  id: ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De assembly die zijn opgenomen in het opgegeven bestand met de opgegeven argumenten worden uitgevoerd."
  remarks: "De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       Deze methode maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread.       Deze methode wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> U kunt ook uitvoeren met assembly&quot;s met de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode die wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_1_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_1_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_1_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De naam van het bestand met de assembly uit te voeren."
    - id: args
      type: System.String[]
      description: "De argumenten van het toegangspunt van de assembly."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>is niet gevonden."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>is geen geldige assembly.       - of - <code>assemblyFile</code> is gecompileerd met een latere versie van de common language runtime dan de versie die momenteel zijn geladen."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De assembly die zijn opgenomen in het opgegeven bestand met de opgegeven bewijs en argumenten worden uitgevoerd."
  remarks: "De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       Deze methode maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread.       Deze methode wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> U kunt ook uitvoeren met assembly&quot;s met de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode die wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/cb15b913-548c-4cb1-bbc5-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/cb15b913-548c-4cb1-bbc5-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/cb15b913-548c-4cb1-bbc5-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De naam van het bestand met de assembly uit te voeren."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Het opgegeven bewijs van de assembly."
    - id: args
      type: System.String[]
      description: "De argumenten van het toegangspunt van de assembly."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>is niet gevonden."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyFile</code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Wanneer het verouderde CAS-beleid niet is ingeschakeld, <code>assemblySecurity</code> moet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De assembly die zijn opgenomen in het opgegeven bestand met de opgegeven argumenten, hash-waarde en hash-algoritme worden uitgevoerd."
  remarks: "De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       Deze methode maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread.       Deze methode wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> U kunt ook uitvoeren met assembly&quot;s met de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode die wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/ccb3b356-1169-4d65-9fdd-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/ccb3b356-1169-4d65-9fdd-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/ccb3b356-1169-4d65-9fdd-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De naam van het bestand met de assembly uit te voeren."
    - id: args
      type: System.String[]
      description: "De argumenten van het toegangspunt van de assembly."
    - id: hashValue
      type: System.Byte[]
      description: "Hiermee geeft u de waarde van de berekende hash-code."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Hiermee geeft u het hashalgoritme dat door het assembly-manifest."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>is niet gevonden."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>is geen geldige assembly.       - of - <code>assemblyFile</code> is gecompileerd met een latere versie van de common language runtime dan de versie die momenteel zijn geladen."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De assembly die zijn opgenomen in het opgegeven bestand met de opgegeven bewijs, argumenten, hash-waarde en hash-algoritme worden uitgevoerd."
  remarks: "De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       Deze methode maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread.       Deze methode wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> U kunt ook uitvoeren met assembly&quot;s met de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode die wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/c176353b-cef5-4b78-b4a8-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/c176353b-cef5-4b78-b4a8-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/c176353b-cef5-4b78-b4a8-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "De naam van het bestand met de assembly uit te voeren."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Het opgegeven bewijs van de assembly."
    - id: args
      type: System.String[]
      description: "De argumenten van het toegangspunt van de assembly."
    - id: hashValue
      type: System.Byte[]
      description: "Hiermee geeft u de waarde van de berekende hash-code."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Hiermee geeft u het hashalgoritme dat door het assembly-manifest."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>is niet gevonden."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyFile</code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Wanneer het verouderde CAS-beleid niet is ingeschakeld, <code>assemblySecurity</code> moet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  id: ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Voert een assembly die de weergegeven naam gegeven."
  remarks: "De <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode biedt vergelijkbare functionaliteit voor de <xref:System.AppDomain.ExecuteAssembly%2A>methode van maar Hiermee geeft u de assembly met weergavenaam of <xref:System.Reflection.AssemblyName>in plaats van door de bestandslocatie.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Daarom <xref:System.AppDomain.ExecuteAssemblyByName%2A>wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode in plaats van met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       Deze methode maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread.       Maken van de <xref:System.AppDomain>gebruiken om te laden en uitvoeren, de <xref:System.AppDomain.CreateDomain%2A>methode.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is niet gevonden."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code> assemblyName </code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is gevonden, maar kan niet worden geladen."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De opgegeven assembly wordt uitgevoerd een <xref:System.Reflection.AssemblyName>, met behulp van de opgegeven argumenten.</xref:System.Reflection.AssemblyName>"
  remarks: "De <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode biedt vergelijkbare functionaliteit voor de <xref:System.AppDomain.ExecuteAssembly%2A>methode van maar Hiermee geeft u de assembly met weergavenaam of <xref:System.Reflection.AssemblyName>in plaats van door de bestandslocatie.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Daarom <xref:System.AppDomain.ExecuteAssemblyByName%2A>wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode in plaats van met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       Deze methode maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread."
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Een <xref:System.Reflection.AssemblyName>-object dat de naam van de assembly vertegenwoordigt.</xref:System.Reflection.AssemblyName>"
    - id: args
      type: System.String[]
      description: "De opdrachtregelargumenten doorgeven bij het starten van het proces."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is niet gevonden."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is gevonden, maar kan niet worden geladen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is geen geldige assembly.       - of - <code> assemblyName </code> is gecompileerd met een latere versie van de common language runtime dan de versie die momenteel zijn geladen."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Een assembly die de weergavenaam opgegeven met de opgegeven bewijs worden uitgevoerd."
  remarks: "De <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode biedt vergelijkbare functionaliteit voor de <xref:System.AppDomain.ExecuteAssembly%2A>methode van maar Hiermee geeft u de assembly met weergavenaam of <xref:System.Reflection.AssemblyName>in plaats van door de bestandslocatie.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Daarom <xref:System.AppDomain.ExecuteAssemblyByName%2A>wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode in plaats van met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       De <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode geen maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread.</xref:System.AppDomain.ExecuteAssemblyByName%2A>      > [!NOTE] > Wanneer u gebruikt de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode met een <xref:System.Security.Policy.Evidence>parameter stukjes bewijs worden samengevoegd.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Stukjes bewijs dat is opgegeven als een argument voor de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode stukjes bewijs geleverd door de lader van de vervangen.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Aanwijzingen voor het laden van de assembly."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is niet gevonden."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is gevonden, maar kan niet worden geladen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code> assemblyName </code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  id: ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De assembly die de weergavenaam opgegeven met de opgegeven argumenten worden uitgevoerd."
  remarks: "De <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode biedt vergelijkbare functionaliteit voor de <xref:System.AppDomain.ExecuteAssembly%2A>methode van maar Hiermee geeft u de assembly met weergavenaam of <xref:System.Reflection.AssemblyName>in plaats van door de bestandslocatie.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Daarom <xref:System.AppDomain.ExecuteAssemblyByName%2A>wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode in plaats van met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       Deze methode maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread."
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: args
      type: System.String[]
      description: "De opdrachtregelargumenten doorgeven bij het starten van het proces."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is niet gevonden."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is gevonden, maar kan niet worden geladen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is geen geldige assembly.       - of - <code> assemblyName </code> is gecompileerd met een latere versie van de common language runtime dan de versie die momenteel zijn geladen."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De opgegeven assembly wordt uitgevoerd een <xref:System.Reflection.AssemblyName>, met behulp van de opgegeven bewijs en de argumenten.</xref:System.Reflection.AssemblyName>"
  remarks: "De <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode biedt vergelijkbare functionaliteit voor de <xref:System.AppDomain.ExecuteAssembly%2A>methode van maar Hiermee geeft u de assembly met weergavenaam of <xref:System.Reflection.AssemblyName>in plaats van door de bestandslocatie.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Daarom <xref:System.AppDomain.ExecuteAssemblyByName%2A>wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode in plaats van met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       Deze methode maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread.      > [!NOTE] > Wanneer u gebruikt de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode met een <xref:System.Security.Policy.Evidence>parameter stukjes bewijs worden samengevoegd.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Stukjes bewijs dat is opgegeven als een argument voor de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode stukjes bewijs geleverd door de lader van de vervangen.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "Een <xref:System.Reflection.AssemblyName>-object dat de naam van de assembly vertegenwoordigt.</xref:System.Reflection.AssemblyName>"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Aanwijzingen voor het laden van de assembly."
    - id: args
      type: System.String[]
      description: "De opdrachtregelargumenten doorgeven bij het starten van het proces."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is niet gevonden."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is gevonden, maar kan niet worden geladen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code> assemblyName </code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Wanneer het verouderde CAS-beleid niet is ingeschakeld, <code>assemblySecurity</code> moet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De opgegeven van de weergavenaam assembly met de opgegeven bewijs en argumenten worden uitgevoerd."
  remarks: "De <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode biedt vergelijkbare functionaliteit voor de <xref:System.AppDomain.ExecuteAssembly%2A>methode van maar Hiermee geeft u de assembly met weergavenaam of <xref:System.Reflection.AssemblyName>in plaats van door de bestandslocatie.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Daarom <xref:System.AppDomain.ExecuteAssemblyByName%2A>wordt geladen assembly&quot;s met de <xref:System.Reflection.Assembly.Load%2A>methode in plaats van met de <xref:System.Reflection.Assembly.LoadFile%2A>methode.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       De assembly, begint het uitvoeren van het toegangspunt dat is opgegeven in de .NET Framework-header.       Deze methode maakt een nieuw proces of het toepassingsdomein en dit wordt de methode post point niet uitgevoerd op een nieuwe thread.      > [!NOTE] > Wanneer u gebruikt de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode met een <xref:System.Security.Policy.Evidence>parameter stukjes bewijs worden samengevoegd.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Stukjes bewijs dat is opgegeven als een argument voor de <xref:System.AppDomain.ExecuteAssemblyByName%2A>methode stukjes bewijs geleverd door de lader van de vervangen.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Aanwijzingen voor het laden van de assembly."
    - id: args
      type: System.String[]
      description: "De opdrachtregelargumenten doorgeven bij het starten van het proces."
    return:
      type: System.Int32
      description: "De waarde die wordt geretourneerd door het invoerpunt van de assembly."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is niet gevonden."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is gevonden, maar kan niet worden geladen."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "De assembly die is opgegeven door <code> assemblyName </code> is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code> assemblyName </code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Wanneer het verouderde CAS-beleid niet is ingeschakeld, <code>assemblySecurity</code> moet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "De opgegeven assembly heeft geen toegangspunt."
  platform:
  - net462
- uid: System.AppDomain.FirstChanceException
  id: FirstChanceException
  parent: System.AppDomain
  langs:
  - csharp
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Treedt op wanneer een uitzondering gegenereerd in beheerde code voordat de runtime de aanroepstack voor een uitzonderings-handler in het toepassingsdomein zoekt."
  remarks: "Deze gebeurtenis is alleen een melding. Deze gebeurtenis verwerkt niet verwerken van de uitzondering of latere uitzonderingsverwerking op elke manier van invloed zijn op. Nadat de gebeurtenis is gegenereerd en gebeurtenis-handlers wordt aangeroepen, begint de common language runtime (CLR) om te zoeken naar een handler voor de uitzondering. FirstChanceException biedt het toepassingsdomein eerste kans om te onderzoeken elke beheerde uitzondering.       De gebeurtenis kan worden verwerkt per toepassingsdomein. Als een thread passeert in meerdere toepassingsdomeinen tijdens het uitvoeren van een aanroep, wordt de gebeurtenis wordt gestart in elk toepassingsdomein die een gebeurtenis-handler is geregistreerd voordat de CLR zoeken naar een overeenkomende uitzonderings-handler in dat toepassingsdomein wordt gestart. Nadat de gebeurtenis is afgehandeld, wordt een zoekopdracht gemaakt voor een overeenkomende uitzonderings-handler in dat toepassingsdomein. Als geen wordt gevonden, wordt de gebeurtenis is opgetreden tijdens het volgende toepassingsdomein.       U moet alle uitzonderingen die in de gebeurtenis-handler voor de gebeurtenis FirstChanceException optreden verwerken. Anders is FirstChanceException verhoogde recursief. Dit kan leiden tot een stack-overloop en beëindiging van de toepassing. Het is raadzaam om de gebeurtenis-handlers voor deze gebeurtenis te implementeren als beperkte uitvoeringsregio regio&quot;s (CESR) om te voorkomen dat infrastructuur-gerelateerde uitzonderingen, zoals onvoldoende geheugen of stack-overloop die betrekking hebben op de virtuele machine tijdens het verwerken van de melding uitzondering.       Deze gebeurtenis wordt niet gestart voor uitzonderingen die duiden op beschadiging van de processtatus zoals toegangsfouten, tenzij de gebeurtenis-handler risicovolle is en heeft de <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>kenmerk.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       De common language runtime wordt onderbroken thread wordt afgebroken terwijl deze meldingsgebeurtenis wordt verwerkt."
  example:
  - "The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain. Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain. The FirstChanceException event is handled in all application domains except `AD1`.  \n  \n> [!NOTE]\n>  In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/add/includes/ajax-current-ext-md.md).  \n  \n When the application domains have been created, the default application domain calls the `TestException` method for the first application domain. Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled. Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.  \n  \n When the last `Worker` object handles the exception, the FirstChanceException event is raised only in the last application domain. The other application domains never get a chance to handle the exception, so the event is not raised.  \n  \n When the last `Worker` object does not handle the exception, the FirstChanceException event is raised in each application domain that has an event handler. After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.  \n  \n> [!NOTE]\n>  To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers. Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.  \n  \n [!code-vb[System.AppDomain.FirstChanceException#1](~/add/codesnippet/visualbasic/e-system.appdomain.first_1.vb)]\n [!code-cs[System.AppDomain.FirstChanceException#1](~/add/codesnippet/csharp/e-system.appdomain.first_1.cs)]"
  syntax:
    content: public event EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
    return:
      type: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.FriendlyName
  id: FriendlyName
  parent: System.AppDomain
  langs:
  - csharp
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u de beschrijvende naam van het toepassingsdomein van deze."
  remarks: "De beschrijvende naam van het standaardtoepassingsdomein is de bestandsnaam van het uitvoerbare procesbestand. Bijvoorbeeld, als het uitvoerbare bestand wordt gebruikt voor het proces starten is `&quot;c:\\MyAppDirectory\\MyAssembly.exe&quot;`, is de beschrijvende naam van het standaardtoepassingsdomein `&quot;MyAssembly.exe&quot;`."
  example:
  - "The following code example uses the FriendlyName property to get the friendly name of the current application domain. For the default application domain, the friendly name is the name of the application's executable file. The code example also displays additional information about the application domain.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.frien_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.frien_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.frien_1.cs)]"
  syntax:
    content: public string FriendlyName { get; }
    return:
      type: System.String
      description: "De beschrijvende naam van het toepassingsdomein van deze."
  overload: System.AppDomain.FriendlyName*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.GetAssemblies
  id: GetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u de assembly&quot;s die zijn geladen in de uitvoeringscontext van dit toepassingsdomein."
  remarks: ''
  example:
  - "The following code example uses the GetAssemblies method to get a list of all assemblies that have been loaded into the application domain. The assemblies are then displayed to the console.  \n  \n To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the GetAssemblies method.  \n  \n [!code-cpp[ADGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.getas_1.cpp)]\n [!code-cs[ADGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.getas_1.cs)]\n [!code-vb[ADGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.getas_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] GetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "Een matrix van assembly&quot;s in dit toepassingsdomein."
  overload: System.AppDomain.GetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.GetCurrentThreadId
  id: GetCurrentThreadId
  parent: System.AppDomain
  langs:
  - csharp
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee wordt de huidige thread-id opgehaald."
  remarks: "Gebruik de <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>eigenschap, die stabiele zelfs wanneer het .NET Framework wordt gehost door een omgeving die vezels (dat wil zeggen, lightweight threads) ondersteunt.</xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>"
  syntax:
    content: public static int GetCurrentThreadId ();
    parameters: []
    return:
      type: System.Int32
      description: "Een 32-bits geheel getal met teken met de id van de huidige thread."
  overload: System.AppDomain.GetCurrentThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.GetData(System.String)
  id: GetData(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee wordt de waarde die is opgeslagen in het huidige toepassingsdomein voor de opgegeven naam."
  remarks: "Gebruik deze methode voor het ophalen van de waarde van een item in een interne cache met naam-data-paren die de eigenschappen van dit exemplaar van <xref:System.AppDomain>.</xref:System.AppDomain> beschrijven Houd er rekening mee dat het vergelijken van `name` met de naam van sleutel-waardeparen is hoofdlettergevoelig.       De cache automatisch bevat vooraf gedefinieerde system-vermeldingen die zijn ingevoegd als het toepassingsdomein wordt gemaakt. U kunt de waarden met de methode GetData of een vergelijkbare inspecteren <xref:System.AppDomainSetup>Eigenschappen.</xref:System.AppDomainSetup>       U kunt invoegen of wijzigen van uw eigen door de gebruiker gedefinieerde naam gegevens paren met de <xref:System.AppDomain.SetData%2A>methode en hun waarden controleren met de methode GetData.</xref:System.AppDomain.SetData%2A>       De volgende tabel beschrijft de `name` van elke vooraf gedefinieerde tot het systeem en de bijbehorende <xref:System.AppDomainSetup>eigenschap.</xref:System.AppDomainSetup>      | Waarde van &quot;name&quot; | Eigenschap |   |---------------------|--------------|   |&quot; APPBASE &quot;| <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>|   |&quot; APP_CONFIG_FILE &quot; | <xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName>|   |&quot; APP_LAUNCH_URL &quot;| (Er is geen eigenschap)</xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName> </xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName><br /><br /> &quot;APP_LAUNCH_URL&quot; vertegenwoordigt de URL die oorspronkelijk zijn aangevraagd door de gebruiker, voordat u geen omleiding. Dit is alleen beschikbaar wanneer de toepassing is gestart met een browser zoals Internet Explorer. Niet alle browsers bieden deze waarde. |   |&quot; APP_NAAM &quot; | <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>|   |&quot; BINPATH_PROBE_ONLY &quot; | <xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName>|   |&quot; CACHE_BASE &quot; | <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>|   |&quot; CODE_DOWNLOAD_DISABLED &quot; | <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>|   |&quot; DEV_PATH &quot; | (Er is geen eigenschap) |   |&quot; DISALLOW_APP &quot; | <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_BASE_PROBING &quot; | <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_REDIRECTS &quot; | <xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName>|   |&quot; DYNAMIC_BASE &quot; | <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>|   |&quot; FORCE_CACHE_INSTALL &quot; | <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>|   |&quot; LICENSE_FILE&quot; of een tekenreeks toepassingsspecifieke | <xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName>|   |&quot; LOADER_OPTIMIZATION &quot; | <xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName>|   |&quot; LOCATION_URI &quot; | (Er is geen eigenschap) |   |&quot; PRIVATE_BINPATH &quot; | <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>|   |&quot; REGEX_DEFAULT_MATCH_TIMEOUT &quot; | <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName></xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName></xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName></xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName></xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName></xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName></xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName><br /><br /> &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; is geen vermelding systeem en de waarde kan worden ingesteld door het aanroepen van de methode <xref:System.AppDomain.SetData%2A>. |   |&quot; SHADOW_COPY_DIRS &quot; | <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>|</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName></xref:System.AppDomain.SetData%2A>"
  example:
  - "The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain. The example then demonstrates how to use the GetData method to retrieve the data from these value pairs and display them to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.getda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.getda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.getda_1.cs)]"
  syntax:
    content: public object GetData (string name);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de eigenschap van een vooraf gedefinieerde toepassing domein of de naam van een eigenschap van het domein toepassing die u hebt gedefinieerd."
    return:
      type: System.Object
      description: "De waarde van de <code> name </code> -eigenschap of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als de eigenschap niet bestaat."
  overload: System.AppDomain.GetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.GetType
  id: GetType
  parent: System.AppDomain
  langs:
  - csharp
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee wordt het type van het huidige exemplaar."
  syntax:
    content: public Type GetType ();
    parameters: []
    return:
      type: System.Type
      description: "Het type van het huidige exemplaar."
  overload: System.AppDomain.GetType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Id
  id: Id
  parent: System.AppDomain
  langs:
  - csharp
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u een geheel getal dat het toepassingsdomein binnen het proces wordt aangeduid."
  remarks: ''
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/p-system.appdomain.id_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/p-system.appdomain.id_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/p-system.appdomain.id_1.cs)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Een geheel getal waarmee het toepassingsdomein."
  overload: System.AppDomain.Id*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.InitializeLifetimeService
  id: InitializeLifetimeService
  parent: System.AppDomain
  langs:
  - csharp
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Geeft de <xref href=&quot;System.AppDomain&quot;> </xref> een oneindige levensduur door te voorkomen dat een lease wordt gemaakt."
  syntax:
    content: public override object InitializeLifetimeService ();
    parameters: []
    return:
      type: System.Object
      description: "Always <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.AppDomain.InitializeLifetimeService*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  id: IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u een null-waarden bevatten Booleaanse waarde die aangeeft of geen compatibele switches zijn ingesteld, en zo ja, of de switch opgegeven compatibiliteit is ingesteld."
  remarks: "This method tests whether the specified compatibility switch has been set for the current application domain. Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.  They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=fullName> method before creating an application domain.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Its success requires sort00001000.dll to be installed. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain.  See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public Nullable<bool> IsCompatibilitySwitchSet (string value);
    parameters:
    - id: value
      type: System.String
      description: "De schakeloptie compatibiliteit om te testen."
    return:
      type: System.Nullable{System.Boolean}
      description: "Een null-verwijzing (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> in Visual Basic) als er geen compatibele switches zijn ingesteld; anders wordt een Booleaanse waarde die aangeeft of de compatibiliteit schakelen die is opgegeven door <code> value </code> is ingesteld."
  overload: System.AppDomain.IsCompatibilitySwitchSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsDefaultAppDomain
  id: IsDefaultAppDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Retourneert een waarde die aangeeft of het toepassingsdomein het standaardtoepassingsdomein voor het proces is."
  remarks: "Elke beheerde proces heeft een standaardtoepassingsdomein. Uitvoering begint in het standaarddomein."
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/m-system.appdomain.isdef_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/m-system.appdomain.isdef_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/m-system.appdomain.isdef_1.cs)]"
  syntax:
    content: public bool IsDefaultAppDomain ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de huidige <xref href=&quot;System.AppDomain&quot;> </xref> object vertegenwoordigt het standaardtoepassingsdomein voor het proces; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsDefaultAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFinalizingForUnload
  id: IsFinalizingForUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee wordt aangegeven of het verwijderen van dit toepassingsdomein en de objecten hierin zijn door de common language runtime wordt voltooid."
  remarks: "De methode voltooiing voor een object biedt u de mogelijkheid voltooiing bewerkingen uitvoeren voordat het object is de garbage collector zijn verzameld. Na voltooiing is het object toegankelijk, maar in een ongeldige status en daarom onbruikbaar. Uiteindelijk de garbage collector is voltooid en maakt het object.       Een object voltooiing methode wordt aangeroepen in een van de volgende situaties: tijdens de garbagecollection, wanneer de common language runtime wordt afgesloten, of wanneer het toepassingsdomein waarin het object is verwijderd. De methode IsFinalizingForUnload retourneert `true` alleen in het laatste geval; deze geen retourneert `true` als voltooiing van routinematige garbagecollection of CLR afsluiting resulteert.      > [!NOTE] > Gebruiken om te bepalen of voltooiing omdat de CLR wordt afgesloten, de <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName>eigenschap.</xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> Deze retourneert `true` als voltooiing als gevolg van een toepassingsdomein ontladen of CLR afgesloten.       Tijdens het uitvoeren in uw methode voltooiing tijdens het verwijderen van het domein, is het raadzaam voor toegang tot een ander object dat wordt verwezen door een statisch veld en heeft een methode voltooiing. Echter, u betrouwbaar niet mogelijk omdat het gebruikte object is mogelijk al voltooid.      > [!NOTE] > Een uitzondering op deze regel wordt de <xref:System.Console>klasse, die statische velden die verwijzen naar stream-objecten bevat, maar is geïmplementeerd, speciaal zodat u altijd naar de systeemconsole zelfs tijdens het domein verwijderen of het systeem afsluiten schrijven kunt.</xref:System.Console>       Gebruik deze methode methode van de voltooiing van een object om te bepalen of het toepassingsdomein waarin het object wordt verwijderd. Als dit het geval is, kunt u elk object dat een methode voor voltooiing heeft en wordt verwezen door een statisch veld niet betrouwbaar openen."
  syntax:
    content: public bool IsFinalizingForUnload ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het toepassingsdomein van deze is verwijderen en de common language runtime gestart aanroepen eindtekens; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFinalizingForUnload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFullyTrusted
  id: IsFullyTrusted
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Haalt een waarde die aangeeft of de assembly&quot;s die worden geladen in het huidige toepassingsdomein uitgevoerd met volledig vertrouwen."
  remarks: "Deze methode retourneert altijd `true` voor het standaarddomein van de toepassing van een toepassing die wordt uitgevoerd op het bureaublad. Deze retourneert `false` voor een sandbox-toepassingsdomein die is gemaakt met behulp van de [AppDomain.CreateDomain (String, bewijs, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) overbelasting voor methode, tenzij de machtigingen die zijn verleend aan het toepassingsdomein komen overeen met volledig vertrouwen."
  example:
  - "The following example demonstrates the IsFullyTrusted property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> property with fully trusted and partially trusted application domains. The fully trusted application domain is the default application domain for the application. The partially trusted application domain is created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload.  \n  \n The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries. The example creates a `Worker` object in the default application domain. It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly. The application domain is fully trusted, so both assemblies are fully trusted.  \n  \n The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method. Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.  \n  \n [!code-vb[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/visualbasic/p-system.appdomain.isful_1.vb)]\n [!code-cs[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/csharp/p-system.appdomain.isful_1.cs)]"
  syntax:
    content: public bool IsFullyTrusted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de assembly&quot;s die worden geladen in het huidige toepassingsdomein uitvoeren met volledig vertrouwen; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFullyTrusted*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsHomogenous
  id: IsHomogenous
  parent: System.AppDomain
  langs:
  - csharp
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Haalt een waarde die aangeeft of het huidige toepassingsdomein beschikt over een reeks machtigingen die aan alle assembly&quot;s die worden geladen in het toepassingsdomein is verleend."
  remarks: "This property returns `true` for sandboxed application domains that were created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload. Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.  \n  \n Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.  \n  \n This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies."
  syntax:
    content: public bool IsHomogenous { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het huidige toepassingsdomein een homogene reeks machtigingen heeft; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsHomogenous*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[])
  id: Load(System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Laadt het <xref:System.Reflection.Assembly>met een algemene indeling (COFF) op basis van afbeelding voor object-bestand met een verzonden <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>"
  remarks: "Vanaf de [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], het vertrouwensniveau van een assembly die is geladen met deze methode is hetzelfde als het vertrouwensniveau van het toepassingsdomein.       Deze methode mag alleen een assembly te laden in het huidige toepassingsdomein worden gebruikt. Deze methode is uw gemak bedoeld voor interoperabiliteit aanroepfuncties die de statische kunnen niet worden aangeroepen <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>methode.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Als u wilt laden van assembly&quot;s in andere toepassingsdomeinen een methode zoals <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> gebruiken       Zie voor informatie die geldt voor alle overloads van deze methode de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_1_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_1_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_1_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Een matrix van het type <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> die een COFF-installatiekopie met een assembly verzonden."
    return:
      type: System.Reflection.Assembly
      description: "De assembly is geladen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>rawAssembly</code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  id: Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Een <xref:System.Reflection.Assembly>gegeven van de <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly> geladen"
  remarks: "Deze methode mag alleen een assembly te laden in het huidige toepassingsdomein worden gebruikt. Deze methode is uw gemak bedoeld voor interoperabiliteit aanroepfuncties die de statische kunnen niet worden aangeroepen <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>methode.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Als u wilt laden van assembly&quot;s in andere toepassingsdomeinen een methode zoals <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> gebruiken       Als u al een versie van de gewenste assembly is geladen, retourneert deze methode de geladen assembly, zelfs als een andere versie is aangevraagd.       Levert een gedeeltelijke assemblynaam voor `assemblyRef` wordt niet aanbevolen. (Een gedeeltelijke naam worden weggelaten een of meer van de cultuur, versie of openbare-sleuteltoken. Voor overloads die een tekenreeks in plaats van een <xref:System.Reflection.AssemblyName>object, &quot; MyAssembly, versie&1;.0.0.0 = &quot; is een voorbeeld van een gedeeltelijke naam en &quot; MyAssembly, versie&1;.0.0.0, Culture = neutral, PublicKeyToken =&18;ab3442da84b47 = &quot; is een voorbeeld van een volledige naam.)</xref:System.Reflection.AssemblyName> Met behulp van gedeeltelijke namen heeft een negatief effect op de prestaties. Bovendien een gedeeltelijke assemblynaam kunt laden van een assembly uit de global assemblycache alleen als er een exacte kopie van de assembly in de basismap van toepassing is (<xref:System.AppDomain.BaseDirectory%2A> of <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>).</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> </xref:System.AppDomain.BaseDirectory%2A>       Als de huidige <xref:System.AppDomain>object vertegenwoordigt toepassingsdomein `A`, en de <xref:System.AppDomain.Load%2A>methode aangeroepen vanuit toepassingsdomein `B`, de assembly is geladen in beide toepassingsdomeinen.</xref:System.AppDomain.Load%2A> </xref:System.AppDomain> Bijvoorbeeld de volgende code laadt `MyAssembly` in het toepassingsdomein van de nieuwe `ChildDomain` en ook in het toepassingsdomein waarin de code wordt uitgevoerd: [!code-vb [System.AppDomain.Load#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_2_1.vb)][!code-cpp[System.AppDomain.Load#1](~/add/codesnippet/cpp/m-system.appdomain.load-_2_1.cpp)][!code-cs[System.AppDomain.Load#1](~/add/codesnippet/csharp/m-system.appdomain.load-_2_1.cs) ] de assembly wordt geladen in beide domeinen omdat <xref:System.Reflection.Assembly>wordt niet afgeleid van <xref:System.MarshalByRefObject>, en daarom de retourwaarde van de <xref:System.AppDomain.Load%2A>methode kan niet worden gemarshald.</xref:System.AppDomain.Load%2A> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly>     In plaats daarvan de common language runtime wordt geprobeerd de assembly te laden in het toepassingsdomein van de aanroepende. De assembly&quot;s die worden geladen in de twee toepassingsdomeinen kunnen afwijken als de Padinstellingen voor de twee toepassingsdomeinen verschillen.      > [!NOTE] > Als zowel de <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>eigenschap en de <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>eigenschap worden ingesteld, wordt de eerste poging tot het laden van de assembly wordt gebruikt voor de weergavenaam (versie, cultuur, enzovoort, inclusief geretourneerd door de <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>eigenschap).</xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> Als het bestand niet wordt gevonden, de <xref:System.Reflection.AssemblyName.CodeBase%2A>eigenschap wordt gebruikt om te zoeken naar de assembly.</xref:System.Reflection.AssemblyName.CodeBase%2A> Als de assembly is gevonden met behulp van <xref:System.Reflection.AssemblyName.CodeBase%2A>, de weergavenaam wordt vergeleken met de assembly.</xref:System.Reflection.AssemblyName.CodeBase%2A> Als er geen overeenkomst met de, een <xref:System.IO.FileLoadException>gegenereerd.</xref:System.IO.FileLoadException>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Een object dat wordt beschreven van de assembly te laden."
    return:
      type: System.Reflection.Assembly
      description: "De assembly is geladen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>is niet gevonden."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyRef</code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String)
  id: Load(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Laadt een <xref:System.Reflection.Assembly>gegeven van de weergavenaam.</xref:System.Reflection.Assembly>"
  remarks: "Deze methode mag alleen een assembly te laden in het huidige toepassingsdomein worden gebruikt. Deze methode is uw gemak bedoeld voor interoperabiliteit aanroepfuncties die de statische kunnen niet worden aangeroepen <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>methode.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Als u wilt laden van assembly&quot;s in andere toepassingsdomeinen een methode zoals <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> gebruiken       Zie voor informatie die geldt voor alle overloads van deze methode de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString);
    parameters:
    - id: assemblyString
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Reflection.Assembly
      description: "De assembly is geladen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>is<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>is niet gevonden."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyString</code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  id: Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Laadt het <xref:System.Reflection.Assembly>met een algemene indeling (COFF) op basis van afbeelding voor object-bestand met een verzonden <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly> De onbewerkte bytes die aangeeft van de symbolen voor de <xref:System.Reflection.Assembly>ook zijn geladen.</xref:System.Reflection.Assembly>"
  remarks: "Vanaf de [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], het vertrouwensniveau van een assembly die is geladen met deze methode is hetzelfde als het vertrouwensniveau van het toepassingsdomein.       Deze methode mag alleen een assembly te laden in het huidige toepassingsdomein worden gebruikt. Deze methode is uw gemak bedoeld voor interoperabiliteit aanroepfuncties die de statische kunnen niet worden aangeroepen <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>methode.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Als u wilt laden van assembly&quot;s in andere toepassingsdomeinen een methode zoals <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> gebruiken       Zie voor informatie die geldt voor alle overloads van deze methode de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_0_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_0_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_0_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Een matrix van het type <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> die een COFF-installatiekopie met een assembly verzonden."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Een matrix van het type <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> met de onbewerkte bytes dat de symbolen voor de assembly vertegenwoordigt."
    return:
      type: System.Reflection.Assembly
      description: "De assembly is geladen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>rawAssembly</code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  id: Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Een <xref:System.Reflection.Assembly>gegeven van de <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly> geladen"
  remarks: "Deze methode mag alleen een assembly te laden in het huidige toepassingsdomein worden gebruikt. Deze methode is uw gemak bedoeld voor interoperabiliteit aanroepfuncties die de statische kunnen niet worden aangeroepen <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>methode.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Als u wilt laden van assembly&quot;s in andere toepassingsdomeinen een methode zoals <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> gebruiken       Zie voor informatie die geldt voor alle overloads van deze methode de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Een object dat wordt beschreven van de assembly te laden."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Aanwijzingen voor het laden van de assembly."
    return:
      type: System.Reflection.Assembly
      description: "De assembly is geladen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>is<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>is niet gevonden."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyRef</code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  id: Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Laadt een <xref:System.Reflection.Assembly>gegeven van de weergavenaam.</xref:System.Reflection.Assembly>"
  remarks: "Deze methode mag alleen een assembly te laden in het huidige toepassingsdomein worden gebruikt. Deze methode is uw gemak bedoeld voor interoperabiliteit aanroepfuncties die de statische kunnen niet worden aangeroepen <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>methode.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Als u wilt laden van assembly&quot;s in andere toepassingsdomeinen een methode zoals <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> gebruiken       Zie voor informatie die geldt voor alle overloads van deze methode de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyString
      type: System.String
      description: "De weergavenaam van de assembly. Zie &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Aanwijzingen voor het laden van de assembly."
    return:
      type: System.Reflection.Assembly
      description: "De assembly is geladen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>is<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>is niet gevonden."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>assemblyString</code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  id: Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Laadt het <xref:System.Reflection.Assembly>met een algemene indeling (COFF) op basis van afbeelding voor object-bestand met een verzonden <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly> De onbewerkte bytes die aangeeft van de symbolen voor de <xref:System.Reflection.Assembly>ook zijn geladen.</xref:System.Reflection.Assembly>"
  remarks: "Vanaf de [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], het vertrouwensniveau van een assembly die is geladen met deze methode is hetzelfde als het vertrouwensniveau van het toepassingsdomein.       Deze methode mag alleen een assembly te laden in het huidige toepassingsdomein worden gebruikt. Deze methode is uw gemak bedoeld voor interoperabiliteit aanroepfuncties die de statische kunnen niet worden aangeroepen <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>methode.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Als u wilt laden van assembly&quot;s in andere toepassingsdomeinen een methode zoals <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> gebruiken       Zie voor informatie die geldt voor alle overloads van deze methode de <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>methode-overload.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/1e204365-b0ec-4650-8d52-_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/1e204365-b0ec-4650-8d52-_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/1e204365-b0ec-4650-8d52-_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Een matrix van het type <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> die een COFF-installatiekopie met een assembly verzonden."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Een matrix van het type <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> met de onbewerkte bytes dat de symbolen voor de assembly vertegenwoordigt."
    - id: securityEvidence
      type: System.Security.Policy.Evidence
      description: "Aanwijzingen voor het laden van de assembly."
    return:
      type: System.Reflection.Assembly
      description: "De assembly is geladen."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>is geen geldige assembly.       - of - versie 2.0 of hoger van de common language runtime is momenteel zijn geladen en <code>rawAssembly</code> is gecompileerd met een latere versie."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Een assembly of module is tweemaal met twee verschillende grond geladen."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>securityEvidence</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Wanneer het verouderde CAS-beleid niet is ingeschakeld, <code>securityEvidence</code> moet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.MonitoringIsEnabled
  id: MonitoringIsEnabled
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Opgehaald of ingesteld van een waarde die aangeeft of de CPU en geheugenbewaking van toepassingsdomeinen is ingeschakeld voor het huidige proces. Zodra de controle is ingeschakeld voor een proces, kan niet worden uitgeschakeld."
  remarks: "Dit `static` eigenschap (`Shared` eigenschap in Visual Basic) controleert de CPU en geheugen van de toepassingsdomeinen in het proces.       Als u deze eigenschap instellen op `false`, een <xref:System.ArgumentException>uitzondering, zelfs als de huidige waarde van de eigenschap is `false`.</xref:System.ArgumentException>       Zodra de controle is ingeschakeld, kunt u de <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, en <xref:System.AppDomain.MonitoringTotalProcessorTime%2A>instantie-eigenschappen voor het bewaken van CPU en geheugen gebruik van afzonderlijke toepassingsdomeinen.</xref:System.AppDomain.MonitoringTotalProcessorTime%2A> </xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>"
  syntax:
    content: public static bool MonitoringIsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als controle is ingeschakeld; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.MonitoringIsEnabled*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Het huidige proces heeft geprobeerd de waarde toe te wijzen <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> naar deze eigenschap."
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  id: MonitoringSurvivedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u het aantal bytes dat de laatste verzameling bedrijf overleven en die bekend zijn bij naar worden verwezen door het huidige toepassingsdomein."
  remarks: "De statistieken worden bijgewerkt met elke garbagecollection. Maar zijn ze gegarandeerd nauwkeurige alleen na een volledige, blokkeert verzameling; dat wil zeggen collector dat alle generaties bevat en dat de toepassing tijdens de verzameling stopt. Bijvoorbeeld, de <xref:System.GC.Collect?displayProperty=fullName>overbelasting voor methode voert een volledige, verzameling worden geblokkeerd.</xref:System.GC.Collect?displayProperty=fullName> (Gelijktijdige verzameling vindt plaats op de achtergrond en worden niet geblokkeerd voor de toepassing.)"
  syntax:
    content: public long MonitoringSurvivedMemorySize { get; }
    return:
      type: System.Int64
      description: "Het aantal overgebleven bytes."
  overload: System.AppDomain.MonitoringSurvivedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>eigenschap is ingesteld op <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  id: MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee wordt het totale aantal bytes dat het bedrijf overleven opgehaald uit de laatste verzameling voor alle toepassingsdomeinen in het proces."
  remarks: "Na een verzameling volledige, blokkerende beheerd geeft dit getal aan het aantal bytes momenteel ondergebracht live op heaps. Moet zich dicht bij het getal dat is gerapporteerd door de <xref:System.GC.GetTotalMemory%2A>methode.</xref:System.GC.GetTotalMemory%2A> Na een tijdelijke verzameling, geeft dit getal aan het aantal bytes momenteel ondergebracht in kortstondige generaties live."
  syntax:
    content: public static long MonitoringSurvivedProcessMemorySize { get; }
    return:
      type: System.Int64
      description: "Het totale aantal overgebleven bytes voor het proces."
  overload: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>eigenschap is ingesteld op <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  id: MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt de totale grootte, in bytes, voor alle geheugentoewijzingen die zijn aangebracht door het toepassingsdomein sinds deze is gemaakt, zonder af te trekken geheugen die is verzameld."
  syntax:
    content: public long MonitoringTotalAllocatedMemorySize { get; }
    return:
      type: System.Int64
      description: "De totale grootte van alle geheugentoewijzingen."
  overload: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>eigenschap is ingesteld op <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalProcessorTime
  id: MonitoringTotalProcessorTime
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u de totale processortijd dat is gebruikt door alle threads tijdens het uitvoeren in het huidige toepassingsdomein sinds het proces is gestart."
  remarks: "De totale tijd die is gerapporteerd voor een toepassingsdomein bevat de tijd elke thread in het proces wordt uitgevoerd in dat toepassingsdomein.       Een thread die in niet-beheerde code aanroept is nog steeds gekoppeld aan een toepassingsdomein en de tijd van processor besteed aan het uitvoeren van die de niet-beheerde code is gerapporteerd voor het toepassingsdomein waarin de oproep heeft plaatsgevonden.       Als een thread is geblokkeerd of in de slaapstand, niet toeneemt processortijd."
  syntax:
    content: public TimeSpan MonitoringTotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Totale processortijd voor het huidige toepassingsdomein."
  overload: System.AppDomain.MonitoringTotalProcessorTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>eigenschap is ingesteld op <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.PermissionSet
  id: PermissionSet
  parent: System.AppDomain
  langs:
  - csharp
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u de machtigingenset van een sandbox-toepassingsdomein."
  remarks: "Sandbox toepassingsdomeinen die zijn gemaakt met behulp van de [AppDomain.CreateDomain (String, bewijs, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) methode-overload hebben een homogene reeks machtigingen; dat wil zeggen, dezelfde set machtigingen te krijgen tot alle gedeeltelijk vertrouwde assembly&quot;s die worden geladen in het toepassingsdomein. Een sandbox-toepassingsdomein is optioneel een lijst met sterke naam assembly&quot;s die zijn uitgesloten van deze machtiging is ingesteld en in plaats daarvan met volledig vertrouwen worden uitgevoerd."
  syntax:
    content: public System.Security.PermissionSet PermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "De machtigingenset van de sandbox-toepassingsdomein."
  overload: System.AppDomain.PermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ProcessExit
  id: ProcessExit
  parent: System.AppDomain
  langs:
  - csharp
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Deze gebeurtenis treedt op wanneer het standaardtoepassingsdomein bovenliggende proces wordt afgesloten."
  remarks: "De <xref:System.EventHandler>voor deze gebeurtenis kunt beëindiging activiteiten uitvoeren, zoals bestanden, sluiten vrijgeven opslag enzovoort, voordat het proces is afgelopen.</xref:System.EventHandler>       Vanaf versie 2.0 van .NET Framework is is deze gebeurtenis opgetreden in elk toepassingsdomein een gebeurtenis-handler registreert.      > [!NOTE] > De totale uitvoeringstijd van alle ProcessExit gebeurtenis-handlers is beperkt, net als de totale tijd van de uitvoering van alle eindtekens op afsluitproces beperkt is. De standaardwaarde is twee seconden. Een niet-beheerde host deze uitvoeringstijd kunt wijzigen door het aanroepen van de [ICLRPolicyManager::SetTimeout](~/add/includes/ajax-current-ext-md.md) methode met de [OPR_ProcessExit](~/add/includes/ajax-current-ext-md.md) opsommingswaarde.       In de .NET Framework-versies 1.0 en 1.1 wordt deze gebeurtenis treedt alleen op in het standaardtoepassingsdomein en wel alleen als een gebeurtenis-handler is geregistreerd in het standaardtoepassingsdomein.       U moet de vereiste machtigingen hebben voor het registreren van een gebeurtenis-handler voor deze gebeurtenis, of een <xref:System.Security.SecurityException>gegenereerd.</xref:System.Security.SecurityException>       Zie voor meer informatie over het verwerken van gebeurtenissen [gebeurtenissen](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler ProcessExit;
    return:
      type: System.EventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  id: ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Deze gebeurtenis treedt op wanneer de resolutie van een assembly is mislukt in de context van de alleen-reflectie."
  remarks: "In de context alleen-reflectie zijn afhankelijkheden niet automatisch opgelost. Ze moeten vooraf geladen of door de handler voor deze gebeurtenis wordt geretourneerd. Deze gebeurtenis treedt op wanneer een assembly heeft een afhankelijkheid die nog niet is geladen in de context van het kenmerk alleen-reflectie. De ontbrekende afhankelijkheid wordt opgegeven door de <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>eigenschap.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> De <xref:System.ResolveEventHandler>voor deze gebeurtenis moet een assembly die voldoet aan de afhankelijkheid retourneren.</xref:System.ResolveEventHandler> De assembly die wordt geretourneerd, moet worden geladen in de context van het kenmerk alleen-reflectie.      > [!IMPORTANT] > Deze gebeurtenis wordt gestart alleen voor ontbrekende afhankelijkheden van de assembly die u in de context van het kenmerk alleen-reflectie laadt (bijvoorbeeld met behulp van de <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName>methode).</xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> Het is niet gegenereerd als de assembly die u laadt kan niet worden gevonden.       Vanaf de [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], wordt de <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>eigenschap retourneert de assembly die de belasting van de assembly die niet kan omgezet worden aangevraagd.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> De identiteit van de aanvragende assembly weten mogelijk handig bij het identificeren van de juiste versie van de afhankelijkheid als meer dan één versie beschikbaar is. Zie voor meer informatie <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Voor deze gebeurtenis, de <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>eigenschap retourneert de assemblynaam voordat beleid wordt toegepast.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>       Zie voor meer informatie over het verwerken van gebeurtenissen [gebeurtenissen](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ReflectionOnlyAssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  id: ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Retourneert de assembly&quot;s die zijn geladen in de context van het kenmerk alleen-reflectie van het toepassingsdomein."
  remarks: "Deze methode retourneert de assembly&quot;s die zijn geladen in de context van het kenmerk alleen-reflectie. Als u de assembly&quot;s die zijn geladen voor uitvoering, gebruikt de <xref:System.AppDomain.GetAssemblies%2A>methode.</xref:System.AppDomain.GetAssemblies%2A>"
  example:
  - "The following code example loads the System.dll assembly into the execution context and then into the reflection-only context. The <xref:System.AppDomain.GetAssemblies%2A> and ReflectionOnlyGetAssemblies methods are used to display the assemblies loaded into each context.  \n  \n [!code-cs[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.refle_1.cs)]\n [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.refle_1.cpp)]\n [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.refle_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "Een matrix van <xref:System.Reflection.Assembly>-objecten met daarin de assembly&quot;s in de context van het kenmerk alleen-reflectie van het toepassingsdomein geladen.</xref:System.Reflection.Assembly>"
  overload: System.AppDomain.ReflectionOnlyGetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Een bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.RelativeSearchPath
  id: RelativeSearchPath
  parent: System.AppDomain
  langs:
  - csharp
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee wordt het pad onder de basismap waar de assembly-omzetter moet probe voor persoonlijke assembly&quot;s."
  remarks: "Persoonlijke assembly&quot;s worden geïmplementeerd in dezelfde mapstructuur als de toepassing. Als het pad dat is opgegeven door de eigenschap RelativeSearchPath is geen onder <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>, wordt dit genegeerd.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>       Deze eigenschap retourneert de waarde die is ingesteld met <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  syntax:
    content: public string RelativeSearchPath { get; }
    return:
      type: System.String
      description: "Het pad onder de basismap waar de assembly-omzetter moet probe voor persoonlijke assembly&quot;s."
  overload: System.AppDomain.RelativeSearchPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.ResourceResolve
  id: ResourceResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Deze gebeurtenis treedt op wanneer de resolutie van een bron is mislukt omdat de bron geen geldige gekoppeld of ingesloten resource in de assembly is."
  remarks: "De <xref:System.ResolveEventHandler>voor deze gebeurtenis kunt proberen te vinden van de assembly met de bron en deze retourneren</xref:System.ResolveEventHandler>      > [!IMPORTANT] > Deze gebeurtenis wordt niet gestart als de omzetting mislukt omdat er geen bestand worden voor een geldige gekoppelde resource gevonden kan. Dit treedt op als een manifestbron-stroom kan niet worden gevonden, maar deze wordt niet gegenereerd als een afzonderlijke bronsleutel kan niet worden gevonden.       Vanaf de [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], wordt de <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>eigenschap bevat de assembly die de resource heeft aangevraagd.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Zie voor meer informatie <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       U moet de vereiste machtigingen hebben voor het registreren van een gebeurtenis-handler voor deze gebeurtenis, of een <xref:System.Security.SecurityException>gegenereerd.</xref:System.Security.SecurityException>       Zie voor meer informatie over het verwerken van gebeurtenissen [gebeurtenissen](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ResourceResolve;
    return:
      type: System.ResolveEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  id: SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee stelt u het beveiligingsniveau voor beleid voor dit toepassingsdomein."
  remarks: "Deze methode niet aanroepen voordat een assembly is geladen in de <xref:System.AppDomain>in volgorde voor het beveiligingsbeleid heeft.</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the SetAppDomainPolicymethod to set the security policy level of an application domain.  \n  \n [!code-cs[ADSetAppDomainPolicy#1](~/add/codesnippet/csharp/m-system.appdomain.setap_1.cs)]\n [!code-cpp[ADSetAppDomainPolicy#1](~/add/codesnippet/cpp/m-system.appdomain.setap_1.cpp)]\n [!code-vb[ADSetAppDomainPolicy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setap_1.vb)]"
  syntax:
    content: public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);
    parameters:
    - id: domainPolicy
      type: System.Security.Policy.PolicyLevel
      description: "Het beveiligingsniveau beleid."
  overload: System.AppDomain.SetAppDomainPolicy*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domainPolicy</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "Het beveiligingsniveau van het beleid is al ingesteld."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.SetCachePath(System.String)
  id: SetCachePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee stelt het pad van de opgegeven als de locatie waar de assembly&quot;s schaduwkopieën zijn."
  remarks: "Het cachepad wordt genegeerd als de <xref:System.AppDomainSetup.ApplicationName%2A>eigenschap is niet ingesteld.</xref:System.AppDomainSetup.ApplicationName%2A> Zie de <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>eigenschap.</xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>       Zie voor meer informatie over het kopiëren van de schaduw [Shadow kopiëren assembly&quot;s](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetCachePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Het volledig gekwalificeerde pad naar de shadow copy-locatie."
  overload: System.AppDomain.SetCachePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object)
  id: SetData(System.String,System.Object)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De opgegeven waarde voor de eigenschap van de opgegeven toepassing domain toegewezen."
  remarks: "Gebruik deze methode invoegen een vermelding, of wijzig de waarde van een item in een interne cache met naam-data-paren die de eigenschappen van dit exemplaar van <xref:System.AppDomain>.</xref:System.AppDomain> beschrijven       De cache automatisch bevat vooraf gedefinieerde system-vermeldingen die zijn ingevoegd als het toepassingsdomein wordt gemaakt. Niet invoegen of systeem vermeldingen met deze methode wijzigen. Een methodeaanroep die toegang probeert te wijzigen van een vermelding systeem heeft geen effect; de methode heeft een uitzondering niet genereren. U kunt de waarden van het systeem vermeldingen met de <xref:System.AppDomain.GetData%2A>methode, of de equivalente <xref:System.AppDomainSetup>Eigenschappen in <xref:System.AppDomain.GetData%2A>.</xref:System.AppDomain.GetData%2A> beschreven</xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A> inspecteren       U kunt deze methode voor het instellen van de waarde van de standaard time-outinterval voor de evaluatie van reguliere expressiepatronen door levering &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; aanroepen als de waarde van de `name` argument en een <xref:System.TimeSpan>waarde waarmee de time-outinterval als de waarde van de `data` argument.</xref:System.TimeSpan> U kunt ook invoegen of uw eigen paren van de gebruiker gedefinieerde naam gegevens wijzigen met deze methode en hun waarden met inspecteren de <xref:System.AppDomain.GetData%2A>methode.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following example demonstrates how to use the SetData method to create a new value pair. The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.setda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.setda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.setda_1.cs)]"
  syntax:
    content: public void SetData (string name, object data);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de domein-eigenschap van een aangepaste toepassing maken of wijzigen."
    - id: data
      type: System.Object
      description: "De waarde van de eigenschap."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  id: SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "De opgegeven waarde wordt toegewezen aan de eigenschap van de opgegeven toepassing domein met een opgegeven machtigingen op de vraag van de aanroepfunctie wanneer de eigenschap wordt opgehaald."
  remarks: "Gebruik deze methode in te voegen of te wijzigen van uw eigen aangepaste vermeldingen in een interne cache van naamgegevens/waardeparen die de eigenschappen van het toepassingsdomein beschrijven. Wanneer u een vermelding invoegt, kunt u een aanvraag voor machtiging om af te dwingen wanneer de vermelding wordt opgehaald. Bovendien kunt u deze methode voor het instellen van de waarde van de standaard time-outinterval voor de evaluatie van reguliere expressiepatronen door levering &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; aanroepen als de waarde van de `name` argument en een <xref:System.TimeSpan>waarde waarmee de time-outinterval als de waarde van de `data` argument.</xref:System.TimeSpan>       U kunt deze methode niet gebruiken een vraag beveiliging toewijzen aan een eigenschap van het systeem gedefinieerde tekenreeks.       De cache automatisch bevat vooraf gedefinieerde system-vermeldingen die zijn ingevoegd als het toepassingsdomein wordt gemaakt. Niet invoegen of systeem vermeldingen met deze methode wijzigen. Een methodeaanroep die toegang probeert te wijzigen van een vermelding systeem heeft geen effect; de methode heeft een uitzondering niet genereren. U kunt de waarden van vermeldingen met systeem inspecteren de <xref:System.AppDomain.GetData%2A>methode of een vergelijkbare <xref:System.AppDomainSetup>Eigenschappen die worden beschreven in de sectie met opmerkingen voor de <xref:System.AppDomain.GetData%2A>methode.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>"
  syntax:
    content: public void SetData (string name, object data, System.Security.IPermission permission);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de domein-eigenschap van een aangepaste toepassing maken of wijzigen."
    - id: data
      type: System.Object
      description: "De waarde van de eigenschap."
    - id: permission
      type: System.Security.IPermission
      description: "De machtiging op de vraag van de aanroepfunctie wanneer de eigenschap wordt opgehaald."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>name</code>Hiermee geeft u een eigenschap van het systeem gedefinieerde tekenreeks en <code>permission</code> is niet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.SetDynamicBase(System.String)
  id: SetDynamicBase(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee stelt het pad van de opgegeven als de basismap voor submappen waar dynamisch gegenereerde bestanden worden opgeslagen en toegankelijk is."
  remarks: "Deze methode stelt de <xref:System.AppDomainSetup.DynamicBase%2A>eigenschap van de interne <xref:System.AppDomainSetup>gekoppeld aan dit exemplaar.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A>"
  example:
  - "This method is now obsolete, and should not be used for new development. The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property. For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/m-system.appdomain.setdy_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/m-system.appdomain.setdy_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/m-system.appdomain.setdy_1.vb)]"
  syntax:
    content: public void SetDynamicBase (string path);
    parameters:
    - id: path
      type: System.String
      description: "Het volledig gekwalificeerde pad dat is de basismap voor submappen waarin dynamische assembly&quot;s worden opgeslagen."
  overload: System.AppDomain.SetDynamicBase*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  id: SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee geeft u op hoe objecten principal en identiteit moeten worden gekoppeld aan een thread als de thread probeert te binden aan een principal tijdens het uitvoeren in het toepassingsdomein van deze."
  remarks: "Als u deze waarde alleen worden van kracht als u deze voordat u instellen de <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>eigenschap.</xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Als u bijvoorbeeld <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>naar een bepaalde principal (bijvoorbeeld een algemene principal) en gebruik vervolgens de methode SetPrincipalPolicy om in te stellen de <xref:System.Security.Principal.PrincipalPolicy>naar <xref:System.Security.Principal.PrincipalPolicy>, de huidige principal blijft de algemene principal.</xref:System.Security.Principal.PrincipalPolicy> </xref:System.Security.Principal.PrincipalPolicy> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>"
  example:
  - "The following example shows the effect on threads of using the SetPrincipalPolicy method to change the principal policy of the application domain. It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setpr_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setpr_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setpr_1.cs)]"
  syntax:
    content: public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Principal.PrincipalPolicy
      description: "Een van de <xref href=&quot;System.Security.Principal.PrincipalPolicy&quot;> </xref> waarden waarmee het type van de principal-object te koppelen aan threads."
  overload: System.AppDomain.SetPrincipalPolicy*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyFiles
  id: SetShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee schakelt u schaduwkopieën maken."
  remarks: "Zie voor meer informatie over het kopiëren van de schaduw [Shadow kopiëren assembly&quot;s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[adproperties#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_0_1.cpp)]\n [!code-vb[adproperties#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_0_1.vb)]\n [!code-cs[adproperties#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_0_1.cs)]"
  syntax:
    content: public void SetShadowCopyFiles ();
    parameters: []
  overload: System.AppDomain.SetShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  id: SetShadowCopyPath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee stelt het pad van de opgegeven als de locatie van de assembly&quot;s schaduwkopieën."
  remarks: "Een schaduwkopie bevat standaard alle assembly&quot;s via probing gevonden. De methode SetShadowCopyPath de schaduwkopie beperkt tot de assembly&quot;s in de mappen die zijn opgegeven door `path`.       De methode SetShadowCopyPath geeft geen extra mappen waarin wordt gezocht naar assembly&quot;s. Assembly&quot;s die moeten worden gekopieerd van schaduwkopieën moeten al zich bevinden in het zoekpad bijvoorbeeld onder <xref:System.AppDomain.BaseDirectory%2A>.</xref:System.AppDomain.BaseDirectory%2A> De methode SetShadowCopyPath geeft aan welke zoekpaden shadow gekopieerd.       Deze methode stelt de <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>eigenschap van de interne <xref:System.AppDomainSetup>gekoppeld aan dit exemplaar.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ShadowCopyDirectories%2A>       Zie voor meer informatie over het kopiëren van de schaduw [Shadow kopiëren assembly&quot;s](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADShadowCopy#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_1_1.cpp)]\n [!code-vb[ADShadowCopy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_1_1.vb)]\n [!code-cs[ADShadowCopy#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_1_1.cs)]"
  syntax:
    content: public void SetShadowCopyPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Een lijst met namen van mappen, waarin de naam van elke worden gescheiden door puntkomma&quot;s."
  overload: System.AppDomain.SetShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  id: SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee stelt u de principal-standaardobjecten aan threads gekoppeld als ze proberen te binden aan een principal tijdens het uitvoeren in het toepassingsdomein van deze."
  remarks: ''
  example:
  - "The following example shows the effect of using the SetThreadPrincipal method to change the principal that is available for attaching to threads that are executing in the application domain. It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setth_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setth_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setth_1.cs)]"
  syntax:
    content: public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);
    parameters:
    - id: principal
      type: System.Security.Principal.IPrincipal
      description: "De principal-object te koppelen aan threads."
  overload: System.AppDomain.SetThreadPrincipal*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>principal</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "De thread-principal is al ingesteld."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.SetupInformation
  id: SetupInformation
  parent: System.AppDomain
  langs:
  - csharp
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee haalt u de toepassing configuration domeingegevens voor dit exemplaar."
  syntax:
    content: public AppDomainSetup SetupInformation { get; }
    return:
      type: System.AppDomainSetup
      description: "Domein initialisatie van de informatie over de toepassing."
  overload: System.AppDomain.SetupInformation*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Met deze eigenschap geeft aan of het toepassingsdomein is geconfigureerd voor shadow copy-bestanden."
  remarks: "Zie voor meer informatie <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>en [Shadow kopiëren assembly&quot;s](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>"
  syntax:
    content: public bool ShadowCopyFiles { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het toepassingsdomein is geconfigureerd voor shadow copy-bestanden. anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.ShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "De bewerking is geprobeerd op een verwijderd toepassingsdomein."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Een set namen toegewezen aan een overeenkomende set van dispatch-id."
  remarks: "Deze methode is voor toegang tot beheerde klassen vanuit niet-beheerde code en moet niet worden aangeroepen vanuit beheerde code. Voor meer informatie over `IDispatch::GetIDsOfNames`, Zie de MSDN-bibliotheek."
  syntax:
    content: void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Gereserveerd voor toekomstig gebruik. Moet IID_NULL."
    - id: rgszNames
      type: System.IntPtr
      description: "Doorgegeven in de matrix van namen worden toegewezen."
    - id: cNames
      type: System.UInt32
      description: "Telling van de namen worden toegewezen."
    - id: lcid
      type: System.UInt32
      description: "De landinstelling context waarin u de namen te interpreteren."
    - id: rgDispId
      type: System.IntPtr
      description: "Aanroeper toegewezen matrix die de id&quot;s die overeenkomen met de namen ontvangt."
  overload: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Laatgebonden toegang met behulp van de COM `IDispatch` interface wordt niet ondersteund."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Haalt de type-informatie voor een object, die vervolgens kan worden gebruikt voor het type-informatie voor een interface."
  remarks: "Deze methode is voor toegang tot beheerde klassen vanuit niet-beheerde code en moet niet worden aangeroepen vanuit beheerde code. Voor meer informatie over `IDispatch::GetTypeInfo`, Zie de MSDN-bibliotheek."
  syntax:
    content: void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "De type-informatie te retourneren."
    - id: lcid
      type: System.UInt32
      description: "De landinstellingen-id voor de type-informatie."
    - id: ppTInfo
      type: System.IntPtr
      description: "Hiermee krijgt een verwijzing naar het gevraagde type-informatie-object."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Laatgebonden toegang met behulp van de COM `IDispatch` interface wordt niet ondersteund."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  id: System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Het nummer van het type informatie interfaces dat een object (0 of 1) biedt opgehaald."
  remarks: "Deze methode is voor toegang tot beheerde klassen vanuit niet-beheerde code en moet niet worden aangeroepen vanuit beheerde code. Voor meer informatie over `IDispatch::GetTypeInfoCount`, Zie de MSDN-bibliotheek."
  syntax:
    content: void _AppDomain.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Verwijst naar een locatie die het nummer van het type informatie interfaces van het object ontvangt."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Laatgebonden toegang met behulp van de COM `IDispatch` interface wordt niet ondersteund."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Biedt toegang tot eigenschappen en methoden die worden weergegeven door een object."
  remarks: "Deze methode is voor toegang tot beheerde klassen vanuit niet-beheerde code en moet niet worden aangeroepen vanuit beheerde code. Voor meer informatie over `IDispatch::Invoke`, Zie de MSDN-bibliotheek."
  syntax:
    content: void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "Identificeert het lid."
    - id: riid
      type: System.Guid
      description: "Gereserveerd voor toekomstig gebruik. Moet IID_NULL."
    - id: lcid
      type: System.UInt32
      description: "De landinstelling context waarin u argumenten interpreteren."
    - id: wFlags
      type: System.Int16
      description: "De vlaggen met een beschrijving van de context van de aanroep."
    - id: pDispParams
      type: System.IntPtr
      description: "Verwijzing naar een structuur met een matrix van argumenten, een matrix van dit argument DISPID&quot;s voor benoemde argumenten en tellingen voor het aantal elementen in de arrays."
    - id: pVarResult
      type: System.IntPtr
      description: "Verwijzing naar de locatie van het resultaat moet worden opgeslagen."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Verwijzing naar een structuur die informatie over de uitzondering bevat."
    - id: puArgErr
      type: System.IntPtr
      description: "De index van het eerste argument waarvoor een fout."
  overload: System.AppDomain.System#_AppDomain#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Laatgebonden toegang met behulp van de COM `IDispatch` interface wordt niet ondersteund."
  platform:
  - net462
- uid: System.AppDomain.ToString
  id: ToString
  parent: System.AppDomain
  langs:
  - csharp
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Een tekenreeks waarin de beschrijvende naam van het toepassingsdomein en Contextbeleid verkrijgt."
  remarks: ''
  example:
  - "The following code example displays the return value of the ToString method.  \n  \n [!code-cpp[ADToString#1](~/add/codesnippet/cpp/m-system.appdomain.tostr_1.cpp)]\n [!code-cs[ADToString#1](~/add/codesnippet/csharp/m-system.appdomain.tostr_1.cs)]\n [!code-vb[ADToString#1](~/add/codesnippet/visualbasic/m-system.appdomain.tostr_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Een tekenreeks gevormd door samenvoeging van de letterlijke tekenreeks &quot; Name: &quot;, de beschrijvende naam van het toepassingsdomein en tekenreeks weergaven van de Contextbeleid of een tekenreeks &quot;Er is geen contextbeleid.&quot;"
  overload: System.AppDomain.ToString*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Het toepassingsdomein vertegenwoordigd door de huidige <xref href=&quot;System.AppDomain&quot;> </xref> is verwijderd."
  platform:
  - net462
- uid: System.AppDomain.TypeResolve
  id: TypeResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Deze gebeurtenis treedt op wanneer de resolutie van een type mislukt."
  remarks: "De TypeResolve gebeurtenis treedt op wanneer de common language runtime kan niet bepalen van de assembly die het gevraagde type kunt maken. Dit kan gebeuren als het type is gedefinieerd in een dynamische assembly of het type is niet gedefinieerd in een dynamische assembly, maar de runtime niet welke het type is gedefinieerd weet in assembly. Het laatste geval kan optreden wanneer <xref:System.Type.GetType%2A?displayProperty=fullName>is aangeroepen met een typenaam die is niet gekwalificeerd met de assembly-naam.</xref:System.Type.GetType%2A?displayProperty=fullName>       De <xref:System.ResolveEventHandler>voor deze gebeurtenis proberen kunt om te zoeken en te maken van het type.</xref:System.ResolveEventHandler>       De gebeurtenis TypeResolve wordt niet uitgevoerd als de runtime kent dat het is niet mogelijk om te zoeken van een type in bepaalde assembly&quot;s. Deze gebeurtenis treedt bijvoorbeeld niet als het type niet in een statische assembly gevonden is omdat de runtime kent typen kunnen niet dynamisch worden toegevoegd aan de statische assembly&quot;s.       Vanaf de [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], wordt de <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>eigenschap bevat de assembly die het type aangevraagd.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Zie voor meer informatie <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       U moet de vereiste machtigingen hebben voor het registreren van een gebeurtenis-handler voor deze gebeurtenis, of een <xref:System.Security.SecurityException>gegenereerd.</xref:System.Security.SecurityException>       Zie voor meer informatie over het verwerken van gebeurtenissen [gebeurtenissen](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the TypeResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_TypeResolve#1](~/add/codesnippet/csharp/e-system.appdomain.typer_1.cs)]\n [!code-vb[AppDomain_TypeResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.typer_1.vb)]\n [!code-cpp[AppDomain_TypeResolve#1](~/add/codesnippet/cpp/e-system.appdomain.typer_1.cpp)]"
  syntax:
    content: public event ResolveEventHandler TypeResolve;
    return:
      type: System.ResolveEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.UnhandledException
  id: UnhandledException
  parent: System.AppDomain
  langs:
  - csharp
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Treedt op wanneer een uitzondering is niet bijgewerkt."
  remarks: "Deze gebeurtenis biedt melding van niet-onderschepte uitzonderingen. Hierdoor kan de toepassing voor informatie over de uitzondering zich vóór de standaard-handler van het systeem rapporten van de uitzondering voor de gebruiker en de toepassing wordt beëindigd. Als er voldoende informatie over de status van de toepassing beschikbaar is, andere acties kunnen worden uitgevoerd, zoals het opslaan van gegevens voor het programma voor latere herstel. Waarschuwing wordt aanbevolen, omdat de gegevens voor het programma kan beschadigd raken wanneer uitzonderingen worden niet verwerkt.      > [!NOTE] > In de .NET Framework-versies 1.0 en 1.1, beëindiging van de toepassing en opties voor foutopsporing worden gerapporteerd aan de gebruiker voordat u deze gebeurtenis treedt op in plaats van na.       Deze gebeurtenis kan worden verwerkt in elk toepassingsdomein. De gebeurtenis is echter niet per se opgetreden in het toepassingsdomein waarin de uitzondering is opgetreden. Een uitzondering wordt verwerkt alleen als de volledige stack voor de thread afgewikkeld is zonder een toepasselijke uitzonderings-handler zoeken om de eerste plaats die de gebeurtenis kan worden verhoogd in het toepassingsdomein waarin de thread afkomstig is.      > [!NOTE] > In de .NET Framework-versies 1.0 en 1.1, deze gebeurtenis treedt op alleen voor het standaardtoepassingsdomein die door het systeem wordt gemaakt wanneer een toepassing wordt gestart. Als een toepassing extra toepassingsdomeinen maakt, heeft het opgeven van een gemachtigde voor deze gebeurtenis in deze domeinen toepassingen geen effect.       Als de gebeurtenis UnhandledException wordt verwerkt bij het standaardtoepassingsdomein, is deze er gegeven voor een niet-verwerkte uitzondering in een willekeurige thread, ongeacht welk domein van de thread is gestart in. Als de thread is gestart in een toepassingsdomein dat een gebeurtenis-handler voor UnhandledException heeft, wordt de gebeurtenis wordt gestart in dat toepassingsdomein. Als dat toepassingsdomein niet het standaardtoepassingsdomein is en er ook een gebeurtenis-handler in het domein van de toepassing standaard is, wordt de gebeurtenis wordt gestart in beide toepassingsdomeinen.       Bijvoorbeeld, Stel dat een thread is gestart in toepassingsdomein &quot;AD1&quot; een methode wordt aangeroepen in het toepassingsdomein &quot;AD2&quot; en daar een methode wordt aangeroepen in het toepassingsdomein &quot;AD3&quot;, waarbij het genereert een uitzondering. Het eerste toepassingsdomein waarin de gebeurtenis UnhandledException kan worden verhoogd is &quot;AD1&quot;. Als dat toepassingsdomein niet het standaardtoepassingsdomein, kan de gebeurtenis ook in het standaardtoepassingsdomein worden verhoogd.      > [!NOTE] > De common language runtime wordt onderbroken thread wordt afgebroken tijdens het uitvoeren van gebeurtenis-handlers voor de gebeurtenis UnhandledException.       Als de gebeurtenis-handler heeft een <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>kenmerk met de juiste vlaggen de gebeurtenis-handler wordt behandeld als een beperkte uitvoeringsregio.</xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>       Beginnen met de [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], deze gebeurtenis wordt niet gestart voor uitzonderingen die beschadigd van de status van het proces, zoals stack-overloop of toegang krijgen tot schendingen, tenzij de gebeurtenis-handler risicovolle is en heeft de <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>kenmerk.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       In de .NET Framework-versies 1.0 en 1.1, een onverwerkte uitzondering in een andere thread dan de thread van de hoofdtoepassing wordt onderschept door de runtime en daarom leidt niet tot de toepassing te beëindigen. Het is dus mogelijk dat de gebeurtenis UnhandledException zonder de beëindiging van de toepassing wordt gegenereerd. Beginnen met de .NET Framework versie 2.0, is deze backstop voor niet-verwerkte uitzonderingen in onderliggende threads verwijderd, omdat het cumulatieve effect van dergelijke fouten achtergrond opgenomen verminderde prestaties, beschadigde gegevens en lockups, die allemaal zijn moeilijk op te lossen. Zie voor meer informatie, waaronder een lijst van gevallen waarin de runtime niet beëindigt, [uitzonderingen in beheerd Threads](~/add/includes/ajax-current-ext-md.md).       U moet de vereiste machtigingen hebben voor het registreren van een gebeurtenis-handler voor deze gebeurtenis, of een <xref:System.Security.SecurityException>gegenereerd.</xref:System.Security.SecurityException>       Zie voor meer informatie over het verwerken van gebeurtenissen [gebeurtenissen](~/add/includes/ajax-current-ext-md.md).      ## Andere gebeurtenissen voor niet-verwerkte uitzonderingen voor bepaalde toepassing modellen, de UnhandledException gebeurtenis kan worden gebruikt door andere gebeurtenissen als de niet-verwerkte uitzondering in de hoofdtoepassing-thread optreedt.       In toepassingen die gebruikmaken van Windows Forms, niet-verwerkte uitzonderingen in de oorzaak van de thread hoofdtoepassing de <xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName>gebeurtenis wordt gegenereerd.</xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName> Als deze gebeurtenis wordt verwerkt, is het standaardgedrag dat de niet-verwerkte uitzondering niet de toepassing beëindigt, hoewel de toepassing een onbekende status blijft. De gebeurtenis UnhandledException wordt in dat geval niet gestart. Dit gedrag kan worden gewijzigd met behulp van het configuratiebestand of via de <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName>methode voor het wijzigen van de modus <xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName>voordat de <xref:System.Windows.Forms.Application.ThreadException>gebeurtenis-handler is aangesloten up</xref:System.Windows.Forms.Application.ThreadException> </xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName> </xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName> Dit geldt alleen voor de hoofdtoepassing-thread. De UnhandledException-gebeurtenis wordt geactiveerd voor niet-verwerkte uitzonderingen in andere threads.       Beginnen met Microsoft Visual Studio 2005, biedt het toepassingsframework Visual Basic een andere gebeurtenis voor niet-verwerkte uitzonderingen in de hoofdtoepassing-thread. Zie de <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName>gebeurtenis.</xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName> Deze gebeurtenis heeft een gebeurtenis argumenten-object met dezelfde naam als het object arguments van gebeurtenis die wordt gebruikt door UnhandledException, maar met verschillende eigenschappen. In het bijzonder dit event argumenten-object heeft een <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>eigenschap waarmee de toepassing om door te gaan die wordt uitgevoerd de niet-verwerkte uitzondering wordt genegeerd (en zonder de toepassing in een onbekende status).</xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> De gebeurtenis UnhandledException wordt in dat geval niet gestart."
  example:
  - "The followingexample demonstrates the UnhandledException event. It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain. It then throws two exceptions. The first is handled by a **try/catch** block. The second is unhandled and invokes the `MyHandle` routine before the application terminates.  \n  \n [!code-cs[AppDomain_UnhandledException#1](~/add/codesnippet/csharp/e-system.appdomain.unhan_1.cs)]\n [!code-vb[AppDomain_UnhandledException#1](~/add/codesnippet/visualbasic/e-system.appdomain.unhan_1.vb)]\n [!code-cpp[AppDomain_UnhandledException#1](~/add/codesnippet/cpp/e-system.appdomain.unhan_1.cpp)]"
  syntax:
    content: public event UnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.UnhandledExceptionEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Unload(System.AppDomain)
  id: Unload(System.AppDomain)
  parent: System.AppDomain
  langs:
  - csharp
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Hiermee wordt het domein van de opgegeven toepassing."
  remarks: "In versie 2.0 van .NET Framework is een thread toegewezen aan lossen toepassingsdomeinen. Dit verbetert de betrouwbaarheid, vooral wanneer .NET Framework wordt gehost. Als een thread-aanroepen Unload, wordt voor het verwijderen van het doeldomein gemarkeerd. De speciale thread probeert te verwijderen (Unload) van het domein en alle threads in het domein worden afgebroken. Als een thread is niet afbreken, bijvoorbeeld omdat deze niet-beheerde code wordt uitgevoerd, of omdat deze wordt uitgevoerd een `finally` blok, moet u na een bepaalde periode een <xref:System.CannotUnloadAppDomainException>gegenereerd in de thread die oorspronkelijk Unload aangeroepen.</xref:System.CannotUnloadAppDomainException> Als de thread die niet uiteindelijk kan worden afgebroken eindigt, is het doeldomein niet verwijderd. Dus in versie 2.0 van .NET Framework `domain` kan niet worden gegarandeerd verwijderen (Unload), omdat het is niet mogelijk is de uitvoerende threads is beëindigd.      > [!NOTE] > In sommige gevallen kan het aanroepen van Unload zorgt ervoor dat een onmiddellijke <xref:System.CannotUnloadAppDomainException>, bijvoorbeeld wanneer deze wordt aangeroepen in een finalizer.</xref:System.CannotUnloadAppDomainException>       De threads in `domain` worden beëindigd met de <xref:System.Threading.Thread.Abort%2A>methode, waarmee genereert een <xref:System.Threading.ThreadAbortException>in de thread.</xref:System.Threading.ThreadAbortException> </xref:System.Threading.Thread.Abort%2A> Hoewel de thread onmiddellijk beëindigt moet, kan deze blijven uitvoeren voor een onvoorspelbare hoeveelheid tijd in een `finally` component.      ## Versie compatibiliteit In de .NET Framework versie 1.0 en 1.1 als de thread die Unload aanroept wordt uitgevoerd in `domain`, een andere thread is gestart om de bewerking uit het geheugen laden. Als `domain` kan niet worden verwijderd, een <xref:System.CannotUnloadAppDomainException>gegenereerd in die thread, niet in de oorspronkelijke thread die Unload aangeroepen.</xref:System.CannotUnloadAppDomainException> Echter, als de thread die aanroept Unload wordt uitgevoerd buiten `domain`, dat thread de uitzondering ontvangt."
  example:
  - "The following code example shows how to unload an application domain.  \n  \n [!code-cpp[ADUnload#1](~/add/codesnippet/cpp/m-system.appdomain.unloa_1.cpp)]\n [!code-vb[ADUnload#1](~/add/codesnippet/visualbasic/m-system.appdomain.unloa_1.vb)]\n [!code-cs[ADUnload#1](~/add/codesnippet/csharp/m-system.appdomain.unloa_1.cs)]"
  syntax:
    content: public static void Unload (AppDomain domain);
    parameters:
    - id: domain
      type: System.AppDomain
      description: "Een toepassingsdomein verwijderen (Unload)."
  overload: System.AppDomain.Unload*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domain</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.CannotUnloadAppDomainException
    commentId: T:System.CannotUnloadAppDomainException
    description: "<code>domain</code>kan niet worden verwijderd."
  - type: System.Exception
    commentId: T:System.Exception
    description: "Er is een fout opgetreden tijdens het verwijderen van ppdomain."
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.AppDomainUnloadedException
  parent: System
  isExternal: false
  name: AppDomainUnloadedException
  nameWithType: AppDomainUnloadedException
  fullName: System.AppDomainUnloadedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.MissingMethodException
  isExternal: true
  name: System.MissingMethodException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.BadImageFormatException
  isExternal: true
  name: System.BadImageFormatException
- uid: System.IO.FileLoadException
  isExternal: true
  name: System.IO.FileLoadException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MethodAccessException
  isExternal: true
  name: System.MethodAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.CannotUnloadAppDomainException
  parent: System
  isExternal: false
  name: CannotUnloadAppDomainException
  nameWithType: CannotUnloadAppDomainException
  fullName: System.CannotUnloadAppDomainException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.AppDomain.ActivationContext
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomain.AppendPrivatePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomain.ApplicationIdentity
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
- uid: System.ApplicationIdentity
  parent: System
  isExternal: false
  name: ApplicationIdentity
  nameWithType: ApplicationIdentity
  fullName: System.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
- uid: System.AppDomain.AssemblyLoad
  parent: System.AppDomain
  isExternal: false
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
- uid: System.AssemblyLoadEventHandler
  parent: System
  isExternal: false
  name: AssemblyLoadEventHandler
  nameWithType: AssemblyLoadEventHandler
  fullName: System.AssemblyLoadEventHandler
- uid: System.AppDomain.AssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
- uid: System.ResolveEventHandler
  parent: System
  isExternal: false
  name: ResolveEventHandler
  nameWithType: ResolveEventHandler
  fullName: System.ResolveEventHandler
- uid: System.AppDomain.BaseDirectory
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
- uid: System.AppDomain.ClearShadowCopyPath
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
- uid: System.Runtime.Remoting.ObjectHandle
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjectHandle
  nameWithType: ObjectHandle
  fullName: System.Runtime.Remoting.ObjectHandle
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Configuration.Assemblies.AssemblyHashAlgorithm
  parent: System.Configuration.Assemblies
  isExternal: false
  name: AssemblyHashAlgorithm
  nameWithType: AssemblyHashAlgorithm
  fullName: System.Configuration.Assemblies.AssemblyHashAlgorithm
- uid: System.AppDomain.CreateDomain(System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
- uid: System.AppDomainSetup
  parent: System
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.StrongName[]
  parent: System.Security.Policy
  isExternal: false
  name: StrongName
  nameWithType: StrongName
  fullName: System.Security.Policy.StrongName[]
  spec.csharp:
  - uid: System.Security.Policy.StrongName
    name: StrongName
    nameWithType: StrongName
    fullName: StrongName[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CurrentDomain
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
- uid: System.Reflection.Emit.AssemblyBuilder
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilder
  nameWithType: AssemblyBuilder
  fullName: System.Reflection.Emit.AssemblyBuilder
- uid: System.Reflection.AssemblyName
  parent: System.Reflection
  isExternal: true
  name: AssemblyName
  nameWithType: AssemblyName
  fullName: System.Reflection.AssemblyName
- uid: System.Reflection.Emit.AssemblyBuilderAccess
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilderAccess
  nameWithType: AssemblyBuilderAccess
  fullName: System.Reflection.Emit.AssemblyBuilderAccess
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
- uid: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<CustomAttributeBuilder>
  nameWithType: IEnumerable<CustomAttributeBuilder>
  fullName: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Reflection.Emit.CustomAttributeBuilder
    name: CustomAttributeBuilder
    nameWithType: CustomAttributeBuilder
    fullName: CustomAttributeBuilder
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
- uid: System.Security.SecurityContextSource
  parent: System.Security
  isExternal: false
  name: SecurityContextSource
  nameWithType: SecurityContextSource
  fullName: System.Security.SecurityContextSource
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
- uid: System.CrossAppDomainDelegate
  parent: System
  isExternal: false
  name: CrossAppDomainDelegate
  nameWithType: CrossAppDomainDelegate
  fullName: System.CrossAppDomainDelegate
- uid: System.AppDomain.DomainManager
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
- uid: System.AppDomainManager
  parent: System
  isExternal: false
  name: AppDomainManager
  nameWithType: AppDomainManager
  fullName: System.AppDomainManager
- uid: System.AppDomain.DomainUnload
  parent: System.AppDomain
  isExternal: false
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.AppDomain.DynamicDirectory
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
- uid: System.AppDomain.FirstChanceException
  parent: System.AppDomain
  isExternal: false
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
- uid: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<FirstChanceExceptionEventArgs>
  nameWithType: EventHandler<FirstChanceExceptionEventArgs>
  fullName: System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs
    name: FirstChanceExceptionEventArgs
    nameWithType: FirstChanceExceptionEventArgs
    fullName: FirstChanceExceptionEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.FriendlyName
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
- uid: System.Reflection.Assembly[]
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly[]
  spec.csharp:
  - uid: System.Reflection.Assembly
    name: Assembly
    nameWithType: Assembly
    fullName: Assembly[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.GetCurrentThreadId
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
- uid: System.AppDomain.GetData(System.String)
  parent: System.AppDomain
  isExternal: false
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
- uid: System.AppDomain.GetType
  parent: System.AppDomain
  isExternal: false
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.AppDomain.Id
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.IsDefaultAppDomain
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
- uid: System.AppDomain.IsFinalizingForUnload
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
- uid: System.AppDomain.IsFullyTrusted
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
- uid: System.AppDomain.Load(System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
- uid: System.AppDomain.Load(System.String)
  parent: System.AppDomain
  isExternal: false
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
- uid: System.AppDomain.MonitoringIsEnabled
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.AppDomain.PermissionSet
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
- uid: System.AppDomain.ProcessExit
  parent: System.AppDomain
  isExternal: false
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
- uid: System.AppDomain.RelativeSearchPath
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
- uid: System.AppDomain.ResourceResolve
  parent: System.AppDomain
  isExternal: false
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.AppDomain.SetCachePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
- uid: System.AppDomain.SetData(System.String,System.Object)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.AppDomain.SetDynamicBase(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
- uid: System.Security.Principal.PrincipalPolicy
  parent: System.Security.Principal
  isExternal: false
  name: PrincipalPolicy
  nameWithType: PrincipalPolicy
  fullName: System.Security.Principal.PrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.AppDomain.SetupInformation
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.AppDomain.ToString
  parent: System.AppDomain
  isExternal: false
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
- uid: System.AppDomain.TypeResolve
  parent: System.AppDomain
  isExternal: false
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
- uid: System.AppDomain.UnhandledException
  parent: System.AppDomain
  isExternal: false
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
- uid: System.UnhandledExceptionEventHandler
  parent: System
  isExternal: false
  name: UnhandledExceptionEventHandler
  nameWithType: UnhandledExceptionEventHandler
  fullName: System.UnhandledExceptionEventHandler
- uid: System.AppDomain.Unload(System.AppDomain)
  parent: System.AppDomain
  isExternal: false
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
- uid: System.AppDomain.ActivationContext*
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
- uid: System.AppDomain.AppendPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath
  nameWithType: AppDomain.AppendPrivatePath
- uid: System.AppDomain.ApplicationIdentity*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy*
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy
  nameWithType: AppDomain.ApplyPolicy
- uid: System.AppDomain.BaseDirectory*
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath
  nameWithType: AppDomain.ClearPrivatePath
- uid: System.AppDomain.ClearShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath
  nameWithType: AppDomain.ClearShadowCopyPath
- uid: System.AppDomain.CreateComInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom
  nameWithType: AppDomain.CreateComInstanceFrom
- uid: System.AppDomain.CreateDomain*
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain
  nameWithType: AppDomain.CreateDomain
- uid: System.AppDomain.CreateInstance*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance
  nameWithType: AppDomain.CreateInstance
- uid: System.AppDomain.CreateInstanceAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap
  nameWithType: AppDomain.CreateInstanceAndUnwrap
- uid: System.AppDomain.CreateInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom
  nameWithType: AppDomain.CreateInstanceFrom
- uid: System.AppDomain.CreateInstanceFromAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap
- uid: System.AppDomain.CurrentDomain*
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly*
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly
  nameWithType: AppDomain.DefineDynamicAssembly
- uid: System.AppDomain.DoCallBack*
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack
  nameWithType: AppDomain.DoCallBack
- uid: System.AppDomain.DomainManager*
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
- uid: System.AppDomain.DynamicDirectory*
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence*
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly
  nameWithType: AppDomain.ExecuteAssembly
- uid: System.AppDomain.ExecuteAssemblyByName*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName
  nameWithType: AppDomain.ExecuteAssemblyByName
- uid: System.AppDomain.FriendlyName*
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies
  nameWithType: AppDomain.GetAssemblies
- uid: System.AppDomain.GetCurrentThreadId*
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId
  nameWithType: AppDomain.GetCurrentThreadId
- uid: System.AppDomain.GetData*
  parent: System.AppDomain
  isExternal: false
  name: GetData
  nameWithType: AppDomain.GetData
- uid: System.AppDomain.GetType*
  parent: System.AppDomain
  isExternal: false
  name: GetType
  nameWithType: AppDomain.GetType
- uid: System.AppDomain.Id*
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService*
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService
  nameWithType: AppDomain.InitializeLifetimeService
- uid: System.AppDomain.IsCompatibilitySwitchSet*
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet
  nameWithType: AppDomain.IsCompatibilitySwitchSet
- uid: System.AppDomain.IsDefaultAppDomain*
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain
  nameWithType: AppDomain.IsDefaultAppDomain
- uid: System.AppDomain.IsFinalizingForUnload*
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload
  nameWithType: AppDomain.IsFinalizingForUnload
- uid: System.AppDomain.IsFullyTrusted*
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous*
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
- uid: System.AppDomain.Load*
  parent: System.AppDomain
  isExternal: false
  name: Load
  nameWithType: AppDomain.Load
- uid: System.AppDomain.MonitoringIsEnabled*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
- uid: System.AppDomain.PermissionSet*
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
- uid: System.AppDomain.ReflectionOnlyGetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies
- uid: System.AppDomain.RelativeSearchPath*
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
- uid: System.AppDomain.SetAppDomainPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy
  nameWithType: AppDomain.SetAppDomainPolicy
- uid: System.AppDomain.SetCachePath*
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath
  nameWithType: AppDomain.SetCachePath
- uid: System.AppDomain.SetData*
  parent: System.AppDomain
  isExternal: false
  name: SetData
  nameWithType: AppDomain.SetData
- uid: System.AppDomain.SetDynamicBase*
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase
  nameWithType: AppDomain.SetDynamicBase
- uid: System.AppDomain.SetPrincipalPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy
  nameWithType: AppDomain.SetPrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles
  nameWithType: AppDomain.SetShadowCopyFiles
- uid: System.AppDomain.SetShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath
  nameWithType: AppDomain.SetShadowCopyPath
- uid: System.AppDomain.SetThreadPrincipal*
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal
  nameWithType: AppDomain.SetThreadPrincipal
- uid: System.AppDomain.SetupInformation*
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount
- uid: System.AppDomain.System#_AppDomain#Invoke*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke
  nameWithType: AppDomain.System._AppDomain.Invoke
- uid: System.AppDomain.ToString*
  parent: System.AppDomain
  isExternal: false
  name: ToString
  nameWithType: AppDomain.ToString
- uid: System.AppDomain.Unload*
  parent: System.AppDomain
  isExternal: false
  name: Unload
  nameWithType: AppDomain.Unload
