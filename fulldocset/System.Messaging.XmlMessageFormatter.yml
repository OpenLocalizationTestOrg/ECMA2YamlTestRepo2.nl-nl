### YamlMime:ManagedReference
items:
- uid: System.Messaging.XmlMessageFormatter
  id: XmlMessageFormatter
  children:
  - System.Messaging.XmlMessageFormatter.#ctor
  - System.Messaging.XmlMessageFormatter.#ctor(System.String[])
  - System.Messaging.XmlMessageFormatter.#ctor(System.Type[])
  - System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)
  - System.Messaging.XmlMessageFormatter.Clone
  - System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)
  - System.Messaging.XmlMessageFormatter.TargetTypeNames
  - System.Messaging.XmlMessageFormatter.TargetTypes
  - System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)
  langs:
  - csharp
  name: XmlMessageFormatter
  nameWithType: XmlMessageFormatter
  fullName: System.Messaging.XmlMessageFormatter
  type: Class
  summary: "Serialiseert en deserializes objecten naar of van de hoofdtekst van een bericht met behulp van de XML-indeling op basis van de definitie van XSD-schema."
  remarks: "De XmlMessageFormatter is de indelingsfunctie standaard die een exemplaar van <xref:System.Messaging.MessageQueue>gebruikt voor serialisatie van berichten die naar de wachtrij worden geschreven.</xref:System.Messaging.MessageQueue> Wanneer u een exemplaar van <xref:System.Messaging.MessageQueue>een exemplaar van XmlMessageFormatter voor u gemaakt en gekoppeld aan de <xref:System.Messaging.MessageQueue>.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue> maken U kunt geen andere indelingsfunctie opgeven door deze in uw code te maken en toe te wijzen aan de <xref:System.Messaging.MessageQueue.Formatter%2A>eigenschap van uw <xref:System.Messaging.MessageQueue>.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Formatter%2A>       Een wachtrij XmlMessageFormatter standaardexemplaar kan worden gebruikt om te schrijven naar de wachtrij, maar deze kan niet worden gebruikt om te lezen uit de wachtrij totdat u een instelt de <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>of <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>-eigenschap op de indelingsfunctie.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> U kunt ofwel een of beide van deze waarden instellen op het standaardexemplaar van de indelingsfunctie of u kunt maken van een nieuw exemplaar van de indelingsfunctie en stel de waarden automatisch door deze als argumenten worden doorgegeven in de juiste <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A>constructor.</xref:System.Messaging.XmlMessageFormatter.%23ctor%2A>       Bij het opgeven van <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>plaats <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type bestaan is ingeschakeld op het tijdstip van compilatie in plaats van lezen tijd, waardoor de mogelijkheid voor fout.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>elke vermelding moet volledig gekwalificeerd zijn, geven de assemblynaam vereist.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Verder, als u werkt met meerdere gelijktijdige versies, het versienummer moet ook worden toegevoegd aan de typenaam doel.       De <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>en <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>Eigenschappen de indelingsfunctie zien welke schema&quot;s om te proberen als overeenkomst als bij het deserialiseren van een bericht.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Hierdoor is de indelingsfunctie interpreteren van de berichttekst.       Het exemplaar geserialiseerd in de hoofdtekst van het bericht moet voldoen aan een van de schema&quot;s weergegeven in het type matrix. Wanneer u het bericht met de <xref:System.Messaging.MessageQueue.Receive%2A>methode, de methode maakt u een object van het type dat overeenkomt met het schema dat wordt geïdentificeerd en leest de berichttekst in deze</xref:System.Messaging.MessageQueue.Receive%2A> lezen       Slechts één van de twee eigenschappen moet worden ingesteld bij het lezen van de wachtrij, maar u kunt beide instellen. De set van typen is de gecombineerde set van de twee eigenschappen. De beslissing over welke eigenschap te gebruiken is specifiek voor uw toepassing. Als de berichttekst een type waarvan het schema komt niet overeen met een van de typen in de matrix voor de eigenschap bevat, wordt een uitzondering opgetreden bij het bericht is gelezen.       De XmlMessageFormatter is een belangrijk onderdeel van losse XML gebaseerde uitwisseling van berichten. Het hulpprogramma XSD.exe gebruikt die de XML-indeling wordt gebruikt voor het genereren van XML-schema, zoals wanneer u het hulpprogramma gebruiken voor het serialiseren van een klasse die wordt gebruikt door de toepassing. De klasse moet een standaardconstructor hebben.       De indeling gebruikt opnieuw in de omgekeerde proces wanneer het hulpprogramma een klasse die is gebaseerd op schema genereert u distribueren om te beschrijven van uw klassegegevens. Het gebruik van het hulpprogramma en het XML-schema dat worden gegenereerd, kunt u om te voorkomen dat bestanden redistributing.dll telkens wanneer u een klasse compileren nadat de implementatie van de klasse is gewijzigd. Als het schema niet worden gewijzigd op de client of de server, andere wijzigingen aan beide zijden hebben geen invloed op de andere."
  example:
  - "The following code example includes three pieces of code: a server component, an order class, and client code. The order class can be used by the XSD.exe utility to generate schema that the server recognizes within incoming messages. The schema is an XML formatted file that describes the \"shape\" of the class. This schema can then be used on the client side to generate a client-specific order class that shares the same schema as the server class.  \n  \n The following code example represents a server component that receives orders through a message queue. The body of the message should be an order object whose schema matches the Order.cs class below. The server process or application deserializes the order.  \n  \n [!code-vb[Classic XmlMessageFormatter Example#1](~/add/codesnippet/visualbasic/t-system.messaging.xmlme_1.vb)]\n [!code-cpp[Classic XmlMessageFormatter Example#1](~/add/codesnippet/cpp/t-system.messaging.xmlme_1.cpp)]\n [!code-cs[Classic XmlMessageFormatter Example#1](~/add/codesnippet/csharp/t-system.messaging.xmlme_1.cs)]  \n  \n The following code example represents the order class that provides a schema for the order objects that the application on the server receives and deserializes.  \n  \n [!code-vb[Classic XmlMessageFormatter Example#2](~/add/codesnippet/visualbasic/t-system.messaging.xmlme_2.vb)]\n [!code-cs[Classic XmlMessageFormatter Example#2](~/add/codesnippet/csharp/t-system.messaging.xmlme_2.cs)]\n [!code-cpp[Classic XmlMessageFormatter Example#2](~/add/codesnippet/cpp/t-system.messaging.xmlme_2.cpp)]  \n  \n Any client application that interacts with the application on the server must send messages to the server by serializing information in a locally defined order class into the message body. The locally defined order class must have the same schema as the server-defined order class into which the application on the server will attempt to deserialize the message body. The XSD.exe utility lets the manager of the application on the server create and distribute the schema the client must use to serialize messages going to the server.  \n  \n When the manager of the client application receives the schema for the order class, the XSD.exe utility is used again to generate a client-specific order class from the schema. It is this class that is used in the client code example below, not the server's order class (the XSD.exe utility causes the schema-generated class to have the same name as the original class). This new order class is used to serialize the order into the message body.  \n  \n The following code example is the client-side processing, used to serialize an order and send the information associated with the order to a queue. The code associates Item, Quantity, and Address information with elements of the schema that were generated for the Order.cs class by the XSD.exe utility. An order is sent to the Orders queue on the local computer.  \n  \n [!code-vb[Classic XmlMessageFormatter Example#3](~/add/codesnippet/visualbasic/t-system.messaging.xmlme_3.vb)]\n [!code-cpp[Classic XmlMessageFormatter Example#3](~/add/codesnippet/cpp/t-system.messaging.xmlme_3.cpp)]\n [!code-cs[Classic XmlMessageFormatter Example#3](~/add/codesnippet/csharp/t-system.messaging.xmlme_3.cs)]  \n  \n After the schema is generated from the order class on the server, you can modify the class. Unless the schema changes, you do not need to redistribute the schema. After you have distributed the schema and generated a client-side order class, that client class can also be modified independently of the server's order class, as long as the schema itself is not modified. The two classes have become loosely coupled."
  syntax:
    content: 'public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter'
  inheritance:
  - System.Object
  implements:
  - System.ICloneable
  - System.Messaging.IMessageFormatter
  inheritedMembers: []
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.#ctor
  id: '#ctor'
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: XmlMessageFormatter()
  nameWithType: XmlMessageFormatter.XmlMessageFormatter()
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter()
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> klasse, zonder het doel van het type ingesteld."
  remarks: "Deze overbelasting van de constructor wordt meestal gebruikt bij het schrijven naar de wachtrij als doeltypen niet vereist zijn bij het schrijven.       Lezen van een bericht van een wachtrij met een exemplaar van <xref:System.Messaging.XmlMessageFormatter>gemaakt met deze constructor, stelt u de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>of <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>eigenschappen zodat de indelingsfunctie welke typen weet geprobeerd te deserialiseren.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> </xref:System.Messaging.XmlMessageFormatter>       Wanneer u een nieuwe maakt <xref:System.Messaging.MessageQueue>, een standaard <xref:System.Messaging.XmlMessageFormatter>instantie is gemaakt, zonder dat de doel-typen is ingesteld.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.MessageQueue> Net als bij een formatter gemaakt met behulp van deze constructor, moet u doeltypen voor dat exemplaar formatter instellen als u wilt lezen uit de wachtrij."
  syntax:
    content: public XmlMessageFormatter ();
    parameters: []
  overload: System.Messaging.XmlMessageFormatter.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.#ctor(System.String[])
  id: '#ctor(System.String[])'
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: XmlMessageFormatter(String[])
  nameWithType: XmlMessageFormatter.XmlMessageFormatter(String[])
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(String[])
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> klasse, doeltypen doorgegeven als een matrix van tekenreekswaarden (FQDN) instellen."
  remarks: "De constructors met typeparameters doel het meest worden gebruikt bij het lezen van de wachtrij. Wanneer u schrijft, is het niet nodig om op te geven doeltypen.       Deze overbelasting van de <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A>constructor stelt de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>eigenschap aan de matrixwaarden doorgegeven via de `targetTypeNames` parameter.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> </xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Deze eigenschap kunt u de instelling een <xref:System.Messaging.MessageQueue>gebruik van deze <xref:System.Messaging.XmlMessageFormatter>exemplaar voor het lezen van berichten met objecten van het opgegeven typen.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.MessageQueue>       Zowel de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>en <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>Eigenschappen de indelingsfunctie zien welke schema&quot;s om te proberen als overeenkomst als bij het deserialiseren van een bericht.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Hierdoor is de indelingsfunctie interpreteren van de berichttekst.       Het exemplaar geserialiseerd in de hoofdtekst van het bericht moet voldoen aan een van de schema&quot;s weergegeven in het type matrix. Wanneer u het bericht met de <xref:System.Messaging.MessageQueue.Receive%2A>methode, de methode maakt u een object van het type dat overeenkomt met het schema dat wordt geïdentificeerd en leest de berichttekst in deze</xref:System.Messaging.MessageQueue.Receive%2A> lezen       Slechts één van de twee eigenschappen moet worden ingesteld bij het lezen van de wachtrij, maar u kunt beide instellen. De set van typen is de gecombineerde set van de twee eigenschappen. De beslissing over welke een om te gebruiken is specifiek voor uw toepassing. Als de berichttekst een type waarvan het schema komt niet overeen met een van de typen in de matrix voor de eigenschap bevat, wordt een uitzondering opgetreden tijdens het lezen."
  example:
  - >-
    [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/m-system.messaging.xmlme_1.cpp)]
     [!code-cs[Message.Body#1](~/add/codesnippet/csharp/m-system.messaging.xmlme_1.cs)]
     [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/m-system.messaging.xmlme_1.vb)]
  syntax:
    content: public XmlMessageFormatter (string[] targetTypeNames);
    parameters:
    - id: targetTypeNames
      type: System.String[]
      description: "Een matrix van het type <xref:System.String>waarmee de reeks mogelijke typen aangegeven die zullen worden gedeserialiseerd door de indelingsfunctie vanuit het geleverde bericht.</xref:System.String> Deze waarden moet volledig gekwalificeerd zijn, bijvoorbeeld &quot;MyNamespace.MyOrders, MyOrdersAssemblyName&quot;."
  overload: System.Messaging.XmlMessageFormatter.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>targetTypeNames</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.#ctor(System.Type[])
  id: '#ctor(System.Type[])'
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: XmlMessageFormatter(Type[])
  nameWithType: XmlMessageFormatter.XmlMessageFormatter(Type[])
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(Type[])
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> klasse, doeltypen doorgegeven als een matrix van objecttypen die instelling."
  remarks: "De constructors met typeparameters doel het meest worden gebruikt bij het lezen van de wachtrij. Wanneer u schrijft, is het niet nodig om op te geven doeltypen.       Deze overbelasting van de <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A>constructor stelt de <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>eigenschap aan de matrixwaarden doorgegeven via de `targetTypes` parameter.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> Deze eigenschap kunt u de instelling een <xref:System.Messaging.MessageQueue>gebruik van deze <xref:System.Messaging.XmlMessageFormatter>exemplaar voor het lezen van berichten die objecten van de opgegeven typen bevatten.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.MessageQueue>       Zowel de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>en <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>Eigenschappen de indelingsfunctie zien welke schema&quot;s om te proberen als overeenkomst als bij het deserialiseren van een bericht.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Hierdoor is de indelingsfunctie interpreteren van de berichttekst.       Het exemplaar geserialiseerd in de hoofdtekst van het bericht moet voldoen aan een van de schema&quot;s weergegeven in het type matrix. Wanneer u het bericht met de <xref:System.Messaging.MessageQueue.Receive%2A>methode, de methode maakt u een object van het type dat overeenkomt met het schema dat wordt geïdentificeerd en leest de berichttekst in deze</xref:System.Messaging.MessageQueue.Receive%2A> lezen       Slechts één van de twee eigenschappen moet worden ingesteld bij het lezen van de wachtrij, maar u kunt beide instellen. De set van typen is de gecombineerde set van de twee eigenschappen. De beslissing over welke een om te gebruiken is specifiek voor uw toepassing. Als de berichttekst een type waarvan het schema komt niet overeen met een van de typen in de matrix voor de eigenschap bevat, wordt een uitzondering opgetreden tijdens het lezen.       Bij het opgeven van <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>plaats <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type bestaan is ingeschakeld op het tijdstip van compilatie in plaats van lezen tijd, waardoor de mogelijkheid voor fout.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>elke vermelding moet volledig gekwalificeerd zijn, geven de assemblynaam vereist.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Verder, als u werkt met meerdere gelijktijdige versies, het versienummer moet ook worden toegevoegd aan de typenaam doel.       Wanneer u <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, kunt u elk object toevoegen (bijvoorbeeld `MyClass`) aan de lijst op een manier die door de volgende C#-code wordt gedemonstreerd.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>      ```   TargetTypes = new Type[]{typeof(MyClass)}   ```"
  syntax:
    content: public XmlMessageFormatter (Type[] targetTypes);
    parameters:
    - id: targetTypes
      type: System.Type[]
      description: "Een matrix van het type <xref:System.Type>waarmee de reeks mogelijke typen aangegeven die zullen worden gedeserialiseerd door de indelingsfunctie vanuit het geleverde bericht.</xref:System.Type>"
  overload: System.Messaging.XmlMessageFormatter.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>targetTypes</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)
  id: CanRead(System.Messaging.Message)
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: CanRead(Message)
  nameWithType: XmlMessageFormatter.CanRead(Message)
  fullName: System.Messaging.XmlMessageFormatter.CanRead(Message)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Hiermee wordt bepaald of de indelingsfunctie kan worden gebruikt voor het deserialiseren van het bericht."
  remarks: "Als CanRead wordt aangeroepen, wordt de indelingsfunctie probeert te bepalen of de inhoud van het bericht zijn iets die kan worden gedeserialiseerd. De formatter kan alleen het bericht deserialiseren als het type van het bericht hetzelfde schema als een van de typen in de matrix die wordt vertegenwoordigd heeft door de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>en <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>Eigenschappen.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> CanRead retourneert `false` in de volgende twee omstandigheden:-het bericht is niet geformatteerd met behulp van de <xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter>      -Het schema van de berichttekst behoort niet tot de genoemde in ofwel de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>of <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>eigenschap.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>       De <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>en <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>Eigenschappen de indelingsfunctie te zien welke soorten objecten moet het mogelijk om toegang te deserialiseren.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Als een ander type in de lijst ontbreekt nog in het bericht is gevonden, CanRead retourneert `false`."
  syntax:
    content: public bool CanRead (System.Messaging.Message message);
    parameters:
    - id: message
      type: System.Messaging.Message
      description: "De <xref href=&quot;System.Messaging.Message&quot;> </xref> om te controleren."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de formatter XML van het bericht deserialiseren kan. anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.XmlMessageFormatter.CanRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Noch de <> </> *> noch <> </> *> eigenschap is ingesteld."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>message</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.Clone
  id: Clone
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: Clone()
  nameWithType: XmlMessageFormatter.Clone()
  fullName: System.Messaging.XmlMessageFormatter.Clone()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Maakt een exemplaar van de <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> klasse waarvan lezen/schrijven eigenschappen (de sets doeltypen) zijn hetzelfde als de huidige <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> exemplaar."
  remarks: "Deze methode maakt een kopie van de indelingsfunctie en initialiseert de eigenschappen aan de waarden van deze <xref:System.Messaging.XmlMessageFormatter>object.</xref:System.Messaging.XmlMessageFormatter>"
  syntax:
    content: public object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Een object waarvan de eigenschappen identiek aan die van dit zijn <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> exemplaar, maar waarvan metagegevens geeft geen dat het een formatter klasse-instantie."
  overload: System.Messaging.XmlMessageFormatter.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)
  id: Read(System.Messaging.Message)
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: Read(Message)
  nameWithType: XmlMessageFormatter.Read(Message)
  fullName: System.Messaging.XmlMessageFormatter.Read(Message)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "De inhoud van het opgegeven bericht leest en maakt een object dat het gedeserialiseerde bericht bevat."
  remarks: "Zowel de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>en <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>Eigenschappen de indelingsfunctie zien welke schema&quot;s om te proberen als overeenkomst als bij het deserialiseren van een bericht.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Een van deze eigenschappen moet worden ingesteld voordat het bericht kan worden gedeserialiseerd.       Het exemplaar geserialiseerd in de hoofdtekst van het bericht moet voldoen aan een van de schema&quot;s weergegeven in het type matrix. Wanneer u het bericht met de <xref:System.Messaging.MessageQueue.Receive%2A>methode, de methode maakt u een object van het type dat overeenkomt met het schema dat wordt geïdentificeerd en leest de berichttekst in deze</xref:System.Messaging.MessageQueue.Receive%2A> lezen       De doeltypen hoeft niet te worden opgegeven om te schrijven naar de wachtrij."
  syntax:
    content: public object Read (System.Messaging.Message message);
    parameters:
    - id: message
      type: System.Messaging.Message
      description: "De <xref href=&quot;System.Messaging.Message&quot;> </xref>, in XML-indeling te deserialiseren."
    return:
      type: System.Object
      description: "Het bericht gedeserialiseerd."
  overload: System.Messaging.XmlMessageFormatter.Read*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Noch de <> </> *> noch <> </> *> eigenschap is ingesteld.       - of - het exemplaar geserialiseerd in de berichttekst voldoet niet aan een van de schema&quot;s dat wordt vertegenwoordigd door de typen in de <> </> *> en <> </> *> eigenschappen."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>message</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.TargetTypeNames
  id: TargetTypeNames
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: TargetTypeNames
  nameWithType: XmlMessageFormatter.TargetTypeNames
  fullName: System.Messaging.XmlMessageFormatter.TargetTypeNames
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Hiermee geeft u de reeks mogelijke typen aangegeven die zullen worden gedeserialiseerd door de indelingsfunctie vanuit het geleverde bericht."
  remarks: "Zowel de TargetTypeNames en <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>Eigenschappen de indelingsfunctie zien welke schema&quot;s om te proberen als overeenkomst als bij het deserialiseren van een bericht.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> Hierdoor is de indelingsfunctie interpreteren van de berichttekst.       Het exemplaar geserialiseerd in de hoofdtekst van het bericht moet voldoen aan een van de schema&quot;s weergegeven in het type matrix. Wanneer u het bericht met de <xref:System.Messaging.MessageQueue.Receive%2A>methode, de methode maakt u een object van het type dat overeenkomt met het schema dat wordt geïdentificeerd en leest de berichttekst in deze</xref:System.Messaging.MessageQueue.Receive%2A> lezen       Slechts één van de twee eigenschappen moet worden ingesteld bij het lezen van de wachtrij, maar u kunt beide instellen. De set van typen is de gecombineerde set van de twee eigenschappen. De beslissing over welke eigenschap te gebruiken is specifiek voor uw toepassing. Als de berichttekst een type waarvan het schema komt niet overeen met een van de typen in de matrix voor de eigenschap bevat, wordt een uitzondering opgetreden bij het bericht is gelezen.       TargetTypeNames moet elke ingang volledig gekwalificeerd zijn, worden de assemblynaam opgeven. Verder, als u werkt met meerdere gelijktijdige versies, het versienummer moet ook worden toegevoegd aan de typenaam doel.       De doeltypen zijn alleen vereist bij het lezen van de wachtrij. De TargetTypeNames en <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>Eigenschappen hoeft niet te worden ingesteld om te schrijven naar de wachtrij.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>"
  syntax:
    content: public string[] TargetTypeNames { get; set; }
    return:
      type: System.String[]
      description: "Een matrix van het type <xref:System.String>die de typen objecten te deserialiseren van de berichttekst bij het lezen van het bericht aangeeft.</xref:System.String>"
  overload: System.Messaging.XmlMessageFormatter.TargetTypeNames*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "De eigenschap TargetTypeNames is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.TargetTypes
  id: TargetTypes
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: TargetTypes
  nameWithType: XmlMessageFormatter.TargetTypes
  fullName: System.Messaging.XmlMessageFormatter.TargetTypes
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Hiermee geeft u de reeks mogelijke typen aangegeven die zullen worden gedeserialiseerd door de indelingsfunctie vanuit het geleverde bericht."
  remarks: "Zowel de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>TargetTypes eigenschappen laat de indelingsfunctie welke schema&quot;s om te proberen als overeenkomst als bij het deserialiseren van een bericht.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Hierdoor is de indelingsfunctie interpreteren van de berichttekst.       Het exemplaar geserialiseerd in de hoofdtekst van het bericht moet voldoen aan een van de schema&quot;s weergegeven in het type matrix. Wanneer u het bericht met de <xref:System.Messaging.MessageQueue.Receive%2A>methode, de methode maakt u een object van het type dat overeenkomt met het schema dat wordt geïdentificeerd en leest de berichttekst in deze</xref:System.Messaging.MessageQueue.Receive%2A> lezen       Slechts één van de twee eigenschappen moet worden ingesteld bij het lezen van de wachtrij, maar u kunt beide instellen. De set van typen is de gecombineerde set van de twee eigenschappen. De beslissing over welke eigenschap te gebruiken is specifiek voor uw toepassing. Als de berichttekst een type waarvan het schema komt niet overeen met een van de typen in de matrix voor de eigenschap bevat, wordt een uitzondering opgetreden bij het bericht is gelezen.       De doeltypen zijn alleen vereist bij het lezen van de wachtrij. De <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>en TargetTypes eigenschappen hoeven niet te worden ingesteld om te schrijven naar de wachtrij.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>       Opgeven wanneer TargetTypes plaats <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, type bestaan is ingeschakeld op het tijdstip van compilatie in plaats van lezen tijd, waardoor de mogelijkheid voor fout.</xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>       Wanneer u TargetTypes gebruikt, kunt u elk object toevoegen (bijvoorbeeld `MyClass`) aan de lijst op een manier die door de C#-code gedemonstreerd `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`."
  example:
  - "The following code example sends and receives a message that contains an order to and from a queue.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/p-system.messaging.xmlme_1.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/p-system.messaging.xmlme_1.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/p-system.messaging.xmlme_1.vb)]"
  syntax:
    content: public Type[] TargetTypes { get; set; }
    return:
      type: System.Type[]
      description: "Een matrix van het type <xref:System.Type>die de typen objecten te deserialiseren van de berichttekst bij het lezen van het bericht aangeeft.</xref:System.Type>"
  overload: System.Messaging.XmlMessageFormatter.TargetTypes*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "De eigenschap TargetTypes is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)
  id: Write(System.Messaging.Message,System.Object)
  parent: System.Messaging.XmlMessageFormatter
  langs:
  - csharp
  name: Write(Message,Object)
  nameWithType: XmlMessageFormatter.Write(Message,Object)
  fullName: System.Messaging.XmlMessageFormatter.Write(Message,Object)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Een object serialiseert in de hoofdtekst van het bericht."
  remarks: "De doeltypen moeten niet worden opgegeven om te schrijven naar de wachtrij als ze moet bij het lezen. De <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>of <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>eigenschap wordt gebruikt door de formatter alleen wanneer het deserialiseren van een bericht.</xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> </xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>       De <xref:System.Messaging.XmlMessageFormatter>maakt gebruik van de <xref:System.Xml.Serialization.XmlSerializer>klasse, die definieert wat kan worden geserialiseerd.</xref:System.Xml.Serialization.XmlSerializer> </xref:System.Messaging.XmlMessageFormatter> Alleen worden openbare velden en eigenschappen public geserialiseerd. Structuren, structuren met arrays en matrices van structuren zijn alle serialiseerbaar omdat ze niet van de gecodeerde stijl met het SOAP-protocol gebruikmaken."
  syntax:
    content: public void Write (System.Messaging.Message message, object obj);
    parameters:
    - id: message
      type: System.Messaging.Message
      description: "De <xref href=&quot;System.Messaging.Message&quot;> </xref> waarvan <xref:System.Messaging.Message.Body*>eigenschap wordt geserialiseerd object bevatten.</xref:System.Messaging.Message.Body*>"
    - id: obj
      type: System.Object
      description: "De <xref:System.Object>wordt geserialiseerd in de berichttekst.</xref:System.Object>"
  overload: System.Messaging.XmlMessageFormatter.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>message</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       The <code>obj</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Messaging.XmlMessageFormatter.#ctor
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: XmlMessageFormatter()
  nameWithType: XmlMessageFormatter.XmlMessageFormatter()
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter()
- uid: System.Messaging.XmlMessageFormatter.#ctor(System.String[])
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: XmlMessageFormatter(String[])
  nameWithType: XmlMessageFormatter.XmlMessageFormatter(String[])
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(String[])
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Messaging.XmlMessageFormatter.#ctor(System.Type[])
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: XmlMessageFormatter(Type[])
  nameWithType: XmlMessageFormatter.XmlMessageFormatter(Type[])
  fullName: System.Messaging.XmlMessageFormatter.XmlMessageFormatter(Type[])
- uid: System.Type[]
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type[]
  spec.csharp:
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: Type[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: CanRead(Message)
  nameWithType: XmlMessageFormatter.CanRead(Message)
  fullName: System.Messaging.XmlMessageFormatter.CanRead(Message)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Messaging.Message
  parent: System.Messaging
  isExternal: false
  name: Message
  nameWithType: Message
  fullName: System.Messaging.Message
- uid: System.Messaging.XmlMessageFormatter.Clone
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Clone()
  nameWithType: XmlMessageFormatter.Clone()
  fullName: System.Messaging.XmlMessageFormatter.Clone()
- uid: System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Read(Message)
  nameWithType: XmlMessageFormatter.Read(Message)
  fullName: System.Messaging.XmlMessageFormatter.Read(Message)
- uid: System.Messaging.XmlMessageFormatter.TargetTypeNames
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: TargetTypeNames
  nameWithType: XmlMessageFormatter.TargetTypeNames
  fullName: System.Messaging.XmlMessageFormatter.TargetTypeNames
- uid: System.Messaging.XmlMessageFormatter.TargetTypes
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: TargetTypes
  nameWithType: XmlMessageFormatter.TargetTypes
  fullName: System.Messaging.XmlMessageFormatter.TargetTypes
- uid: System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Write(Message,Object)
  nameWithType: XmlMessageFormatter.Write(Message,Object)
  fullName: System.Messaging.XmlMessageFormatter.Write(Message,Object)
- uid: System.Messaging.XmlMessageFormatter.#ctor*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: XmlMessageFormatter
  nameWithType: XmlMessageFormatter.XmlMessageFormatter
- uid: System.Messaging.XmlMessageFormatter.CanRead*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: CanRead
  nameWithType: XmlMessageFormatter.CanRead
- uid: System.Messaging.XmlMessageFormatter.Clone*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Clone
  nameWithType: XmlMessageFormatter.Clone
- uid: System.Messaging.XmlMessageFormatter.Read*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Read
  nameWithType: XmlMessageFormatter.Read
- uid: System.Messaging.XmlMessageFormatter.TargetTypeNames*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: TargetTypeNames
  nameWithType: XmlMessageFormatter.TargetTypeNames
- uid: System.Messaging.XmlMessageFormatter.TargetTypes*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: TargetTypes
  nameWithType: XmlMessageFormatter.TargetTypes
- uid: System.Messaging.XmlMessageFormatter.Write*
  parent: System.Messaging.XmlMessageFormatter
  isExternal: false
  name: Write
  nameWithType: XmlMessageFormatter.Write
