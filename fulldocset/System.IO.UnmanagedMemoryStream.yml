### YamlMime:ManagedReference
items:
- uid: System.IO.UnmanagedMemoryStream
  id: UnmanagedMemoryStream
  children:
  - System.IO.UnmanagedMemoryStream.#ctor
  - System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.CanRead
  - System.IO.UnmanagedMemoryStream.CanSeek
  - System.IO.UnmanagedMemoryStream.CanWrite
  - System.IO.UnmanagedMemoryStream.Capacity
  - System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  - System.IO.UnmanagedMemoryStream.Flush
  - System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.Length
  - System.IO.UnmanagedMemoryStream.Position
  - System.IO.UnmanagedMemoryStream.PositionPointer
  - System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.ReadByte
  - System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  - System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: UnmanagedMemoryStream
  nameWithType: UnmanagedMemoryStream
  fullName: System.IO.UnmanagedMemoryStream
  type: Class
  summary: "Biedt toegang tot niet-beheerde blokken van het geheugen van beheerde code."
  remarks: "Deze klasse biedt ondersteuning voor toegang tot het onbeheerde geheugen met behulp van het bestaande model op basis van stroom en vereist niet dat de inhoud in het geheugen van niet-beheerde worden gekopieerd naar de heap.      > [!IMPORTANT] > Dit type implementeert de <xref:System.IDisposable>interface.</xref:System.IDisposable> Wanneer u klaar bent met het type, moet u beschikken over het direct of indirect. Aanroepen voor het rechtstreeks verwijderen van het type ervan <xref:System.IDisposable.Dispose%2A>methode in een `try` / `catch` blok.</xref:System.IDisposable.Dispose%2A> Gebruiken om de buitengebruikstelling van het indirect, een taal constructie zoals `using` (in C#) of `Using` (in Visual Basic). Zie voor meer informatie de sectie &quot;Met behulp van een Object dat wordt geïmplementeerd IDisposable&quot; in de <xref:System.IDisposable>interface onderwerp.</xref:System.IDisposable>"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the UnmanagedMemoryStream class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/t-system.io.unmanagedmem_1.cs)]"
  syntax:
    content: 'public class UnmanagedMemoryStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor
  id: '#ctor'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream()
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream()
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> klasse."
  syntax:
    content: protected UnmanagedMemoryStream ();
    parameters: []
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De gebruiker heeft niet de vereiste machtiging."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  id: '#ctor(System.Byte*,System.Int64)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(Byte*,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> klasse met behulp van de opgegeven lengte van de locatie en het geheugen."
  remarks: "Deze constructor maakt een nieuw exemplaar van de <xref:System.IO.UnmanagedMemoryStream>klasse, en stelt standaard de <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A>eigenschap `false` en de <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>eigenschap `true`.</xref:System.IO.UnmanagedMemoryStream.CanRead%2A> </xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> </xref:System.IO.UnmanagedMemoryStream> De <xref:System.IO.UnmanagedMemoryStream.Length%2A>eigenschap is ingesteld op de waarde van de `length` parameter en kan niet worden gewijzigd.</xref:System.IO.UnmanagedMemoryStream.Length%2A>"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_4_1.cs)]"
  syntax:
    content: public UnmanagedMemoryStream (byte* pointer, long length);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "Een verwijzing naar een niet-beheerde geheugenlocatie."
    - id: length
      type: System.Int64
      description: "De lengte van het geheugen te gebruiken."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De gebruiker heeft niet de vereiste machtiging."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> is large enough to cause an overflow."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  id: '#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> klasse in een veilige buffer met een opgegeven offset en lengte."
  syntax:
    content: public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "De buffer voor de onbegeleide geheugenstroom bevatten."
    - id: offset
      type: System.Int64
      description: "De bytepositie in de buffer waarmee de onbegeleide geheugenstroom starten."
    - id: length
      type: System.Int64
      description: "De lengte van de onbegeleide geheugenstroom."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  id: '#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> klasse met behulp van de opgegeven locatie, de lengte van geheugen, de totale hoeveelheid geheugen en waarden voor toegang tot het bestand."
  remarks: "De `length` parameter definieert u de huidige hoeveelheid geheugen in gebruik. Als het lezen van of toevoegen van gegevens naar de stroom, de `length` waarde moet gelijk zijn aan het bedrag van geldige gegevens in de stroom moet worden gelezen uit of behouden blijven. Als u schrijft naar de stroom, moet deze waarde nul zijn.       De `capacity` parameter geeft de hoeveelheid Totaal geheugen beschikbaar. Deze waarde kan een regio die langer is dan de opgegeven lengte beschrijven of duiden op een regio die kan worden toegevoegd aan. Elke poging om te schrijven dan deze waarde zal mislukken.       De `access` parametersets de <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>, en <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A>Eigenschappen.</xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> </xref:System.IO.UnmanagedMemoryStream.CanRead%2A> Houd er rekening mee dat geven <xref:System.IO.FileAccess>kan niet garanderen dat de stroom beschrijfbare worden.</xref:System.IO.FileAccess> De toegangsparameters kan de uitvoerder implementatie een object waarvan de implementatie kan overeenkomen met de werkelijke stroom die wordt blootgelegd te maken."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/62930bcb-5dff-4d38-8341-_1.cs)]"
  syntax:
    content: public UnmanagedMemoryStream (byte* pointer, long length, long capacity, System.IO.FileAccess access);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "Een verwijzing naar een niet-beheerde geheugenlocatie."
    - id: length
      type: System.Int64
      description: "De lengte van het geheugen te gebruiken."
    - id: capacity
      type: System.Int64
      description: "De totale hoeveelheid geheugen die naar de stroom is toegewezen."
    - id: access
      type: System.IO.FileAccess
      description: "Een van de <xref href=&quot;System.IO.FileAccess&quot;> </xref> waarden."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De gebruiker heeft niet de vereiste machtiging."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>capacity</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> value is greater than the <code>capacity</code> value."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  id: '#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> -klasse in een veilige buffer met een opgegeven offset lengte, en bestanden openen."
  syntax:
    content: public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "De buffer voor de onbegeleide geheugenstroom bevatten."
    - id: offset
      type: System.Int64
      description: "De bytepositie in de buffer waarmee de onbegeleide geheugenstroom starten."
    - id: length
      type: System.Int64
      description: "De lengte van de onbegeleide geheugenstroom."
    - id: access
      type: System.IO.FileAccess
      description: "De modus van toegang tot de bestanden naar de geheugenstroom niet-beheerde."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanRead
  id: CanRead
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
  fullName: System.IO.UnmanagedMemoryStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee wordt een waarde die aangeeft of een stroom lezen ondersteunt."
  remarks: "Deze eigenschap geeft aan of de huidige stroom lezen ondersteunt."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the CanRead property before attempting to display the contents to the console.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_2_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Als het object is gemaakt door een constructor met een <code> access </code> parameter die niet lezen van de stroom en als de stroom gesloten, anders wordt is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.UnmanagedMemoryStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanSeek
  id: CanSeek
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
  fullName: System.IO.UnmanagedMemoryStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee wordt een waarde die aangeeft of een stroom zoekbewerkingen ondersteunt."
  remarks: "Deze eigenschap geeft aan of de huidige stroom zoekbewerkingen ondersteunt."
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Als de stroom is gesloten; anders <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.UnmanagedMemoryStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanWrite
  id: CanWrite
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
  fullName: System.IO.UnmanagedMemoryStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee wordt een waarde die aangeeft of een stroom schrijven ondersteunt."
  remarks: "Deze eigenschap geeft aan of de huidige stroom schrijven ondersteunt."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the CanWrite property before attempting to write the data to the stream.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Als het object is gemaakt door een constructor met een <code> access </code> parameterwaarde op die ondersteuning biedt voor schrijven of is gemaakt met een constructor die geen parameters heeft of als de stroom gesloten, anders wordt is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.UnmanagedMemoryStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Capacity
  id: Capacity
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
  fullName: System.IO.UnmanagedMemoryStream.Capacity
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee haalt u de stream-lengte (grootte) of de totale hoeveelheid geheugen die is toegewezen aan een stroom (capaciteit)."
  remarks: "Deze eigenschap geeft de `capacity` waarde die is opgegeven voor de constructor. Als er geen `capacity` waarde is opgegeven als de stroom is geïnitialiseerd, retourneert de stroomlengte van de van deze eigenschap."
  syntax:
    content: public long Capacity { get; }
    return:
      type: System.Int64
      description: "De grootte of de capaciteit van de stroom."
  overload: System.IO.UnmanagedMemoryStream.Capacity*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: UnmanagedMemoryStream.Dispose(Boolean)
  fullName: System.IO.UnmanagedMemoryStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Heft de niet-beheerde bronnen worden gebruikt door de <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> en eventueel de beheerde bronnen vrij."
  remarks: "Deze methode wordt aangeroepen door het publiek <xref:System.ComponentModel.Component.Dispose%2A>methode en de <xref:System.Object.Finalize%2A>methode.</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>de beveiligde methode Dispose met roept de `disposing` parameter ingesteld op `true`.</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>roept Dispose met `disposing` ingesteld op `false`.</xref:System.Object.Finalize%2A>       Wanneer de `disposing` parameter `true`, deze methode worden alle resources die beheerde objecten waarover vrijgegeven dat dit <xref:System.IO.UnmanagedMemoryStream>verwijzingen.</xref:System.IO.UnmanagedMemoryStream> Deze methode roept de <xref:System.ComponentModel.Component.Dispose%2A>methode van elk object waarnaar wordt verwezen.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>voor het vrijgeven van zowel beheerde als onbeheerde hulpbronnen; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om alleen niet-beheerde bronnen vrij te geven."
  overload: System.IO.UnmanagedMemoryStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Flush
  id: Flush
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Flush()
  nameWithType: UnmanagedMemoryStream.Flush()
  fullName: System.IO.UnmanagedMemoryStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Onderdrukt de <xref:System.IO.Stream.Flush*>methode zodat wordt geen actie uitgevoerd.</xref:System.IO.Stream.Flush*>"
  remarks: "Deze methode voert geen actie uit voor deze klasse, maar is opgenomen als onderdeel van de <xref:System.IO.Stream>basis-klasse.</xref:System.IO.Stream> Aangezien geen gegevens naar het RAM-geheugen wordt geschreven, is deze methode is overbodig."
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.UnmanagedMemoryStream.Flush*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: UnmanagedMemoryStream.FlushAsync(CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Onderdrukt de &lt;xref:System.IO.Stream.FlushAsync%2A?displayProperty=fullName&gt; methode zodat de bewerking is geannuleerd, indien opgegeven, maar geen andere actie wordt uitgevoerd.       Beschikbaar vanaf[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "Als de bewerking niet is geannuleerd, de <xref:System.IO.UnmanagedMemoryStream>aanroepen de <xref:System.IO.UnmanagedMemoryStream.Flush%2A>methode, wat betekent dat er geen acties uitvoeren.</xref:System.IO.UnmanagedMemoryStream.Flush%2A> </xref:System.IO.UnmanagedMemoryStream>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Het token voor annulering aanvragen bewaken. De standaardwaarde is <xref:System.Threading.CancellationToken.None*>.</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task
      description: "Een taak die staat voor de asynchrone bewerking leegmaken."
  overload: System.IO.UnmanagedMemoryStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  id: Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Initialize(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> klasse met behulp van een verwijzing naar een niet-beheerde geheugenlocatie."
  remarks: "Deze methode is gelijk aan de <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A>constructor.</xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> Biedt ondersteuning voor methoden die u moeten de aanwijzer initialiseren voordat u de variabelen voor de stroom en daarom kunnen de constructor met parameters niet aanroepen. Deze methoden moeten de standaardconstructor gebruiken <xref:System.IO.UnmanagedMemoryStream.%23ctor>, initialiseren van de wijzer en vervolgens de methode Initialize aanroepen.</xref:System.IO.UnmanagedMemoryStream.%23ctor>"
  syntax:
    content: protected void Initialize (byte* pointer, long length, long capacity, System.IO.FileAccess access);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "Een verwijzing naar een niet-beheerde geheugenlocatie."
    - id: length
      type: System.Int64
      description: "De lengte van het geheugen te gebruiken."
    - id: capacity
      type: System.Int64
      description: "De totale hoeveelheid geheugen die naar de stroom is toegewezen."
    - id: access
      type: System.IO.FileAccess
      description: "Een van de <xref href=&quot;System.IO.FileAccess&quot;> </xref> waarden."
  overload: System.IO.UnmanagedMemoryStream.Initialize*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De gebruiker heeft niet de vereiste machtiging."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>capacity</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> value is large enough to cause an overflow."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  id: Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Initialize(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> -klasse in een veilige buffer met een opgegeven offset lengte, en bestanden openen."
  syntax:
    content: protected void Initialize (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "De buffer voor de onbegeleide geheugenstroom bevatten."
    - id: offset
      type: System.Int64
      description: "De bytepositie in de buffer waarmee de onbegeleide geheugenstroom starten."
    - id: length
      type: System.Int64
      description: "De lengte van de onbegeleide geheugenstroom."
    - id: access
      type: System.IO.FileAccess
      description: "De modus van toegang tot de bestanden naar de geheugenstroom niet-beheerde."
  overload: System.IO.UnmanagedMemoryStream.Initialize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Length
  id: Length
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
  fullName: System.IO.UnmanagedMemoryStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee haalt de lengte van de gegevens in een stroom."
  remarks: "Als het niet worden gewijzigd omdat de stroom is geïnitialiseerd, retourneert deze eigenschap de waarde voor de lengte die aan de constructor. Als wijzigingen in de stroom die hebben plaatsgevonden, geeft deze eigenschap eventuele wijzigingen aan de lengte van de gegevens."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_1_1.cs)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "De lengte van de gegevens in de stroom."
  overload: System.IO.UnmanagedMemoryStream.Length*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Position
  id: Position
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
  fullName: System.IO.UnmanagedMemoryStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Opgehaald of ingesteld van de huidige positie in een stroom."
  remarks: "Wanneer een stream wordt geïnitialiseerd, wordt deze eigenschap ingesteld op nul.       Hoewel u de positie van de stroom niet verder dan de capaciteit van de stream instellen kunt, kunt u zich niet dat openen gebied met de <xref:System.IO.UnmanagedMemoryStream.Read%2A>en <xref:System.IO.UnmanagedMemoryStream.Write%2A>methoden.</xref:System.IO.UnmanagedMemoryStream.Write%2A> </xref:System.IO.UnmanagedMemoryStream.Read%2A> <xref:System.IO.UnmanagedMemoryStream.Read%2A>retourneert 0 en <xref:System.IO.UnmanagedMemoryStream.Write%2A>genereert een <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.UnmanagedMemoryStream.Write%2A></xref:System.IO.UnmanagedMemoryStream.Read%2A> Deze ondersteuning is bedoeld om de compatibiliteit van ontwerp en de code met basic stroom bewerkingen."
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "De huidige positie in de stroom."
  overload: System.IO.UnmanagedMemoryStream.Position*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De positie is ingesteld op een waarde die kleiner is dan nul of de positie is groter dan <xref:System.Int32.MaxValue>of resulteert in een overloop wanneer toegevoegd aan de huidige aanwijzer.</xref:System.Int32.MaxValue>"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.PositionPointer
  id: PositionPointer
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
  fullName: System.IO.UnmanagedMemoryStream.PositionPointer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Opgehaald of ingesteld van een byte-aanwijzer naar een stroom op basis van de huidige positie in de stroom."
  remarks: "Voor een verwijzing naar de volledige stroom, stel de <xref:System.IO.UnmanagedMemoryStream.Position%2A>eigenschap in op nul, en vervolgens roept u deze eigenschap.</xref:System.IO.UnmanagedMemoryStream.Position%2A>"
  syntax:
    content: public byte* PositionPointer { get; set; }
    return:
      type: System.Byte*
      description: "Een byte-verwijzing."
  overload: System.IO.UnmanagedMemoryStream.PositionPointer*
  exceptions:
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "De huidige positie is groter dan de capaciteit van de stroom."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De positie wordt ingesteld, is geen geldige positie in de huidige stroom."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De wijzer wordt ingesteld op een lagere waarde dan de beginpositie van de stroom."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De stroom is geïnitialiseerd voor gebruik met een <xref:System.Runtime.InteropServices.SafeBuffer>.</xref:System.Runtime.InteropServices.SafeBuffer> De eigenschap PositionPointer is alleen geldig voor stromen die worden geïnitialiseerd met een <xref:System.Byte>aanwijzer.</xref:System.Byte>"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Leest het opgegeven aantal bytes in de opgegeven matrix."
  remarks: "De `offset` parameter geeft de verschuiving van de bytes in de `array` parameter (de bufferindex) waarop u wilt beginnen met lezen, en de `count` parameter geeft het maximum aantal bytes dat moet worden gelezen uit deze stroom. De geretourneerde waarde is het werkelijke aantal bytes dat is gelezen, of nul als het einde van de stroom is bereikt. Als de leesbewerking geslaagd is, wordt de huidige positie van de stroom geavanceerde door het aantal bytes dat is gelezen. Als er een uitzondering optreedt, wordt de huidige positie van de stroom is ongewijzigd.       De methode Read retourneert nul pas na het einde van de stroom is bereikt. Anders leest lezen altijd ten minste één byte uit de stroom voordat u terugkeert. Als er geen gegevens uit de stroom van een aanroep naar lezen beschikbaar is, wordt de methode blokkeren totdat ten minste één byte aan gegevens kan worden geretourneerd. Een implementatie is gratis minder bytes dan aangevraagde retourneren, zelfs als het einde van de stroom niet is bereikt."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/m-system.io.unmanagedmem_2_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Wanneer deze methode retourneert, bevat de opgegeven byte-matrix met de waarden tussen `offset` en (`offset`  +  `count` - 1) vervangen door het aantal bytes lezen uit de huidige bron. Deze parameter wordt doorgegeven niet geïnitialiseerd."
    - id: offset
      type: System.Int32
      description: "De op nul gebaseerde byte-offset in `buffer` waarop u wilt beginnen met opslaan van de gegevens uit de huidige stroom lezen."
    - id: count
      type: System.Int32
      description: "Het maximum aantal bytes lezen van de huidige stroom."
    return:
      type: System.Int32
      description: "Het totale aantal bytes in de buffer gelezen. Dit kan zijn dat kleiner is dan het aantal bytes aangevraagd als dat veel bytes momenteel niet beschikbaar zijn, of nul (0) als het einde van de stroom is bereikt."
  overload: System.IO.UnmanagedMemoryStream.Read*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support reading.  \n  \n \\- or -  \n  \n The <xref:System.IO.UnmanagedMemoryStream.CanRead*> property is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is set to <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>offset</code> parameter is less than zero.  \n  \n \\- or -  \n  \n The <code>count</code> parameter is less than zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De lengte van de matrix buffer minus de <code> offset </code> -parameter is kleiner dan de <code> count </code> parameter."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchroon leest het opgegeven aantal bytes in de opgegeven matrix.       Beschikbaar vanaf[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "Als een uitzondering opgetreden tijdens de leesbewerking optreedt, wordt het ingesteld als de <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>van de eigenschap van de resulterende taak.</xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "De buffer om de gegevens in te schrijven."
    - id: offset
      type: System.Int32
      description: "De byte-offset in `buffer` waarop u wilt beginnen met het schrijven van gegevens uit de stroom."
    - id: count
      type: System.Int32
      description: "Het maximum aantal bytes te lezen."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Het token voor annulering aanvragen bewaken. De standaardwaarde is <xref:System.Threading.CancellationToken.None*>.</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Een taak die staat voor de asynchrone leesbewerking. De waarde van de <code> TResult </code> parameter bevat het totale aantal bytes dat is gelezen in de buffer. De resultaatwaarde kan zijn dat kleiner is dan het aantal bytes aangevraagd als het aantal bytes momenteel beschikbaar kleiner dan het gevraagde aantal is of kan de waarde 0 (nul) als het einde van de stroom is bereikt."
  overload: System.IO.UnmanagedMemoryStream.ReadAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.ReadByte
  id: ReadByte
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: UnmanagedMemoryStream.ReadByte()
  fullName: System.IO.UnmanagedMemoryStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Een byte leest uit een stroom en de positie binnen de stroom van één byte verplaatst, of retourneert-1 als de computer aan het einde van de stroom."
  remarks: "Gebruik deze methode om terug te keren gehele waarden uit de stroom."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to read and display the contents to the console.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_1_1.cs)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "De niet-ondertekende byte geconverteerd naar een <xref:System.Int32>object, of -1 als de computer aan het einde van de stroom.</xref:System.Int32>"
  overload: System.IO.UnmanagedMemoryStream.ReadByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support reading.  \n  \n \\- or -  \n  \n The current position is at the end of the stream."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee stelt u de huidige positie van de huidige stroom op de opgegeven waarde."
  remarks: "Zie voor meer informatie over het zoeken, <xref:System.IO.FileStream.Seek%2A>.</xref:System.IO.FileStream.Seek%2A>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin loc);
    parameters:
    - id: offset
      type: System.Int64
      description: "Het punt relatief `origin` om te beginnen met zoeken uit."
    - id: loc
      type: System.IO.SeekOrigin
      description: "Hiermee geeft u het begin, het einde of de huidige positie als een referentiepunt voor `origin`, gebruikt u de waarde van het type <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "De nieuwe positie in de stroom."
  overload: System.IO.UnmanagedMemoryStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Een poging gedaan om te zoeken vóór het begin van de stroom."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De <code> offset </code> waarde groter is dan de maximale grootte van de stroom."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>loc</code>is ongeldig."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: UnmanagedMemoryStream.SetLength(Int64)
  fullName: System.IO.UnmanagedMemoryStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee stelt u de lengte van een stroom op een bepaalde waarde."
  remarks: "Als de opgegeven waarde kleiner dan de huidige lengte van de stroom is, wordt de stroom wordt afgekapt. Als de opgegeven waarde groter dan de huidige lengte van de stroom is, wordt de stroom is uitgevouwen. Als de stroom is uitgevouwen, wordt de inhoud van de stroom tussen de oude en de nieuwe lengte zijn niet gedefinieerd.       Een stroom moet ondersteunen zowel schrijven en zoeken voor SetLength om te werken."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "De lengte van de stroom."
  overload: System.IO.UnmanagedMemoryStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The specified <code>value</code> exceeds the capacity of the stream.  \n  \n \\- or -  \n  \n The specified <code>value</code> is negative."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Schrijft een blok van de bytes in de huidige stroom met gegevens uit een buffer."
  remarks: "Schrijven wordt de huidige positie in de stroom."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/m-system.io.unmanagedmem_3_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "De bytematrix waaruit bytes kopiëren naar de huidige stroom."
    - id: offset
      type: System.Int32
      description: "De offset in de buffer waarop u wilt beginnen met het kopiëren van bytes naar de huidige stroom."
    - id: count
      type: System.Int32
      description: "Het aantal bytes schrijven naar de huidige stroom."
  overload: System.IO.UnmanagedMemoryStream.Write*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The <code>count</code> value is greater than the capacity of the stream.  \n  \n \\- or -  \n  \n The position is at the end of the stream capacity."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Een i/o-fout optreedt."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Een van de opgegeven parameters is kleiner dan nul."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De <code> offset </code> parameter minus de lengte van de <code> buffer </code> -parameter is kleiner dan de <code> count </code> parameter."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchroon een reeks bytes geschreven naar de huidige stroom, verplaatst de huidige positie binnen deze stroom door het aantal geschreven bytes en controleert annulering aanvragen.       Beschikbaar vanaf[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "Als een uitzondering opgetreden tijdens de schrijfbewerking optreedt, wordt het ingesteld als de <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>van de eigenschap van de resulterende taak.</xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "De buffer om gegevens uit te schrijven."
    - id: offset
      type: System.Int32
      description: "De op nul gebaseerde byte-offset in `buffer` waaruit u wilt beginnen met het kopiëren van bytes naar de stroom."
    - id: count
      type: System.Int32
      description: "Het maximum aantal bytes te schrijven."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Het token voor annulering aanvragen bewaken. De standaardwaarde is <xref:System.Threading.CancellationToken.None*>.</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task
      description: "Een taak die de asynchrone schrijfbewerking vertegenwoordigt."
  overload: System.IO.UnmanagedMemoryStream.WriteAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: UnmanagedMemoryStream.WriteByte(Byte)
  fullName: System.IO.UnmanagedMemoryStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Een byte schrijft naar de huidige positie in de bestandsstroom."
  remarks: ''
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_0_1.cs)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Een bytewaarde naar de stroom is geschreven."
  overload: System.IO.UnmanagedMemoryStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The current position is at the end of the capacity of the stream."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De opgegeven <code> value </code> zorgt ervoor dat de stroom overschrijdt de maximale capaciteit."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IndexOutOfRangeException
  isExternal: true
  name: System.IndexOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.UnmanagedMemoryStream.#ctor
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream()
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream()
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream()
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(Byte*,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
- uid: System.Runtime.InteropServices.SafeBuffer
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeBuffer
  nameWithType: SafeBuffer
  fullName: System.Runtime.InteropServices.SafeBuffer
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.CanRead
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
  fullName: System.IO.UnmanagedMemoryStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.UnmanagedMemoryStream.CanSeek
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
  fullName: System.IO.UnmanagedMemoryStream.CanSeek
- uid: System.IO.UnmanagedMemoryStream.CanWrite
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
  fullName: System.IO.UnmanagedMemoryStream.CanWrite
- uid: System.IO.UnmanagedMemoryStream.Capacity
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
  fullName: System.IO.UnmanagedMemoryStream.Capacity
- uid: System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: UnmanagedMemoryStream.Dispose(Boolean)
  fullName: System.IO.UnmanagedMemoryStream.Dispose(Boolean)
- uid: System.IO.UnmanagedMemoryStream.Flush
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Flush()
  nameWithType: UnmanagedMemoryStream.Flush()
  fullName: System.IO.UnmanagedMemoryStream.Flush()
- uid: System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: UnmanagedMemoryStream.FlushAsync(CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.Length
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
  fullName: System.IO.UnmanagedMemoryStream.Length
- uid: System.IO.UnmanagedMemoryStream.Position
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
  fullName: System.IO.UnmanagedMemoryStream.Position
- uid: System.IO.UnmanagedMemoryStream.PositionPointer
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
  fullName: System.IO.UnmanagedMemoryStream.PositionPointer
- uid: System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.UnmanagedMemoryStream.ReadByte
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadByte()
  nameWithType: UnmanagedMemoryStream.ReadByte()
  fullName: System.IO.UnmanagedMemoryStream.ReadByte()
- uid: System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: UnmanagedMemoryStream.SetLength(Int64)
  fullName: System.IO.UnmanagedMemoryStream.SetLength(Int64)
- uid: System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
- uid: System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: UnmanagedMemoryStream.WriteByte(Byte)
  fullName: System.IO.UnmanagedMemoryStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.UnmanagedMemoryStream.#ctor*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream
- uid: System.IO.UnmanagedMemoryStream.CanRead*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
- uid: System.IO.UnmanagedMemoryStream.CanSeek*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
- uid: System.IO.UnmanagedMemoryStream.CanWrite*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
- uid: System.IO.UnmanagedMemoryStream.Capacity*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
- uid: System.IO.UnmanagedMemoryStream.Dispose*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Dispose
  nameWithType: UnmanagedMemoryStream.Dispose
- uid: System.IO.UnmanagedMemoryStream.Flush*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Flush
  nameWithType: UnmanagedMemoryStream.Flush
- uid: System.IO.UnmanagedMemoryStream.FlushAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: FlushAsync
  nameWithType: UnmanagedMemoryStream.FlushAsync
- uid: System.IO.UnmanagedMemoryStream.Initialize*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize
  nameWithType: UnmanagedMemoryStream.Initialize
- uid: System.IO.UnmanagedMemoryStream.Length*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
- uid: System.IO.UnmanagedMemoryStream.Position*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
- uid: System.IO.UnmanagedMemoryStream.PositionPointer*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
- uid: System.IO.UnmanagedMemoryStream.Read*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Read
  nameWithType: UnmanagedMemoryStream.Read
- uid: System.IO.UnmanagedMemoryStream.ReadAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadAsync
  nameWithType: UnmanagedMemoryStream.ReadAsync
- uid: System.IO.UnmanagedMemoryStream.ReadByte*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadByte
  nameWithType: UnmanagedMemoryStream.ReadByte
- uid: System.IO.UnmanagedMemoryStream.Seek*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Seek
  nameWithType: UnmanagedMemoryStream.Seek
- uid: System.IO.UnmanagedMemoryStream.SetLength*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: SetLength
  nameWithType: UnmanagedMemoryStream.SetLength
- uid: System.IO.UnmanagedMemoryStream.Write*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Write
  nameWithType: UnmanagedMemoryStream.Write
- uid: System.IO.UnmanagedMemoryStream.WriteAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteAsync
  nameWithType: UnmanagedMemoryStream.WriteAsync
- uid: System.IO.UnmanagedMemoryStream.WriteByte*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteByte
  nameWithType: UnmanagedMemoryStream.WriteByte
