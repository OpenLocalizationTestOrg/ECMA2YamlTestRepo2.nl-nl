### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.FileSystem
  id: FileSystem
  children:
  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  - Microsoft.VisualBasic.FileSystem.CurDir
  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  - Microsoft.VisualBasic.FileSystem.Dir
  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FreeFile
  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.Kill(System.String)
  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.Reset
  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  - Microsoft.VisualBasic.FileSystem.TAB
  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  langs:
  - csharp
  name: FileSystem
  nameWithType: FileSystem
  fullName: Microsoft.VisualBasic.FileSystem
  type: Class
  summary: "De <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> -module bevat de procedures die worden gebruikt voor het bestand, map of map- en bewerkingen uitvoeren. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan het gebruik van de <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> module. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Deze module biedt ondersteuning voor de Visual Basic-taal sleutelwoorden en run-time-bibliotheek-leden die toegang bestanden en mappen tot."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/t-microsoft.visualbasic._17_1.vb)]"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      [System.Security.SecurityCritical]

      public sealed class FileSystem
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  id: ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "De huidige map of een map wordt gewijzigd. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan de <xref uid=&quot;langword_csharp_ChDir &quot; name=&quot;ChDir &quot; href=&quot;&quot;> </xref>functie. Zie voor meer informatie <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: "De `ChDir` functie wordt de standaardmap, maar niet op het standaardstation. Bijvoorbeeld, als de standaardstation C is, de volgende instructie wijzigt de standaardmap op station D, maar C blijft het standaardstation: [!code-vb [VbVbalrCatRef&#39;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_1.vb) ] kunt u relatieve directorywijzigingen is als volgt door twee punten: [!code-vb [VbVbalrCatRef&#40;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_2.vb) ]       >  [!IMPORTANT] > de `ChDir` functie vereist dat niet-beheerde Codemachtiging kan invloed hebben op de uitvoering in situaties met gedeeltelijk vertrouwen. Zie voor meer informatie <xref:System.Security.Permissions.SecurityPermission>en.</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDir` function to change the current directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#41](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_3.vb)]"
  syntax:
    content: public static void ChDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Vereist. Een <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> expressie die welke map of een map aangeeft wordt het nieuwe standaarddirectory of de map. `Path`kan het station bevatten. Als u geen station opgeeft, <xref uid=&quot;langword_csharp_ChDir&quot; name=&quot;ChDir&quot; href=&quot;&quot;> </xref> de standaardmap of de map op het huidige station wordt gewijzigd."
  overload: Microsoft.VisualBasic.FileSystem.ChDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>is leeg."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Ongeldig station is opgegeven of station is niet beschikbaar."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  id: ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Hiermee wijzigt u het huidige station."
  remarks: "De `ChDrive` functie vereist dat niet-begeleid code machtiging kan invloed hebben op de uitvoering in situaties met gedeeltelijk vertrouwen. Zie voor meer informatie <xref:System.Security.Permissions.SecurityPermission>en [Code toegangsmachtigingen](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._181_1.vb)]"
  syntax:
    content: public static void ChDrive (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Vereist. Een tekenreeksexpressie die een bestaand station aangeeft. Als u een tekenreeks met lengte nul opgeeft (&quot;&quot;), het huidige station wordt niet gewijzigd. Als de `Drive` -argument is een tekenreeks met meerdere teken <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> maakt gebruik van alleen de eerste letter."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ongeldig station is opgegeven of station is niet beschikbaar."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  id: ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Hiermee wijzigt u het huidige station."
  remarks: "De `ChDrive` functie vereist dat niet-begeleid code machtiging kan invloed hebben op de uitvoering in situaties met gedeeltelijk vertrouwen. Zie voor meer informatie <xref:System.Security.Permissions.SecurityPermission>en [Code toegangsmachtigingen](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._225_1.vb)]"
  syntax:
    content: public static void ChDrive (string Drive);
    parameters:
    - id: Drive
      type: System.String
      description: "Vereist. Een tekenreeksexpressie die een bestaand station aangeeft. Als u een tekenreeks met lengte nul opgeeft (&quot;&quot;), het huidige station wordt niet gewijzigd. Als de `Drive` -argument is een tekenreeks met meerdere teken <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> maakt gebruik van alleen de eerste letter."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ongeldig station is opgegeven of station is niet beschikbaar."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  id: CurDir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een tekenreeks voor het huidige pad. De <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._123_1.vb)]"
  syntax:
    content: public static string CurDir ();
    parameters: []
    return:
      type: System.String
      description: "Een tekenreeks die de huidige pad vertegenwoordigt."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  id: CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een tekenreeks voor het huidige pad. De <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._203_1.vb)]"
  syntax:
    content: public static string CurDir (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Optioneel. <xref uid=&quot;langword_csharp_Char&quot; name=&quot;Char&quot; href=&quot;&quot;></xref>expressie die een bestaand station aangeeft. Als u geen station opgeeft, of als `Drive` is een tekenreeks met lengte nul (&quot;&quot;), <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref> resulteert in het pad voor het huidige station."
    return:
      type: System.String
      description: "Een tekenreeks die de huidige pad vertegenwoordigt."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir
  id: Dir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een tekenreeks voor de naam van een bestand of map die overeenkomt met een opgegeven patroon of file-kenmerk of het volumelabel van een station. De <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan de <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> functie. Zie <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>voor meer informatie.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "De `Dir` functie ondersteunt het gebruik van meerdere tekens (`*`) en één teken (`?`) jokertekens meerdere bestanden opgeven.       `VbVolume`retourneert het volumelabel voor het station in plaats van een specifieke bestandsnaam.       U dient een `PathName` de eerste keer dat u de `Dir` functie. Voor het ophalen van het volgende item, kunt u volgende aanroepen naar de `Dir` functie zonder parameters.      > [!IMPORTANT] > Correct, uit te voeren de `Dir` functie vereist dat de <xref:System.Security.Permissions.FileIOPermissionAccess>en <xref:System.Security.Permissions.FileIOPermissionAccess>van vlaggen <xref:System.Security.Permissions.FileIOPermission>om te worden toegekend aan het uitvoeren van code.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, en [Code toegangsmachtigingen](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       De `Attributes` argument opsommingswaarden zijn als volgt: |||   |-|-|-|   | Waarde | Constante | Beschrijving |   | `Normal`|`vbnormal`| De standaardinstelling. Hiermee worden bestanden zonder attributen. |   | `ReadOnly`|`vbReadOnly`| Hiermee geeft u alleen-lezen bestanden en bestanden zonder attributen. |   | `Hidden`|`vbHidden`| Hiermee geeft u het verborgen bestanden en bestanden zonder attributen. |   | `System`|`vbSystem`| Hiermee geeft u de systeembestanden en bestanden zonder attributen. |   | `Volume`|`vbVolume`| Volumenaam. Als elk ander kenmerk is opgegeven, `vbVolume` wordt genegeerd. |   | `Directory`|`vbDirectory`| Mappen en bestanden, ook zonder kenmerken. |   | `Archive`|`vbArchive`| Bestand is gewijzigd sinds de laatste back-up. |   | `Alias`|`vbAlias`| Bestand heeft een andere naam. |      > [!NOTE] > Deze opsommingen zijn opgegeven door de taal Visual Basic en overal kan worden gebruikt in uw code in plaats van de werkelijke waarden."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._44_1.vb)]"
  syntax:
    content: public static string Dir ();
    parameters: []
    return:
      type: System.String
      description: "Een tekenreeks die de naam van een bestand of map die overeenkomt met een opgegeven patroon of file-kenmerk of het volumelabel van een station."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een tekenreeks voor de naam van een bestand of map die overeenkomt met een opgegeven patroon of file-kenmerk of het volumelabel van een station. De <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan de <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> functie. Zie <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>voor meer informatie.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "De `Dir` functie ondersteunt het gebruik van meerdere tekens (`*`) en één teken (`?`) jokertekens meerdere bestanden opgeven.       `VbVolume`retourneert het volumelabel voor het station in plaats van een specifieke bestandsnaam.       U dient een `PathName` de eerste keer dat u de `Dir` functie. Voor het ophalen van het volgende item, kunt u volgende aanroepen naar de `Dir` functie zonder parameters.      > [!IMPORTANT] > Correct, uit te voeren de `Dir` functie vereist dat de <xref:System.Security.Permissions.FileIOPermissionAccess>en <xref:System.Security.Permissions.FileIOPermissionAccess>van vlaggen <xref:System.Security.Permissions.FileIOPermission>om te worden toegekend aan het uitvoeren van code.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, en [Code toegangsmachtigingen](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       De `Attributes` argument opsommingswaarden zijn als volgt: |||   |-|-|-|   | Waarde | Constante | Beschrijving |   | `Normal`|`vbnormal`| De standaardinstelling. Hiermee worden bestanden die geen kenmerken hebben. |   | `ReadOnly`|`vbReadOnly`| Hiermee geeft u alleen-lezen bestanden naast de bestanden die geen kenmerken hebben. |   | `Hidden`|`vbHidden`| Hiermee worden verborgen bestanden, naast de bestanden die geen kenmerken hebben. |   | `System`|`vbSystem`| Hiermee geeft u de systeembestanden, naast de bestanden die geen kenmerken hebben. |   | `Volume`|`vbVolume`| Volumenaam. Als elk ander kenmerk is opgegeven, `vbVolume` wordt genegeerd. |   | `Directory`|`vbDirectory`| Hiermee geeft u het mappen, ook bestanden die geen kenmerken hebben. |   | `Archive`|`vbArchive`| Bestand is gewijzigd sinds de laatste back-up. |   | `Alias`|`vbAlias`| Bestand heeft een andere naam. |      > [!NOTE] > Deze opsommingen zijn opgegeven door de taal Visual Basic en overal kan worden gebruikt in uw code in plaats van de werkelijke waarden."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/0bb37160-d621-482a-af3b-_1.vb)]"
  syntax:
    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);
    parameters:
    - id: PathName
      type: System.String
      description: "Optioneel. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressie die een bestandsnaam, map-of mapnaam of volumelabel station aangeeft. Een tekenreeks met lengte nul (<xref uid=&quot;langword_csharp_&quot;&quot;&quot; name=&quot;&quot;&quot;&quot; href=&quot;&quot;></xref>) wordt geretourneerd als `PathName` is niet gevonden."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Optioneel. Opsomming of numerieke expressie waarvan de waarde bestandskenmerken aangeeft. Als u dit weglaat, <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> retourneert bestanden die overeenkomen met `PathName` maar geen kenmerken hebben."
    return:
      type: System.String
      description: "Een tekenreeks die de naam van een bestand of map die overeenkomt met een opgegeven patroon of file-kenmerk of het volumelabel van een station."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  id: EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een Booleaanse waarde <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> wanneer het einde van een bestand geopend voor <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> of opeenvolgende <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> is bereikt."
  remarks: "Gebruik `EOF` om te voorkomen dat de fout gegenereerd wanneer u invoer voorbij het einde van een bestand.       De `EOF` functie retourneert `False` tot het einde van het bestand is bereikt. Bestanden zijn geopend voor `Random` of `Binary` access `EOF` retourneert `False` totdat de laatst uitgevoerde `FileGet` functie kan niet een hele record lezen is.       Bestanden zijn geopend voor `Binary` toegang tot een poging om te lezen via het bestand met de `Input` werken totdat `EOF` retourneert `True` wordt een fout gegenereerd. Gebruik de `LOF` en `Loc` functies in plaats van `EOF` wanneer het lezen van binaire bestanden met `Input`, of gebruik `Get` bij gebruik van de `EOF` functie. Bestanden zijn geopend voor `Output`, `EOF` retourneert altijd `True`."
  example:
  - "This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#62](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._184_1.vb)]"
  syntax:
    content: public static bool EOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> die een geldig bestandsnummer bevat."
    return:
      type: System.Boolean
      description: "Retourneert een Booleaanse waarde <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> wanneer het einde van een bestand geopend voor <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> of opeenvolgende <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> is bereikt."
  overload: Microsoft.VisualBasic.FileSystem.EOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  id: FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een opsomming de bestandsmodus voor bestanden die zijn geopend met behulp van de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie. De <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan de <xref uid=&quot;langword_csharp_FileAttr &quot; name=&quot;FileAttr &quot; href=&quot;&quot;> </xref>functie. Zie <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>voor meer informatie.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Deze functie retourneert een opsomming de bestandsmodus voor bestanden die zijn geopend met behulp van de `FileOpen` functie."
  example:
  - "This example uses the `FileAttr` function to return the file mode of an open file.  \n  \n [!code-vb[VbVbalrCatRef#46](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._147_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. Een geldig bestandsnummer."
    return:
      type: Microsoft.VisualBasic.OpenMode
      description: "De volgende opsommingswaarden geeft aan dat de toegangsmodus voor bestand:       <table><tbody><tr><td> Waarde       </td><td> Modus       </td></tr><tr><td> 1       </td><td><xref uid=&quot;langword_csharp_OpenMode.Input&quot; name=&quot;OpenMode.Input&quot; href=&quot;&quot;></xref></td></tr><tr><td> 2       </td><td><xref uid=&quot;langword_csharp_OpenMode.Output&quot; name=&quot;OpenMode.Output&quot; href=&quot;&quot;></xref></td></tr><tr><td> 4       </td><td><xref uid=&quot;langword_csharp_OpenMode.Random&quot; name=&quot;OpenMode.Random&quot; href=&quot;&quot;></xref></td></tr><tr><td> 8       </td><td><xref uid=&quot;langword_csharp_OpenMode.Append&quot; name=&quot;OpenMode.Append&quot; href=&quot;&quot;></xref></td></tr><tr><td> 32       </td><td><xref uid=&quot;langword_csharp_OpenMode.Binary&quot; name=&quot;OpenMode.Binary&quot; href=&quot;&quot;></xref></td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.FileSystem.FileAttr*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  id: FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Input/output (I/O) concludeert de domeincontroller naar een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>biedt u betere productiviteit en prestaties in bestands-i/o-bewerkingen. Zie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> voor meer informatie."
  remarks: "De `FileClose` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [hoe: tekst lezen van bestanden met een StreamReader](~/add/includes/ajax-current-ext-md.md),[hoe: tekst schrijven naar bestanden met een StreamWriter](~/add/includes/ajax-current-ext-md.md), en [Walkthrough: bewerken van bestanden en mappen in Visual Basic](~/add/includes/ajax-current-ext-md.md).       Als u weglaat `FileNumbers`, alle actieve bestanden worden geopend door de `FileOpen` functie zijn gesloten.       Wanneer u bestanden die zijn geopend voor sluit `Output` of `Append`, de uiteindelijke uitvoer-buffer wordt geschreven naar de buffer van het besturingssysteem voor het bestand. Alle bufferruimte die zijn gekoppeld aan het gesloten bestand wordt uitgebracht.       Wanneer de `FileClose` functie wordt uitgevoerd, is de koppeling van een bestand met het bestand number eindigt."
  example:
  - "This example uses the `FileClose`function to close a file opened for `Input`.  \n  \n [!code-vb[VbVbalrCatRef#69](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._41_1.vb)]"
  syntax:
    content: public static void FileClose (int[] FileNumbers);
    parameters:
    - id: FileNumbers
      type: System.Int32[]
      description: "Optioneel. De parametermatrix 0 of meer kanalen gesloten."
  overload: Microsoft.VisualBasic.FileSystem.FileClose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>bestaat niet."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  id: FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Een bestand kopiëren. De <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileCopy&quot; name=&quot;FileCopy&quot; href=&quot;&quot;> </xref>. Zie <xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>voor meer informatie.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>"
  remarks: "Als u probeert te gebruiken de `FileCopy` functioneren in een geopende bestand, een fout optreedt.       `FileCopy`volledig vertrouwen om te werken op de lokale schijf vereist."
  example:
  - "This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \n  \n [!code-vb[VbVbalrCatRef#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._96_1.vb)]"
  syntax:
    content: public static void FileCopy (string Source, string Destination);
    parameters:
    - id: Source
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>de expressie waarmee de naam van het bestand moet worden gekopieerd. `Source`omvat de directory of map en het station van het bronbestand."
    - id: Destination
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressie die de naam van doelbestand aangeeft. `Destination`omvat de directory of map en het station van het doelbestand."
  overload: Microsoft.VisualBasic.FileSystem.FileCopy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Source</code>of <code>Destination</code> is ongeldig of niet opgegeven."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestand is al geopend."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Bestand bestaat niet."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  id: FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een <xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;> </xref> waarde die aangeeft van de datum en tijd naar een bestand is geschreven. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileDateTime&quot; name=&quot;FileDateTime&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*></xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: ''
  example:
  - "This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \n  \n [!code-vb[VbVbalrCatRef#34](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._22_1.vb)]"
  syntax:
    content: public static DateTime FileDateTime (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressie die een bestandsnaam aangeeft. `PathName`kan de map of map, en het station opnemen."
    return:
      type: System.DateTime
      description: "<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>waarde die geeft de datum en tijd van een bestand is gemaakt of het laatst is gewijzigd."
  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>PathName</code>is ongeldig of jokertekens bevat."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Doelbestand bestaat niet."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  id: FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/ad6628f8-6ae5-47af-a394-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Boolean
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  id: FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/9daa1fad-0f67-40af-bac0-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Byte
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  id: FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/31a532e9-297f-48c8-a186-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Char
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  id: FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/d9877ddb-692f-47fe-8c26-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.DateTime
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  id: FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/3d9f416d-1287-4566-b3fa-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Decimal
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  id: FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/184fee0e-b744-4669-8fdf-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Double
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  id: FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/45e0fdff-455b-4fd4-a7c2-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Int16
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  id: FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/7db3ee1c-ee17-457b-bd2d-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Int32
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  id: FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/bd48d1ef-82ea-4239-8c9b-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Int64
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  id: FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/79f9948f-e0d0-41fe-a7b5-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Single
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  id: FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/f351f02c-d919-4d73-938f-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.ValueType
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/cefffea4-17eb-455d-be3e-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.String
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Optioneel. Geldt alleen bij het schrijven van een tekenreeks. Geeft aan of het schrijven van een twee-byte-descriptor voor de tekenreeks met een lengte van de beschrijving. De standaardwaarde is <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/c053ec00-d593-49bf-a3cb-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Array
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Optioneel. Geldt alleen bij het schrijven van een matrix. Geeft aan of de matrix moet worden behandeld als dynamisch en of de descriptor van een matrix met een beschrijving van de grootte en de grenzen van de matrix nodig is."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Optioneel. Geldt alleen bij het schrijven van een tekenreeks. Geeft aan of het schrijven van een twee-byte-descriptor voor de tekenreeks met een lengte van de beschrijving. De standaardwaarde is <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  id: FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een openstaande schijfbestand in een variabele.  De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileGetObject&quot; name=&quot;FileGetObject&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_1.vb)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 \\* 10 \\* 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject`reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file."
  example:
  - "The following example reads a record into a test file and then retrieves it.  \n  \n [!code-vb[VbVbalrCatRef#26](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_2.vb)]"
  syntax:
    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Object
      description: "Vereist. Geldige variabelenaam waarin gegevens worden gelezen."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke lezen wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  id: FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> waarde waarmee de lengte van een bestand in bytes. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileLen&quot; name=&quot;FileLen&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Als het opgegeven bestand geopend wanneer is de `FileLen` functie wordt aangeroepen, de geretourneerde waarde vertegenwoordigt de grootte van het bestand op het moment dat deze is geopend.      > [!NOTE] > Voor de huidige lengte van een geopend bestand verkrijgen, gebruikt u de `LOF` functie."
  example:
  - "This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \n  \n [!code-vb[VbVbalrCatRef#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._122_1.vb)]"
  syntax:
    content: public static long FileLen (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>de expressie waarmee een bestand. `PathName`kan de map of map, en het station opnemen."
    return:
      type: System.Int64
      description: "<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>waarde waarmee de lengte van een bestand in bytes."
  overload: Microsoft.VisualBasic.FileSystem.FileLen*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Bestand bestaat niet."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Hiermee opent u een bestand voor invoer of uitvoer. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "De `FileOpen` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Voordat de i/o-bewerkingen kan worden uitgevoerd, moet u een bestand openen. `FileOpen`een buffer toewijst voor i/o&quot;s naar het bestand en de modus van toegang voor gebruik met de buffer wordt bepaald.      > [!IMPORTANT] > Bij het schrijven naar een bestand, een toepassing heeft mogelijk een bestand te maken als het bestand waarnaar deze probeert te schrijven niet bestaat. Om dit te doen heeft toestemming nodig voor de map waarin het bestand is gemaakt. Echter, als het bestand is opgegeven door `FileName` bestaat, de toepassing moet `Write` machtiging alleen voor het bestand zelf. Waar mogelijk, voor betere beveiliging, het bestand maken tijdens de implementatie en verleen `Write` machtiging voor het bestand alleen, in plaats van aan de gehele map. Om beveiliging te verbeteren, door gegevens te schrijven naar de mappen van de gebruiker in plaats van naar de hoofdmap of de map Program Files.       Het kanaal te openen vindt u met behulp van de `FreeFile()` functie.      > [!IMPORTANT] > De `FileOpen` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming, die invloed kan zijn op de uitvoering in situaties met gedeeltelijk vertrouwen. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \n  \n The following code opens the file `TestFile` in `Input` mode.  \n  \n [!code-vb[VbVbalrCatRef#5](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_1.vb)]  \n  \n This example opens the file in `Binary` mode for writing operations only.  \n  \n [!code-vb[VbVbalrCatRef#6](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_2.vb)]  \n  \n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#7](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_3.vb)]  \n  \n This code example opens the file in `Output` mode; any process can read or write to file.  \n  \n [!code-vb[VbVbalrCatRef#8](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_4.vb)]  \n  \n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \n  \n [!code-vb[VbVbalrCatRef#9](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_5.vb)]"
  syntax:
    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer. Gebruik de <xref uid=&quot;langword_csharp_FreeFile&quot; name=&quot;FreeFile&quot; href=&quot;&quot;> </xref> functie het volgende beschikbare nummer te verkrijgen."
    - id: FileName
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressie waarmee een bestandsnaam, mapnaam kan bevatten en het station."
    - id: Mode
      type: Microsoft.VisualBasic.OpenMode
      description: 'Vereist. Enumeration specifying the file mode: <xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Output&quot; name=&quot;Output&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.OpenMode&quot;> </xref> .'
    - id: Access
      type: Microsoft.VisualBasic.OpenAccess
      description: 'Optioneel. Opsomming geven de bewerkingen zijn niet toegestaan in het geopende bestand: <xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>, of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Standaard ingesteld op <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.OpenAccess&quot;> </xref> .'
    - id: Share
      type: Microsoft.VisualBasic.OpenShare
      description: 'Optioneel. Opsomming geven de bewerkingen zijn niet toegestaan op het geopende bestand door andere processen: <xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Read&quot; name=&quot;Lock Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Write&quot; name=&quot;Lock Write&quot; href=&quot;&quot;> </xref>, en <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Standaard ingesteld op <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.OpenShare&quot;> </xref> .'
    - id: RecordLength
      type: System.Int32
      description: "Optioneel. Getal kleiner dan of gelijk aan 32.767 (bytes). Deze waarde is voor de bestanden zijn geopend voor willekeurige toegang, de recordlengte van de. Deze waarde is voor sequentiële bestanden, het aantal tekens in de buffer opgeslagen."
  overload: Microsoft.VisualBasic.FileSystem.FileOpen*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Recordlengte is negatief (en niet gelijk aan-1)."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileName</code>al is geopend, of <code>FileName</code> is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  id: FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen`functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Boolean
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  id: FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Byte
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  id: FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Char
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  id: FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.DateTime
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  id: FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Decimal
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  id: FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Double
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  id: FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de`VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Int16
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  id: FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Int32
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  id: FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Int64
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  id: FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen`functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Single
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  id: FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de`RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.ValueType
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  id: FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_3.vb)]"
  syntax:
    content: public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Object
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Object
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Object
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>..."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.String
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Optioneel. Geldt alleen bij het schrijven van een tekenreeks. Geeft aan of een twee-byte-tekenreeks Lengte descriptor voor de tekenreeks schrijven naar het bestand. De standaardwaarde is <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePut` meestal uit een bestand wordt gelezen via `FileGet`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, de volgende record of byte na de laatste `FileGet` of `FilePut` functioneren of waarnaar wordt verwezen door de laatste `Seek` functie wordt geschreven.       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePut`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePut`, u hoeft te doen met dezelfde `FileGet`, en u hebt om ervoor te zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePut` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens kan niet worden bepaald met een zekerheid, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, een uitzondering opgetreden.      -Als de variabele wordt geschreven een tekenreeks is, `FilePut` schrijft een twee-byte-descriptor die de string-lengte bevat en vervolgens schrijft de gegevens die u naar de variabele gaat. Daarom de recordlengte opgegeven door de `RecordLength` -component in de `FileOpen` functie moet ten minste twee bytes groter is dan de werkelijke lengte van de tekenreeks.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePut` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePut` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePut` schrijft een twee-byte descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven een matrix is, hebt u een keuze woord al dan niet een descriptor voor de grootte en de afmetingen van de matrix te schrijven. Schrijven naar het bestand descriptor voor een dynamische matrix maar niet voor een vaste grootte matrix Visual Basic 6.0 en eerdere versies. Visual Basic 2005 standaard de descriptor niet schrijven. Voor het schrijven van de descriptor, stel de `ArrayIsDynamic` -parameter voor `True`. Bij het schrijven van de matrix moet overeenkomen met de manier waarop die de matrix worden gelezen; Als deze wordt gelezen met de descriptor, hebt u de descriptor schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions). De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. Bijvoorbeeld de volgende matrix-declaratie 218 bytes vereist wanneer de matrix wordt geschreven naar schijf.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_1.vb) ] - als de variabele wordt geschreven is een ander type variabele (geen tekenreeks met een variabele lengte of een object), `FilePut` alleen de variabele gegevens schrijft. De recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de lengte van de gegevens worden geschreven.      - `FilePut` schrijft elementen van structuren alsof elk afzonderlijk, zijn geschreven, behalve geen opvulling tussen de elementen. De `VBFixedString` kenmerk kan worden toegepast op tekenreeksvelden in de structuren op te geven van de grootte van de tekenreeks wanneer geschreven naar schijf.          > [!NOTE] > String velden die u meer bytes hebt dan is opgegeven bij de `VBFixedString` kenmerk worden afgekapt wanneer geschreven naar schijf, ## binaire modus voor bestanden die zijn geopend `Binary` modus, de meeste van de `Random` modus regels zijn van toepassing, met enkele uitzonderingen. De volgende regels voor bestanden die zijn geopend in `Binary` modus afwijken van de regels voor `Random` modus: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePut`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft.      -Voor elke matrix dan een matrix in een structuur `FilePut` alleen de gegevens worden geschreven. Er is geen descriptor wordt geschreven.      - `FilePut` tekenreeksen met variabele lengte die geen elementen van structuren zonder de lengte van de twee-byte-descriptor schrijft. Het aantal geschreven bytes is gelijk aan het aantal tekens in de tekenreeks. Bijvoorbeeld de volgende instructies 11 bytes schrijven naar bestandsnummer 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_2.vb) ] - schrijven naar een bestand met behulp van de `FilePut` functie vereist `Write` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Array
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Optioneel. Geldt alleen bij het schrijven van een matrix. Geeft aan of de matrix moet worden behandeld als dynamic, en of het schrijven van een matrix descriptor voor de tekenreeks met een lengte van de beschrijving."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Optioneel. Geldt alleen bij het schrijven van een tekenreeks. Geeft aan of een twee-byte-tekenreeks Lengte descriptor voor de tekenreeks schrijven naar het bestand. De standaardwaarde is <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 en niet gelijk aan-1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  id: FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens uit een variabele naar een schijf-bestand.  De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FilePutObject&quot; name=&quot;FilePutObject&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "De `FilePutObject` functie wordt gebruikt in plaats van `FilePut` om te voorkomen dat dubbelzinnigheden tijdens het compileren als type `Object` wordt doorgegeven in plaats van een ander type, zoals `Integer`, `Long`, `Short`, enzovoort.       `FilePutObject`Schrijf- en leesbewerkingen descriptors die het object te beschrijven. Als u wilt uitschrijven de `Variant` type `FilePutObject` is vereist. Bij twijfel als u een object voor de tweede parameter gebruikt, wordt aangeraden dat u altijd gebruiken `FilePutObject` en `FileGetObject`.       `FilePutObject`is alleen geldig in `Random` en `Binary` modus.       Gegevens die zijn geschreven met `FilePutObject` meestal uit een bestand wordt gelezen via `FileGetObject`.       De eerste record of byte in een bestand is op positie 1, de tweede record of een byte op positie 2, enzovoort. Als u weglaat `RecordNumber`, `FilePutObject` schrijft u de volgende record of byte na de laatste `FileGetObject` of `FilePutObject` functie (of een record of een byte waarnaar wordt verwezen door de laatste `Seek` functie).       De `StringIsFixedLength` argument bepaalt of de functie tekenreeksen geïnterpreteerd als een variabele of vaste lengte. `FilePutObject`schrijft niet de lengte descriptor wanneer het argument `True`. Als u `StringIsFixedLength`  =  `True` met `FilePutObject`, u hoeft te doen met dezelfde `FileGetObject`, en moet u ook ervoor zorgen dat de tekenreeks met de verwachte lengte is geïnitialiseerd.      ## Willekeurige modus voor bestanden die zijn geopend `Random` -modus gelden van de volgende regels: - als de lengte van de gegevens worden geschreven kleiner dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, `FilePutObject` schrijft daaropvolgende records op recordlengte grenzen. De ruimte tussen het einde van een record en het begin van de volgende record opgevuld met de bestaande inhoud van de bestandsbuffer. Omdat de hoeveelheid opvulling gegevens nauwkeurig kan niet worden bepaald, wordt het doorgaans een goed idee om de recordlengte van de die overeenkomt met de lengte van de gegevens worden geschreven. Als de lengte van de gegevens worden geschreven groter dan de lengte die is opgegeven is in de `RecordLength` -component van de `FileOpen` functie, wordt er een uitzondering gegenereerd.      -Als de variabele wordt geschreven is een object met een numeriek type `FilePutObject` twee bytes te identificeren schrijft de `VarType` van het object en schrijft u de variabele. Bij het schrijven van een object dat bevat bijvoorbeeld een geheel getal, `FilePutObject` zes bytes geschreven: twee bytes identificatie van het object als `VarType(`3`)` (`Integer`) en vier bytes die gegevens bevatten. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste twee bytes groter is dan het werkelijke aantal bytes dat nodig is voor het opslaan van de variabele.      -Als de variabele wordt geschreven is een object met een tekenreeks `FilePutObject` schrijft een twee-byte-descriptor identificeren de `VarType(`8`)` van het object, een twee-byte-descriptor die de lengte van de string en schrijft het gegevenstype string aangeeft. De recordlengte is opgegeven door de `RecordLength` parameter in de `FileOpen` functie moet ten minste vier bytes groter is dan de werkelijke lengte van de tekenreeks. Als u een tekenreeks op zonder de descriptor plaatsen wilt, moet u doorgeven `True` naar de `StringIsFixedLength` parameter en de tekenreeks die u in het gelezen moet de juiste lengte.      -Als de variabele wordt geschreven is een matrix, is de recordlengte is opgegeven door de `RecordLength` -component in de `FileOpen` functie moet groter dan of gelijk zijn aan de som van de bytes die zijn vereist om de matrixgegevens en de descriptor array te schrijven. De descriptor bepaalt de positie van de matrix, de grootte en de ondergrenzen voor elke positie. De lengte is gelijk aan 2, plus 8 keer het aantal dimensies: (2 + 8 * NumberOfDimensions).      ## Binaire bestanden voor de modus voor geopend in `Binary` modus alle de `Random` modus regels zijn van toepassing, behalve: - de `RecordLength` -component in de `FileOpen` functie heeft geen effect. `FilePutObject`alle variabelen naar de schijf aaneengesloten, dat wil zeggen, zonder de opvulling aan tussen records schrijft."
  example:
  - "This example uses the `FilePutObject` function to write a string to a file.  \n  \n [!code-vb[VbVbalrCatRef#54](~/add/codesnippet/visualbasic/69f8d8bb-169c-4dec-b805-_1.vb)]"
  syntax:
    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Object
      description: "Vereist. Geldige variabelenaam met gegevens geschreven naar schijf."
    - id: RecordNumber
      type: System.Int64
      description: "Optioneel. Noteer nummer (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> modus-bestanden) of byte-nummer (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus bestanden) op welke schrijven wordt gestart."
  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  id: FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "De lijnbreedte van een uitvoer wijst naar een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie."
  remarks: ''
  example:
  - "This example uses the `FileWidth` function to set the output line width for a file.  \n  \n [!code-vb[VbVbalrCatRef#10](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._187_1.vb)]"
  syntax:
    content: public static void FileWidth (int FileNumber, int RecordWidth);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: RecordWidth
      type: System.Int32
      description: "Vereist. Een numerieke expressie in het bereik 0-255 waarmee wordt aangegeven hoeveel tekens op een regel wordt weergegeven voordat een nieuwe regel wordt gestart. Als `RecordWidth` is gelijk aan 0, er is geen limiet aan de lengte van een regel. De standaardwaarde voor `RecordWidth` is ingesteld op 0."
  overload: Microsoft.VisualBasic.FileSystem.FileWidth*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  id: FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> waarde waarmee het volgende bestandsnummer beschikbaar voor gebruik door de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie."
  remarks: "Gebruik `FreeFile` op te geven van een bestand getal dat niet al wordt gebruikt."
  example:
  - "This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \n  \n [!code-vb[VbVbalrCatRef#55](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._104_1.vb)]"
  syntax:
    content: public static int FreeFile ();
    parameters: []
    return:
      type: System.Int32
      description: "Retourneert een <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> waarde waarmee het volgende bestandsnummer beschikbaar voor gebruik door de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie."
  overload: Microsoft.VisualBasic.FileSystem.FreeFile*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Meer dan 255 bestanden zijn in gebruik."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  id: GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref> waarde waarmee de kenmerken van een bestand of map. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Om te bepalen welke kenmerken zijn ingesteld, gebruikt de `And` operator om uit te voeren een bitsgewijze vergelijking van de waarde die is geretourneerd door de `GetAttr` functie en de waarde van het bestandskenmerk die u wilt. Als het resultaat niet nul is, wordt dat kenmerk is ingesteld voor het genoemde bestand. Bijvoorbeeld, de retourwaarde van de volgende `And` expressie is nul als de `Archive` kenmerk niet is ingesteld: ```vb#   Result = GetAttr(FName) And vbArchive   ``` een andere waarde dan nul wordt geretourneerd als de `Archive` kenmerk is ingesteld."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._13_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>de expressie waarmee een bestand, map of map naam. `PathName`kan de map of map, en het station opnemen."
    return:
      type: Microsoft.VisualBasic.FileAttribute
      description: "De waarde die is geretourneerd door <xref uid=&quot;langword_csharp_GetAttr&quot; name=&quot;GetAttr&quot; href=&quot;&quot;> </xref> is de som van de volgende opsommingswaarden:       <table><tbody><tr><td> Waarde       </td><td> Constante beschrijving       </td></tr><tr><td><xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbNormal&quot; name=&quot;vbNormal&quot; href=&quot;&quot;></xref>Standaard heeft.       </td></tr><tr><td><xref uid=&quot;langword_csharp_ReadOnly&quot; name=&quot;ReadOnly&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbReadOnly&quot; name=&quot;vbReadOnly&quot; href=&quot;&quot;></xref>Alleen-lezen.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Hidden&quot; name=&quot;Hidden&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbHidden&quot; name=&quot;vbHidden&quot; href=&quot;&quot;></xref>Verborgen.       </td></tr><tr><td><xref uid=&quot;langword_csharp_System&quot; name=&quot;System&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbSystem&quot; name=&quot;vbSystem&quot; href=&quot;&quot;></xref>Bestand voor systeem.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Directory&quot; name=&quot;Directory&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbDirectory&quot; name=&quot;vbDirectory&quot; href=&quot;&quot;></xref>Map of een map.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Archive&quot; name=&quot;Archive&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbArchive&quot; name=&quot;vbArchive&quot; href=&quot;&quot;></xref>Bestand is gewijzigd sinds de laatste back-up.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Alias&quot; name=&quot;Alias&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbAlias&quot; name=&quot;vbAlias&quot; href=&quot;&quot;></xref>Bestand heeft een andere naam.       </td></tr></tbody></table><div class=&quot;alert NOTE&quot;>    Deze opsommingen worden opgegeven door de taal Visual Basic. De namen kunnen overal worden gebruikt in uw code in plaats van de werkelijke waarden.      </div>"
  overload: Microsoft.VisualBasic.FileSystem.GetAttr*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>Pathname</code>is ongeldig of jokertekens bevat."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Doelbestand bestaat niet."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  id: Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._237_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref bool Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Boolean
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  id: Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._73_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref byte Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Byte
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  id: Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._91_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref char Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Char
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  id: Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._169_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref DateTime Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.DateTime
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  id: Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._46_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref decimal Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Decimal
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  id: Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._204_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref double Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Double
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  id: Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._81_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref short Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Int16
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  id: Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._207_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref int Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Int32
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  id: Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._31_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref long Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Int64
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  id: Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._244_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref object Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Object
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  id: Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._115_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref float Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.Single
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  id: Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Leest de gegevens uit een geopend bestand sequentiële en wijst de gegevens naar variabelen."
  remarks: "De `Input` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `Input` meestal naar een bestand is geschreven met behulp van `Write`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van het bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een bronbestand Visual Basic 2005.       Wanneer het wordt gelezen, wordt standaard tekenreeks of numerieke gegevens toegewezen aan variabelen zonder aanpassing. De volgende tabel ziet u hoe de andere invoergegevens wordt behandeld.      |||   |-|-|   | Gegevens | Waarde die is toegewezen aan de variabele |   | Die begrenst komma of een lege regel | Lege |   | NULL #| `DBNull`|   | # #-TRUE of FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| De datum en/of tijd vertegenwoordigd door de expressie |   |#ERROR `errornumber` #| `errornumber` (variabele is een object als een fout met tags) |       Als u het einde van het bestand bereikt terwijl u bij het invoeren van een gegevensitem, de invoer is gestopt en er een fout optreedt.      > [!NOTE] > De `Input` functie is niet gelokaliseerd. Bijvoorbeeld, in de Duitse versie wordt als het ingevoerde 3,14159, alleen 3, omdat de komma wordt behandeld als een variabele scheidingsteken in plaats van als een decimaalteken.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `Input` functie vereist `Read` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._140_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref string Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Value
      type: System.String
      description: "Vereist. Variabele die de waarden wordt toegewezen uit het bestand wordt gelezen: kan niet een matrix of object-variabele."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  id: InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> -waarde die tekens uit een bestand bevat wordt geopend in <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "De `InputString` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens gelezen met de `InputString` functie meestal naar een bestand is geschreven met behulp van `Print` of `FilePut`. Gebruik deze functie alleen met bestanden die zijn geopend `Input` of `Binary` modus.       In tegenstelling tot de `Input` functie, de `InputString` functie retourneert alle tekens worden gelezen. Dit omvat komma&quot;s, regelterugloop regelinvoer, aanhalingstekens en voorloopspaties.       Bestanden zijn geopend voor `Binary` toegang tot een poging tot lezen via het bestand met de `InputString` werken totdat `EOF` retourneert `True` wordt een fout gegenereerd. Gebruik de `LOF` en `Loc` functies in plaats van `EOF` wanneer u de binaire bestanden lezen met `InputString`, of gebruik `FileGet` wanneer u gebruikt de `EOF` functie.      > [!NOTE] > Bij het lezen van bestanden, beveiliging nemen van beslissingen over de inhoud van het bestand op basis van de extensie niet maken. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een Visual Basic-bronbestand."
  example:
  - "This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#33](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._220_1.vb)]"
  syntax:
    content: public static string InputString (int FileNumber, int CharCount);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: CharCount
      type: System.Int32
      description: "Vereist. Een geldige numerieke expressie waarmee het aantal tekens dat moet worden gelezen."
    return:
      type: System.String
      description: "Retourneert <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> -waarde die tekens uit een bestand bevat wordt geopend in <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> modus. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.InputString*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>bestaat niet."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>CharCount</code>&lt; 0 or &gt; 214."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  id: Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Hiermee verwijdert u bestanden van een schijf. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_Kill&quot; name=&quot;Kill&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ."
  remarks: "`Kill`ondersteunt het gebruik van meerdere tekens (`*`) en één teken (`?`) jokertekens meerdere bestanden opgeven.       **Opmerking over beveiliging** om te worden uitgevoerd, de `Kill` functie vereist `Read` en `PathDiscovery` vlaggen van <xref:System.Security.Permissions.FileIOPermission>om te worden toegekend aan het uitvoeren van code.</xref:System.Security.Permissions.FileIOPermission> Zie voor meer informatie, <xref:System.Security.SecurityException> [toegangsmachtigingen van Code](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</xref:System.Security.SecurityException>"
  example:
  - "This example uses the `Kill` function to delete a file from a disk.  \n  \n [!code-vb[VbVbalrCatRef#60](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._250_1.vb)]"
  syntax:
    content: public static void Kill (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>de expressie waarmee een of meer bestandsnamen moeten worden verwijderd. `PathName`kan de map of map, en het station opnemen."
  overload: Microsoft.VisualBasic.FileSystem.Kill*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Doelbestand openen."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Doelbestand is niet gevonden."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Toestemming geweigerd."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  id: LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Een enkele regel leest uit een geopend bestand sequentiële en overdraagt aan een <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variabele."
  remarks: "De `LineInput` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Gegevens lezen met `LineInput` meestal naar een bestand is geschreven met behulp van `Print`.      > [!IMPORTANT] > Bij het lezen van bestanden, geen beslissingen over de inhoud van een bestand op basis van de bestandsnaamextensie. Een bestand met de naam Form1.vb mogelijk bijvoorbeeld niet een Visual Basic-bronbestand.       De `LineInput` functie leest uit een bestand een teken tegelijkertijd totdat er een regelterugloop aangetroffen (`Chr(`13`)`) of een retourtype/lijn feed (`Chr(`13`)` + `Chr(`10`)`) sequence. In plaats van worden regeleinde return/lijn feed reeksen overgeslagen toegevoegd aan de tekenreeks.      > [!IMPORTANT] > Lezen in een bestand met behulp van de `LineInput` functie vereist `Read` openen vanuit de <xref:System.Security.Permissions.FileIOPermissionAccess>opsomming.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#19](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._158_1.vb)]"
  syntax:
    content: public static string LineInput (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    return:
      type: System.String
      description: "Een enkele regel leest uit een geopend bestand sequentiële en overdraagt aan een <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> variabele."
  overload: Microsoft.VisualBasic.FileSystem.LineInput*
  exceptions:
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Einde van het bestand is bereikt."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>bestaat niet."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  id: Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> waarde waarmee de huidige positie van de lezen/schrijven in een geopend bestand."
  remarks: "De `Loc` functie is op nul gebaseerde; 0 gebruikt voor het ophalen van de eerste byte in een bestand wordt geretourneerd.       De `Loc` functie wordt aangeboden voor achterwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Hieronder wordt beschreven voor de retourwaarde voor elk bestandstoegangsmodus: |||   |-|-|   | Modus | Retourwaarde |   | `Random`| Nummer van de laatste record lezen uit of schrijven naar het bestand. |   | `Sequential`| De bytepositie van het huidige in het bestand dat wordt gedeeld door 128. Evenwel de informatie wordt geretourneerd door `Loc` voor sequentiële bestanden wordt niet gebruikt en is vereist. |   | `Binary`| Positie van de laatste byte gelezen of geschreven. |"
  example:
  - "This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#17](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._178_1.vb)]"
  syntax:
    content: public static long Loc (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldige <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> bestandsnummer."
    return:
      type: System.Int64
      description: "Retourneert een <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> waarde waarmee de huidige positie van de lezen/schrijven in een geopend bestand."
  overload: Microsoft.VisualBasic.FileSystem.Loc*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  id: Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controleert de toegang door andere processen tot een bestand of een deel van een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> functie. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> en <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "De `Lock` en `Unlock` functies worden gebruikt in omgevingen waar verschillende processen mogelijk toegang tot hetzelfde bestand.       `Lock`en `Unlock` functies altijd in paren worden gebruikt. De argumenten voor `Lock` en `Unlock` moeten identiek zijn.       Als `Record`, of `FromRecord` en `ToRecord` zijn niet opgegeven, wordt de vergrendeling worden voor het hele bestand. Als `Record` alleen is opgegeven één record worden vergrendeld/ontgrendeld.       Als het bestand is geopend voor opeenvolgende invoer of uitvoer, `Lock` en `Unlock` invloed hebben op het hele bestand, ongeacht het bereik van `FromRecord` en`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._243_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  id: Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controleert de toegang door andere processen tot een bestand of een deel van een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> functie. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> en <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "De `Lock` en `Unlock` functies worden gebruikt in omgevingen waar verschillende processen mogelijk toegang tot hetzelfde bestand.       `Lock`en `Unlock` functies altijd in paren worden gebruikt. De argumenten voor `Lock` en `Unlock` moeten identiek zijn.       Als `Record`, of `FromRecord` en `ToRecord` zijn niet opgegeven, wordt de vergrendeling worden voor het hele bestand. Als `Record` alleen is opgegeven één record worden vergrendeld/ontgrendeld.       Als het bestand is geopend voor opeenvolgende invoer of uitvoer, `Lock` en `Unlock` invloed hebben op het hele bestand, ongeacht het bereik van `FromRecord` en`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._38_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Record
      type: System.Int64
      description: "Optioneel. Nummer van de enige record of een byte vergrendelen of ontgrendelen"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  id: Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controleert de toegang door andere processen tot een bestand of een deel van een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> functie. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> en <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "De `Lock` en `Unlock` functies worden gebruikt in omgevingen waar verschillende processen mogelijk toegang tot hetzelfde bestand.       `Lock`en `Unlock` functies altijd in paren worden gebruikt. De argumenten voor `Lock` en `Unlock` moeten identiek zijn.       Als `Record`, of `FromRecord` en `ToRecord` zijn niet opgegeven, wordt de vergrendeling worden voor het hele bestand. Als `Record` alleen is opgegeven één record worden vergrendeld/ontgrendeld.       Als het bestand is geopend voor opeenvolgende invoer of uitvoer, `Lock` en `Unlock` invloed hebben op het hele bestand, ongeacht het bereik van `FromRecord` en`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._116_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: FromRecord
      type: System.Int64
      description: "Optioneel. Nummer van de eerste record of byte vergrendelen of ontgrendelen."
    - id: ToRecord
      type: System.Int64
      description: "Optioneel. Nummer van de laatste record of byte vergrendelen of ontgrendelen."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  id: LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> die de grootte in bytes, van een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Gebruik de `FileLen` functie om de lengte van een bestand dat niet is geopend."
  example:
  - "This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \n  \n [!code-vb[VbVbalrCatRef#23](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._83_1.vb)]"
  syntax:
    content: public static long LOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> die een geldig bestandsnummer bevat."
    return:
      type: System.Int64
      description: "Retourneert een <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> die de grootte in bytes, van een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.LOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  id: MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Hiermee maakt een nieuwe map. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>"
  remarks: "Deze functie maakt een nieuwe map."
  example:
  - "This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \n  \n [!code-vb[VbVbalrCatRef#38](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._246_1.vb)]"
  syntax:
    content: public static void MkDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressie die u de map identificeert moet worden gemaakt. De `Path` het station kan bevatten. Als u geen station opgeeft, <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref> maakt de nieuwe map op de huidige schijf."
  overload: Microsoft.VisualBasic.FileSystem.MkDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>is niet opgegeven of is leeg."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Toestemming geweigerd."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er bestaat al een map."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  id: Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens weergave-indeling naar een sequentiële bestand."
  remarks: "De `Print` en `PrintLine` functies zijn beschikbaar voor neerwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`omvat geen een nieuwe regel aan het einde van een lijn. echter `PrintLine` bevat een nieuwe regel.       Gegevens die zijn geschreven met `Print` meestal uit een bestand wordt gelezen via `LineInput` of `Input`.       Als u weglaat `Output` voor `PrintLine`, een lege regel wordt afgedrukt naar het bestand; voor `Print`, er is niets uitvoer is. Meerdere expressies van elkaar gescheiden door een komma worden afgestemd op het tabblad grenzen, maar groeperen komma&quot;s en `TAB` kan leiden tot inconsistente resultaten.       Voor `Boolean` gegevens, ofwel `True` of `False` wordt afgedrukt. De `True` en `False` trefwoorden zijn niet vertaald, ongeacht de landinstellingen.       Datumgegevens worden geschreven naar het bestand met behulp van de standaard korte datumnotatie wordt herkend door het systeem. Wanneer de datum of de tijdcomponent ontbreekt of is gelijk aan nul, alleen het gedeelte opgegeven is geschreven naar het bestand.       Er is niets is geschreven naar het bestand als `Output` gegevens is leeg. Echter, als `Output` lijstgegevens is `DBNull`, `Null` is geschreven naar het bestand.       Voor `Error` gegevens, de uitvoer wordt weergegeven als `Error errorcode`. De `Error` sleutelwoord is niet vertaald ongeacht de landinstellingen.       Alle gegevens geschreven naar het bestand met behulp van `Print` internationaal bewust; dat wil zeggen, de gegevens is correct geformatteerd met het juiste decimaalteken. Als de gebruiker wil uitvoergegevens voor gebruik door meerdere landinstellingen `Write` moet worden gebruikt.       Schrijven naar een bestand met behulp van de `Print` of `PrintLine` functies vereist `Write` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._146_1.vb)]"
  syntax:
    content: public static void Print (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Output
      type: System.Object[]
      description: "Optioneel. Nul of meer door komma&quot;s gescheiden expressies naar een bestand te schrijven.       De `Output` argumentinstellingen zijn: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: bestandsmodus is ongeldig.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` bestaat niet."
  overload: Microsoft.VisualBasic.FileSystem.Print*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  id: PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens weergave-indeling naar een sequentiële bestand."
  remarks: "De `Print` en `PrintLine` functies zijn beschikbaar voor neerwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`omvat geen een nieuwe regel aan het einde van een lijn. echter`PrintLine` bevat een nieuwe regel.       Gegevens die zijn geschreven met `Print` meestal uit een bestand wordt gelezen via `LineInput` of `Input`.       Als u weglaat `Output` voor `PrintLine`, een lege regel wordt afgedrukt naar het bestand; voor `Print`, er is niets uitvoer is. Meerdere expressies van elkaar gescheiden door een komma worden afgestemd op het tabblad grenzen, maar groeperen komma&quot;s en `TAB` kan leiden tot inconsistente resultaten.       Voor `Boolean` gegevens, ofwel `True` of `False` wordt afgedrukt. De `True` en `False` trefwoorden zijn niet vertaald, ongeacht de landinstellingen.       Datumgegevens worden geschreven naar het bestand met behulp van de standaard korte datumnotatie wordt herkend door het systeem. Wanneer de datum of de tijdcomponent ontbreekt of is gelijk aan nul, alleen het gedeelte opgegeven is geschreven naar het bestand.       Er is niets is geschreven naar het bestand als `Output` gegevens is leeg. Echter, als `Output` lijstgegevens is `DBNull`, `Null` is geschreven naar het bestand.       Voor `Error` gegevens, de uitvoer wordt weergegeven als `Error errorcode`. De `Error` sleutelwoord is niet vertaald ongeacht de landinstellingen.       Alle gegevens geschreven naar het bestand met behulp van `Print` internationaal bewust; dat wil zeggen, de gegevens is correct geformatteerd met het juiste decimaalteken. Als de gebruiker wil uitvoergegevens voor gebruik door meerdere landinstellingen `Write` moet worden gebruikt.       Schrijven naar een bestand met behulp van de `Print` of `PrintLine` functies vereist `Write` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._245_1.vb)]"
  syntax:
    content: public static void PrintLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Output
      type: System.Object[]
      description: "Optioneel. Nul of meer door komma&quot;s gescheiden expressies naar een bestand te schrijven.       De `Output` argumentinstellingen zijn: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: bestandsmodus is ongeldig.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` bestaat niet."
  overload: Microsoft.VisualBasic.FileSystem.PrintLine*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  id: Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Wijzigt de naam van een bestand of map. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_Rename&quot; name=&quot;Rename&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "De`Rename` functie wijzigt de naam van een bestand en wordt verplaatst naar een andere map, indien nodig. De `Rename` functie een bestand over stations kunt verplaatsen, maar deze kan alleen een bestaande map wijzigen wanneer beide `NewPath` en `OldPath` zich op hetzelfde station bevinden. `Rename`kan een nieuw bestand of map niet maken.       Met behulp van de `Rename` functie op een geopend bestand, treedt een fout. U moet een geopend bestand sluiten voordat deze naam. `Rename`Er kunnen geen argumenten bevatten meerdere tekens (*) en jokertekens die één teken (?).      > [!IMPORTANT] > Bij gebruik van `Rename` wilt kopiëren van een bestand vanaf een niet-beveiligde locatie naar een beveiligde locatie, behoudt de minder beperkte rechten voor het bestand. Controleer of u bent niet introductie van een mogelijk beveiligingsrisico."
  example:
  - "This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \n  \n [!code-vb[VbVbalrCatRef#30](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._97_1.vb)]"
  syntax:
    content: public static void Rename (string OldPath, string NewPath);
    parameters:
    - id: OldPath
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>de expressie waarmee de bestaande bestandsnaam en locatie. `OldPath`omvat de directory en het station van het bestand."
    - id: NewPath
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>de expressie waarmee de nieuwe bestandsnaam en locatie. `NewPath`omvat mogelijk directory en de schijf van de doellocatie. De bestandsnaam die is opgegeven door `NewPath` kan niet al bestaan."
  overload: Microsoft.VisualBasic.FileSystem.Rename*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Pad is ongeldig."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>OldPath</code>bestand bestaat niet."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Naam niet wijzigen naar een ander apparaat."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Reset
  id: Reset
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Sluit alle bestanden die zijn geopend met behulp van schijf de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_Reset&quot; name=&quot;Reset&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "De `Reset` functie sluit u alle actieve bestanden die zijn geopend door de `FileOpen` functioneren en heeft dezelfde functie als `FileClose()` zonder parameters."
  example:
  - "This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \n  \n [!code-vb[VbVbalrCatRef#12](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._117_1.vb)]"
  syntax:
    content: public static void Reset ();
    parameters: []
  overload: Microsoft.VisualBasic.FileSystem.Reset*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  id: RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Hiermee verwijdert u een bestaande map. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>"
  remarks: "Er treedt een fout op als u probeert te gebruiken `RmDir` op een map die bestanden bevat. Gebruik de `Kill` functie voor het verwijderen van alle bestanden voordat u probeert te verwijderen van een map."
  example:
  - "This example uses the `RmDir` function to remove an existing directory.  \n  \n [!code-vb[VbVbalrCatRef#31](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._20_1.vb)]"
  syntax:
    content: public static void RmDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressie die u identificeert de map of een map worden verwijderd. `Path`kan het station bevatten. Als u geen station opgeeft, <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref> Hiermee verwijdert u de map op de huidige schijf."
  overload: Microsoft.VisualBasic.FileSystem.RmDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>is niet opgegeven of is leeg."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Doelmap bevat bestanden."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Map bestaat niet."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  id: Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> opgeven van de huidige positie lezen/schrijven in een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie of stelt de positie van de volgende lezen/schrijven-bewerking in een bestand wordt geopend met behulp van de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`retourneert een waarde tussen 1 en 2.147.483.647 (equivalent zijn aan 2 ^ 31-1).       De volgende beschrijft de retourwaarden voor elk bestandstoegangsmodus: |||   |-|-|   | Modus | Retourwaarde |   | `Random`| Nummer van de volgende record gelezen of geschreven |   | `Binary`, `Input`, `Output`, `Append`| De bytepositie waar de volgende bewerking plaatsvindt. De eerste byte in een bestand op positie 1 is, de tweede byte op positie 2, enzovoort. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_4.vb)]"
  syntax:
    content: public static long Seek (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> die een geldig bestandsnummer bevat."
    return:
      type: System.Int64
      description: "Retourneert een <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> opgeven van de huidige positie lezen/schrijven in een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie of stelt de positie van de volgende lezen/schrijven-bewerking in een bestand wordt geopend met behulp van de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  id: Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Retourneert een <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> opgeven van de huidige positie lezen/schrijven in een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie of stelt de positie van de volgende lezen/schrijven-bewerking in een bestand wordt geopend met behulp van de <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> functie. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`retourneert een waarde tussen 1 en 2.147.483.647 (equivalent zijn aan 2 ^ 31-1).       De volgende beschrijft de retourwaarden voor elk bestandstoegangsmodus: |||   |-|-|   | Modus | Retourwaarde |   | `Random`| Nummer van de volgende record gelezen of geschreven |   | `Binary`, `Input`, `Output`, `Append`| De bytepositie waar de volgende bewerking plaatsvindt. De eerste byte in een bestand op positie 1 is, de tweede byte op positie 2, enzovoort. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_4.vb)]"
  syntax:
    content: public static void Seek (int FileNumber, long Position);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> die een geldig bestandsnummer bevat."
    - id: Position
      type: System.Int64
      description: "Vereist. Nummer in het bereik 1 – 2.147.483.647, liggen, waarmee wordt aangegeven waar de volgende lezen/schrijven bewerking moet plaatsvinden."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Stelt de kenmerkgegevens voor een bestand. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_SetAttr&quot; name=&quot;SetAttr&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Een runtime fout treedt op als u probeert in te stellen van de kenmerken van een geopend bestand.       De `Attributes` argument opsommingswaarden zijn als volgt: |||   |-|-|-|   | Waarde | Constante | Beschrijving |   | `Normal`|`vbNormal`| Normaal (standaard). |   | `ReadOnly`|`vbReadOnly`| Alleen-lezen. |   | `Hidden`|`vbHidden`| Verborgen. |   | `System`|`vbSystem`| Systeembestand. |   | `Volume`|`vbVolume`| Volumenaam |   | `Directory`|`vbDirectory`| Map of een map. |   | `Archive`|`vbArchive`| Bestand is gewijzigd sinds de laatste back-up. |   | `Alias`|`vbAlias`| Bestand heeft een andere naam. |      > [!NOTE] > Deze opsommingen zijn opgegeven door de taal Visual Basic. De namen kunnen overal worden gebruikt in uw code in plaats van de werkelijke waarden."
  example:
  - "This example uses the `SetAttr` function to set attributes for a file.  \n  \n [!code-vb[VbVbalrCatRef#14](~/add/codesnippet/visualbasic/7c37826d-7b37-4e2d-b69a-_1.vb)]"
  syntax:
    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);
    parameters:
    - id: PathName
      type: System.String
      description: "Vereist. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>expressie die een bestandsnaam aangeeft. `PathName`mapnaam kunt opnemen en het station."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Vereist. Constante of numerieke expressie, waarvan de som bestandskenmerken aangeeft."
  overload: Microsoft.VisualBasic.FileSystem.SetAttr*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Attribute</code>type is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  id: SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Gebruikt met de <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> functie om uitvoer te positioneren."
  remarks: "Als `Count` is kleiner dan de lijnbreedte van uitvoer, onmiddellijk de volgende afdrukken positie volgt het aantal afgedrukte spaties. Als`Count` groter is dan de lijnbreedte van de uitvoer `SPC` berekent de volgende afdrukken positie met de formule: `currentprintposition`(+ (`Count``Mod``width`)) als de huidige positie van de afdruktaak is 24, de breedte van de uitvoer 80, en u geeft bijvoorbeeld `SPC(`90`)`, de volgende afdruk op positie 34 (huidige afdrukken positie + de rest van 90/80) wordt gestart. Als het verschil tussen de huidige positie van de afdruktaak en de breedte van de uitvoer is minder dan `Count` (of `Count` `Mod` *breedte*), wordt de `SPC` functie toe aan het begin van de volgende regel en genereert spaties gelijk zijn aan `Count` – (*breedte* – *huidigeafdrukpositie*).      > [!NOTE] > Zorg ervoor dat de tabelkolommen zijn breed genoeg om toe te staan voor brede letters."
  example:
  - "This example uses the `SPC` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#16](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._222_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);
    parameters:
    - id: Count
      type: System.Int16
      description: "Vereist. Het aantal spaties wilt invoegen voordat de volgende expressie in een lijst weergegeven of afgedrukt."
    return:
      type: Microsoft.VisualBasic.SpcInfo
      description: "Gebruikt met de <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> functie om uitvoer te positioneren."
  overload: Microsoft.VisualBasic.FileSystem.SPC*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB
  id: TAB
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Gebruikt met de <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> functies om uitvoer te positioneren."
  remarks: "Als de huidige afdrukken positie in de huidige regel groter dan is `Column`, `TAB` slaat de kolomwaarde gelijk zijn aan `Column` op de volgende uitvoerregel. Als `Column` is kleiner dan 1 `TAB` verplaatst de afdruktaak positie naar kolom 1. Als `Column` groter is dan de lijnbreedte van de uitvoer `TAB` berekent de volgende afdrukken positie met de formule: kolom Mod breedte bijvoorbeeld, als *breedte* 80 en u geeft `TAB(`90`)`, de volgende afdruk, begint bij kolom 10 (de rest van 90/80). Als `Column` kleiner is dan de huidige positie voor afdrukken, afdrukken begint op de volgende regel op de positie van de berekende afdrukken. Als de berekende afdrukken positie groter dan de huidige positie voor het afdrukken is, afdrukken afdrukken begint bij de berekende positie op dezelfde lijn.       De meest linkse afdrukken positie op een uitvoerregel is altijd 1. Wanneer u gebruikt de `Print` of `PrintLine` functies worden afgedrukt op bestanden, de meest rechtse afdrukken positie is de huidige breedte van het uitvoerbestand, kunt u instellen met behulp van de `FileWidth` functie.       De `TAB` functie kan ook worden gebruikt met de `WriteLine` functie. Deze kan niet worden gebruikt met <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>of <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Zorg ervoor dat de tabelkolommen zijn breed genoeg wide letters bevatten."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._165_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB ();
    parameters: []
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Gebruikt met de <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> functies om uitvoer te positioneren."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  id: TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Gebruikt met de <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> functies om uitvoer te positioneren."
  remarks: "Als de huidige afdrukken positie in de huidige regel groter dan is `Column`, `TAB` slaat de kolomwaarde gelijk zijn aan `Column` op de volgende uitvoerregel. Als `Column` is kleiner dan 1 `TAB` verplaatst de afdruktaak positie naar kolom 1. Als `Column` groter is dan de lijnbreedte van de uitvoer `TAB` berekent de volgende afdrukken positie met de formule: kolom Mod breedte bijvoorbeeld, als *breedte* 80 en u geeft `TAB(`90`)`, de volgende afdruk, begint bij kolom 10 (de rest van 90/80). Als `Column` kleiner is dan de huidige positie voor afdrukken, afdrukken begint op de volgende regel op de positie van de berekende afdrukken. Als de berekende afdrukken positie groter dan de huidige positie voor het afdrukken is, afdrukken afdrukken begint bij de berekende positie op dezelfde lijn.       De meest linkse afdrukken positie op een uitvoerregel is altijd 1. Wanneer u gebruikt de `Print` of `PrintLine` functies worden afgedrukt op bestanden, de meest rechtse afdrukken positie is de huidige breedte van het uitvoerbestand, kunt u instellen met behulp van de `FileWidth` functie.       De `TAB` functie kan ook worden gebruikt met de `WriteLine` functie. Deze kan niet worden gebruikt met <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>of <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > Zorg ervoor dat de tabelkolommen zijn breed genoeg wide letters bevatten."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._125_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);
    parameters:
    - id: Column
      type: System.Int16
      description: "Optioneel. Nummer van de kolom wordt verplaatst naar voordat de volgende expressie in een lijst weergegeven of afgedrukt. Als u dit weglaat, <xref uid=&quot;langword_csharp_TAB&quot; name=&quot;TAB&quot; href=&quot;&quot;> </xref> de invoegpositie toe aan het begin van de volgende afdrukken zone."
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "Gebruikt met de <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> functies om uitvoer te positioneren."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  id: Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controleert de toegang door andere processen tot een bestand of een deel van een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> functie. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> en <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "De `Lock` en `Unlock` functies worden gebruikt in omgevingen waar verschillende processen mogelijk toegang tot hetzelfde bestand.       `Lock`en `Unlock` functies altijd in paren worden gebruikt. De argumenten voor `Lock` en `Unlock` moeten identiek zijn.       Als `Record`, of `FromRecord` en `ToRecord` zijn niet opgegeven, wordt de vergrendeling worden voor het hele bestand. Als `Record` alleen is opgegeven één record worden vergrendeld/ontgrendeld.       Als het bestand is geopend voor opeenvolgende invoer of uitvoer, `Lock` en `Unlock` invloed hebben op het hele bestand, ongeacht het bereik van `FromRecord` en`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._26_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  id: Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controleert de toegang door andere processen tot een bestand of een deel van een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> functie. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> en <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "De `Lock` en `Unlock` functies worden gebruikt in omgevingen waar verschillende processen mogelijk toegang tot hetzelfde bestand.       `Lock`en `Unlock` functies altijd in paren worden gebruikt. De argumenten voor `Lock` en `Unlock` moeten identiek zijn.       Als `Record`, of `FromRecord` en `ToRecord` zijn niet opgegeven, wordt de vergrendeling worden voor het hele bestand. Als `Record` alleen is opgegeven één record worden vergrendeld/ontgrendeld.       Als het bestand is geopend voor opeenvolgende invoer of uitvoer, `Lock` en `Unlock` invloed hebben op het hele bestand, ongeacht het bereik van `FromRecord` en`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._210_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: Record
      type: System.Int64
      description: "Optioneel. Nummer van de enige record of een byte vergrendelen of ontgrendelen"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  id: Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Controleert de toegang door andere processen tot een bestand of een deel van een bestand geopend met behulp van de <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> functie. De <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> functie krijgt u betere productiviteit en prestaties in bestands-i/o-bewerkingen dan <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> en <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Zie voor meer informatie <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "De `Lock` en `Unlock` functies worden gebruikt in omgevingen waar verschillende processen mogelijk toegang tot hetzelfde bestand.       `Lock`en `Unlock` functies altijd in paren worden gebruikt. De argumenten voor `Lock` en `Unlock` moeten identiek zijn.       Als `Record`, of `FromRecord` en `ToRecord` zijn niet opgegeven, wordt de vergrendeling worden voor het hele bestand. Als `Record` alleen is opgegeven één record worden vergrendeld/ontgrendeld.       Als het bestand is geopend voor opeenvolgende invoer of uitvoer, `Lock` en `Unlock` invloed hebben op het hele bestand, ongeacht het bereik van `FromRecord` en`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/93b8910d-5e06-4d09-8b8b-_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een geldig bestandsnummer."
    - id: FromRecord
      type: System.Int64
      description: "Optioneel. Nummer van de eerste record of byte vergrendelen of ontgrendelen."
    - id: ToRecord
      type: System.Int64
      description: "Optioneel. Nummer van de laatste record of byte vergrendelen of ontgrendelen."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  id: Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens naar een sequentiële bestand. Gegevens die zijn geschreven met <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> meestal uit een bestand wordt gelezen via <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "De `Write` en `WriteLine` functies zijn beschikbaar voor neerwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Als u weglaat `Output`, een lege regel aan het bestand wordt afgedrukt. Meerdere expressies kunnen worden gescheiden met een komma.       In tegenstelling tot de `Print` functie, de `Write` functie voegt een komma tussen items en aanhalingstekens rond tekenreeksen als ze zijn geschreven naar het bestand. U hebt geen expliciete scheidingstekens in de lijst geplaatst. Wanneer `Write` wordt gebruikt om gegevens te schrijven naar een bestand, alleen numerieke `Boolean`, datum, null, en `Error` gegevensopmaak worden ondersteund. De volgende universal veronderstellingen worden gevolgd, zodat de gegevens kunnen altijd worden gelezen en correct geïnterpreteerd met gebruikmaking van `Input`, ongeacht van landinstellingen:-numerieke gegevens worden altijd geschreven met behulp van de periode als decimaalteken.      -Voor `Boolean` gegevens, ofwel `#TRUE#` of `#FALSE#` wordt afgedrukt. De `True` en `False` trefwoorden zijn niet vertaald, ongeacht de landinstelling.      -Datum gegevens worden geschreven naar het bestand met de universele datumnotatie. Wanneer de datum of de tijdcomponent ontbreekt of is gelijk aan nul, alleen het gedeelte opgegeven is geschreven naar het bestand.      -Niets is geschreven naar het bestand als `Output` gegevens is leeg. Echter, voor null gegevens `#NULL#` wordt geschreven.      -Voor `Error` gegevens, de uitvoer wordt weergegeven als `#ERROR errorcode#`. De `Error` sleutelwoord niet vertaald, ongeacht de landinstelling.       `WriteLine`Hiermee voegt u een nieuwe-regelteken (dat wil zeggen, een regelterugloop en nieuwe regel feeds of `Chr(13) + Chr(10)`), nadat deze is het laatste teken geschreven `Output` naar het bestand.       U kunt aanhalingstekens insluiten in een tekenreeks met behulp van dubbele aanhalingstekens, of &quot; &quot;. Bijvoorbeeld: [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_1.vb) ] retourneert een tekenreeks met de waarde van `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Schrijven naar een bestand met behulp van de `Write` of `WriteLine` functies vereist `Append` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_2.vb)]"
  syntax:
    content: public static void Write (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> expressie die een geldig bestandsnummer bevat."
    - id: Output
      type: System.Object[]
      description: "Optioneel. Een of meer door komma&quot;s gescheiden expressies naar een bestand te schrijven."
  overload: Microsoft.VisualBasic.FileSystem.Write*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Bestandsmodus is ongeldig."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  id: WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Schrijft gegevens naar een sequentiële bestand. Gegevens die zijn geschreven met <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> meestal uit een bestand wordt gelezen via <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "De `Write` en `WriteLine` functies zijn beschikbaar voor neerwaartse compatibiliteit en kan de prestaties beïnvloeden. Voor niet-legacy-toepassingen, de `My.Computer.FileSystem` object biedt betere prestaties. Zie voor meer informatie [bestandstoegang met Visual Basic](~/add/includes/ajax-current-ext-md.md).       Als u weglaat `Output`, een lege regel aan het bestand wordt afgedrukt. Meerdere expressies kunnen worden gescheiden met een komma.       In tegenstelling tot de `Print` functie, de `Write` functie voegt een komma tussen items en aanhalingstekens rond tekenreeksen als ze zijn geschreven naar het bestand. U hebt geen expliciete scheidingstekens in de lijst geplaatst. Wanneer `Write` wordt gebruikt om gegevens te schrijven naar een bestand, alleen numerieke `Boolean`, datum, null, en `Error` gegevensopmaak worden ondersteund. De volgende universal veronderstellingen worden gevolgd, zodat de gegevens kunnen altijd worden gelezen en correct geïnterpreteerd met gebruikmaking van `Input`, ongeacht van landinstellingen:-numerieke gegevens worden altijd geschreven met behulp van de periode als decimaalteken.      -Voor `Boolean` gegevens, ofwel `#TRUE#` of `#FALSE#` wordt afgedrukt. De `True` en `False` trefwoorden zijn niet vertaald, ongeacht de landinstelling.      -Datum gegevens worden geschreven naar het bestand met de universele datumnotatie. Wanneer de datum of de tijdcomponent ontbreekt of is gelijk aan nul, alleen het gedeelte opgegeven is geschreven naar het bestand.      -Niets is geschreven naar het bestand als `Output` gegevens is leeg. Echter, voor null gegevens `#NULL#` wordt geschreven.      -Voor `Error` gegevens, de uitvoer wordt weergegeven als `#ERROR errorcode#`. De `Error` sleutelwoord niet vertaald, ongeacht de landinstelling.       `WriteLine`Hiermee voegt u een nieuwe-regelteken (dat wil zeggen, een regelterugloop en nieuwe regel feeds of `Chr(13) + Chr(10)`), nadat deze is het laatste teken geschreven `Output` naar het bestand.       U kunt aanhalingstekens insluiten in een tekenreeks met behulp van dubbele aanhalingstekens, of &quot; &quot;. Bijvoorbeeld: [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_1.vb) ] retourneert een tekenreeks met de waarde van `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Schrijven naar een bestand met behulp van de `Write` of `WriteLine` functies vereist `Append` openen vanuit de `FileIOPermissionAccess` opsomming. Zie voor meer informatie <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_2.vb)]"
  syntax:
    content: public static void WriteLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Vereist. Een <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> expressie die een geldig bestandsnummer bevat."
    - id: Output
      type: System.Object[]
      description: "Optioneel. Een of meer door komma&quot;s gescheiden expressies naar een bestand te schrijven."
  overload: Microsoft.VisualBasic.FileSystem.WriteLine*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
- uid: Microsoft.VisualBasic.FileSystem.Dir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileAttribute
  parent: Microsoft.VisualBasic
  isExternal: false
  name: FileAttribute
  nameWithType: FileAttribute
  fullName: Microsoft.VisualBasic.FileAttribute
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
- uid: Microsoft.VisualBasic.OpenMode
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenMode
  nameWithType: OpenMode
  fullName: Microsoft.VisualBasic.OpenMode
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
- uid: System.Int32[]
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32[]
  spec.csharp:
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
- uid: System.Decimal
  parent: System
  isExternal: true
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
- uid: System.ValueType
  parent: System
  isExternal: true
  name: ValueType
  nameWithType: ValueType
  fullName: System.ValueType
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
- uid: Microsoft.VisualBasic.OpenAccess
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenAccess
  nameWithType: OpenAccess
  fullName: Microsoft.VisualBasic.OpenAccess
- uid: Microsoft.VisualBasic.OpenShare
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenShare
  nameWithType: OpenShare
  fullName: Microsoft.VisualBasic.OpenShare
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
- uid: Microsoft.VisualBasic.FileSystem.Reset
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
- uid: Microsoft.VisualBasic.SpcInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: SpcInfo
  nameWithType: SpcInfo
  fullName: Microsoft.VisualBasic.SpcInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
- uid: Microsoft.VisualBasic.TabInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: TabInfo
  nameWithType: TabInfo
  fullName: Microsoft.VisualBasic.TabInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.ChDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir
  nameWithType: FileSystem.ChDir
- uid: Microsoft.VisualBasic.FileSystem.ChDrive*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive
  nameWithType: FileSystem.ChDrive
- uid: Microsoft.VisualBasic.FileSystem.CurDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir
  nameWithType: FileSystem.CurDir
- uid: Microsoft.VisualBasic.FileSystem.Dir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir
  nameWithType: FileSystem.Dir
- uid: Microsoft.VisualBasic.FileSystem.EOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF
  nameWithType: FileSystem.EOF
- uid: Microsoft.VisualBasic.FileSystem.FileAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr
  nameWithType: FileSystem.FileAttr
- uid: Microsoft.VisualBasic.FileSystem.FileClose*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose
  nameWithType: FileSystem.FileClose
- uid: Microsoft.VisualBasic.FileSystem.FileCopy*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy
  nameWithType: FileSystem.FileCopy
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime
  nameWithType: FileSystem.FileDateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet
  nameWithType: FileSystem.FileGet
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject
  nameWithType: FileSystem.FileGetObject
- uid: Microsoft.VisualBasic.FileSystem.FileLen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen
  nameWithType: FileSystem.FileLen
- uid: Microsoft.VisualBasic.FileSystem.FileOpen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen
  nameWithType: FileSystem.FileOpen
- uid: Microsoft.VisualBasic.FileSystem.FilePut*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut
  nameWithType: FileSystem.FilePut
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject
  nameWithType: FileSystem.FilePutObject
- uid: Microsoft.VisualBasic.FileSystem.FileWidth*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth
  nameWithType: FileSystem.FileWidth
- uid: Microsoft.VisualBasic.FileSystem.FreeFile*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile
  nameWithType: FileSystem.FreeFile
- uid: Microsoft.VisualBasic.FileSystem.GetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr
  nameWithType: FileSystem.GetAttr
- uid: Microsoft.VisualBasic.FileSystem.Input*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input
  nameWithType: FileSystem.Input
- uid: Microsoft.VisualBasic.FileSystem.InputString*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString
  nameWithType: FileSystem.InputString
- uid: Microsoft.VisualBasic.FileSystem.Kill*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill
  nameWithType: FileSystem.Kill
- uid: Microsoft.VisualBasic.FileSystem.LineInput*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput
  nameWithType: FileSystem.LineInput
- uid: Microsoft.VisualBasic.FileSystem.Loc*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc
  nameWithType: FileSystem.Loc
- uid: Microsoft.VisualBasic.FileSystem.Lock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock
  nameWithType: FileSystem.Lock
- uid: Microsoft.VisualBasic.FileSystem.LOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF
  nameWithType: FileSystem.LOF
- uid: Microsoft.VisualBasic.FileSystem.MkDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir
  nameWithType: FileSystem.MkDir
- uid: Microsoft.VisualBasic.FileSystem.Print*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print
  nameWithType: FileSystem.Print
- uid: Microsoft.VisualBasic.FileSystem.PrintLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine
  nameWithType: FileSystem.PrintLine
- uid: Microsoft.VisualBasic.FileSystem.Rename*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename
  nameWithType: FileSystem.Rename
- uid: Microsoft.VisualBasic.FileSystem.Reset*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset
  nameWithType: FileSystem.Reset
- uid: Microsoft.VisualBasic.FileSystem.RmDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir
  nameWithType: FileSystem.RmDir
- uid: Microsoft.VisualBasic.FileSystem.Seek*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek
  nameWithType: FileSystem.Seek
- uid: Microsoft.VisualBasic.FileSystem.SetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr
  nameWithType: FileSystem.SetAttr
- uid: Microsoft.VisualBasic.FileSystem.SPC*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC
  nameWithType: FileSystem.SPC
- uid: Microsoft.VisualBasic.FileSystem.TAB*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB
  nameWithType: FileSystem.TAB
- uid: Microsoft.VisualBasic.FileSystem.Unlock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock
  nameWithType: FileSystem.Unlock
- uid: Microsoft.VisualBasic.FileSystem.Write*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write
  nameWithType: FileSystem.Write
- uid: Microsoft.VisualBasic.FileSystem.WriteLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine
  nameWithType: FileSystem.WriteLine
