### YamlMime:ManagedReference
items:
- uid: System.Windows.Interop.D3DImage
  id: D3DImage
  children:
  - System.Windows.Interop.D3DImage.#ctor
  - System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  - System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  - System.Windows.Interop.D3DImage.Clone
  - System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.CloneCurrentValue
  - System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.CopyBackBuffer
  - System.Windows.Interop.D3DImage.CreateInstanceCore
  - System.Windows.Interop.D3DImage.Finalize
  - System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  - System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.Height
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  - System.Windows.Interop.D3DImage.Lock
  - System.Windows.Interop.D3DImage.Metadata
  - System.Windows.Interop.D3DImage.PixelHeight
  - System.Windows.Interop.D3DImage.PixelWidth
  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  - System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  - System.Windows.Interop.D3DImage.Unlock
  - System.Windows.Interop.D3DImage.Width
  langs:
  - csharp
  name: D3DImage
  nameWithType: D3DImage
  fullName: System.Windows.Interop.D3DImage
  type: Class
  summary: "Een <xref href=&quot;System.Windows.Media.ImageSource&quot;> </xref> waarmee een gebruiker gemaakte Direct3D oppervlak worden weergegeven."
  remarks: "De klasse D3DImage gebruiken om Direct3D inhoud in een Windows Presentation Foundation (WPF)-toepassing te hosten.       Roep de <xref:System.Windows.Interop.D3DImage.Lock%2A>methode die moet worden weergegeven door de D3DImage Direct3D inhoud wijzigen.</xref:System.Windows.Interop.D3DImage.Lock%2A> Roep de <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>methode een oppervlak Direct3D toewijzen aan een D3DImage.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Roep de <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>methode voor het bijhouden van updates aan het oppervlak Direct3D.</xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Roep de <xref:System.Windows.Interop.D3DImage.Unlock%2A>methode om de gewijzigde gebieden weer te geven.</xref:System.Windows.Interop.D3DImage.Unlock%2A>       De klasse D3DImage beheert twee weergave buffers, die worden aangeroepen de *backbuffer* en de *voorste buffer*. De backbuffer is uw Direct3D voor aanvallen.  Wijzigingen in de backbuffer gekopieerd doorsturen naar de voorste buffer bij het aanroepen van de <xref:System.Windows.Interop.D3DImage.Unlock%2A>methode, waar deze wordt weergegeven op de hardware.</xref:System.Windows.Interop.D3DImage.Unlock%2A> In sommige gevallen kan de front-buffer niet beschikbaar. Dit gebrek aan beschikbaarheid kan zijn veroorzaakt door scherm vergrendelen, volledig scherm exclusieve Direct3D toepassingen, gebruikerswisseling of andere systeemactiviteiten. Wanneer dit gebeurt, uw WPF-toepassing is gemeld door het verwerken de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>gebeurtenis.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Hoe uw toepassing reageert op de front-buffer niet langer beschikbaar is, is afhankelijk van of WPF terugvallen op Softwarerendering is ingeschakeld. De <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>methode heeft een overbelasting waarvoor een parameter die aangeeft of WPF terugvalt op het Softwarerendering.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      ## Reageren op een niet beschikbaar voor Buffer wanneer WPF valt niet terug naar Software Rendering bij het aanroepen van de <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29>overbelasting of bel de <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>overbelasting met de `enableSoftwareFallback` parameter ingesteld op `false`, het systeem weergave releases de verwijzing naar de backbuffer wanneer de front-buffer niet meer beschikbaar is en er wordt niets weergegeven.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Wanneer de front-buffer weer beschikbaar is, wordt het systeem rendering gegeven de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>gebeurtenis aan uw toepassing WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Kunt u een gebeurtenis-handler voor de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>gebeurtenis rendering opnieuw met een geldige Direct3D oppervlak opnieuw opstarten.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Als u wilt starten rendering, moet u <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> aanroepen      ## Reageren op een beschikbaar Front-Buffer bij het WPF valt terug naar Software Rendering bij het aanroepen van de <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>overbelasting met de `enableSoftwareFallback` parameter ingesteld op `true`, het systeem rendering behoudt de verwijzing naar de backbuffer wanneer de front-buffer niet meer beschikbaar is, dus er is niet nodig om aan te roepen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>wanneer de front-buffer weer beschikbaar is.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>  Mogelijk zijn er situaties waarin de gebruiker-apparaat niet meer beschikbaar is.  Als dit het geval is, roepen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>vrijgeven van WPF-verwijzing naar de backbuffer.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  U moet uw apparaat opnieuw instelt, belt <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>met de `backBuffer` parameter ingesteld op `null`, en vervolgens aanroepen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>opnieuw met `backBuffer` ingesteld op een geldige Direct3D oppervlak.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      > [!NOTE] > Prestaties aanzienlijk afhankelijk is van de instellingen van het oppervlak Direct3D. Zie voor meer informatie [prestatie-overwegingen voor Direct3D9 en WPF-interoperabiliteit](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > De D3DImage klasse worden niet weergegeven Direct3D inhoud wanneer WPF renders per software, zoals via een extern bureaublad-verbinding, tenzij u aanroepen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>en geef `true` voor de `enableSoftwareFallback` parameter.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>"
  example:
  - "The following code example shows how to declare a D3DImage in XAML. You must map the <xref:System.Windows.Interop> namespace, because it is not included in the default XAML namespaces. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-xml[System.Windows.Interop.D3DImage#10](~/add/codesnippet/xaml/d3dhost/window1.xaml#10)]"
  syntax:
    content: 'public class D3DImage : System.Windows.Media.ImageSource'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Freezable
  - System.Windows.Media.Animation.Animatable
  - System.Windows.Media.ImageSource
  implements: []
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Freezable.CanFreeze
  - System.Windows.Freezable.Changed
  - System.Windows.Freezable.CreateInstance
  - System.Windows.Freezable.Freeze
  - System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)
  - System.Windows.Freezable.GetAsFrozen
  - System.Windows.Freezable.GetCurrentValueAsFrozen
  - System.Windows.Freezable.IsFrozen
  - System.Windows.Freezable.OnChanged
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)
  - System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.Freezable.ReadPreamble
  - System.Windows.Freezable.WritePostscript
  - System.Windows.Freezable.WritePreamble
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  - System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  - System.Windows.Media.ImageSource.PixelsToDIPs(System.Double,System.Int32)
  - System.Windows.Media.ImageSource.System#IFormattable#ToString(System.String,System.IFormatProvider)
  - System.Windows.Media.ImageSource.ToString
  - System.Windows.Media.ImageSource.ToString(System.IFormatProvider)
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.#ctor
  id: '#ctor'
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: D3DImage()
  nameWithType: D3DImage.D3DImage()
  fullName: System.Windows.Interop.D3DImage.D3DImage()
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> klasse."
  remarks: "De standaardbeeldschermresolutie is 1/96th inch."
  syntax:
    content: public D3DImage ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  id: '#ctor(System.Double,System.Double)'
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: D3DImage(Double,Double)
  nameWithType: D3DImage.D3DImage(Double,Double)
  fullName: System.Windows.Interop.D3DImage.D3DImage(Double,Double)
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> klasse met de opgegeven beeldschermresolutie."
  remarks: "De standaardbeeldschermresolutie is 1/96th inch."
  syntax:
    content: public D3DImage (double dpiX, double dpiY);
    parameters:
    - id: dpiX
      type: System.Double
      description: "De resolutie van het beeldscherm op de x-as."
    - id: dpiY
      type: System.Double
      description: "De resolutie van het beeldscherm op de y-as."
  overload: System.Windows.Interop.D3DImage.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>dpiX</code>of <code>dpiY</code> is kleiner dan nul."
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  id: AddDirtyRect(System.Windows.Int32Rect)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: AddDirtyRect(Int32Rect)
  nameWithType: D3DImage.AddDirtyRect(Int32Rect)
  fullName: System.Windows.Interop.D3DImage.AddDirtyRect(Int32Rect)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Hiermee geeft u op het gebied van de backbuffer die gewijzigd."
  remarks: "Roep de methode AddDirtyRect om aan te geven van wijzigingen in uw code heeft de backbuffer. Om te worden weergegeven, moet het gewijzigde gedeelte van de backbuffer een bijbehorende gewijzigde gedeelte van de <xref:System.Windows.Interop.D3DImage>.</xref:System.Windows.Interop.D3DImage> hebben.       Roep de <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>en <xref:System.Windows.Interop.D3DImage.Lock%2A>methoden voordat u de AddDirtyRect-methode aanroept.</xref:System.Windows.Interop.D3DImage.Lock%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       Roep de <xref:System.Windows.Interop.D3DImage.Unlock%2A>methode de gewijzigde gebieden kopiëren naar de voorste buffer.</xref:System.Windows.Interop.D3DImage.Unlock%2A>      > [!NOTE] > Na een paar aanroepen naar de methode AddDirtyRect de gewijzigde gebieden worden samengevoegd in één gebied. Dit betekent dat u moet geldige gegevens buiten de gewijzigde gebieden."
  example:
  - "The following code example shows how to call the AddDirtyRect method to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);
    parameters:
    - id: dirtyRect
      type: System.Windows.Int32Rect
      description: "Een <xref href=&quot;System.Windows.Int32Rect&quot;> </xref> die staat voor het gebied dat gewijzigd."
  overload: System.Windows.Interop.D3DImage.AddDirtyRect*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De bitmap niet is vergrendeld door een aanroep naar de <> </> *> of <> </> *> methoden.       - of - de backbuffer is niet toegewezen door een aanroep naar de <xref:System.Windows.Interop.D3DImage.SetBackBuffer*>methode.</xref:System.Windows.Interop.D3DImage.SetBackBuffer*>"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Een of meer van de volgende voorwaarden is waar.       <code>dirtyRect.X</code>&lt; 0       <code>dirtyRect.Y</code> &lt; 0       <code>dirtyRect.Width</code> &lt; 0 or <code>dirtyRect.Width</code> &gt; <>*>       <code>dirtyRect.Height</code> &lt; 0 or <code>dirtyRect.Height</code> &gt;<>*>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Clone
  id: Clone
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Clone()
  nameWithType: D3DImage.Clone()
  fullName: System.Windows.Interop.D3DImage.Clone()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Maakt een kloon kan worden gewijzigd van deze <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> object, grondige kopieën van de waarden van dit object. Bij het kopiëren van afhankelijkheidseigenschappen kopieert deze methode resource verwijzingen en gegevens Bindingen (die niet langer mogelijk opgelost), maar niet animaties of de huidige waarden."
  remarks: "Deze methode wordt gebruikt voor het produceren van bewerkbaar kopieën van bevroren <xref:System.Windows.Freezable>objecten (of een <xref:System.Windows.Freezable>object).</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> Deze methode schaduwen voor het gemak de overgenomen versie door een implementatie met een sterk getypeerde.       Zie voor meer informatie <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.</xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Interop.D3DImage Clone ();
    parameters: []
    return:
      type: System.Windows.Interop.D3DImage
      description: "Een bewerkbaar kloon van het huidige object. Het gekloonde object <> </> *> eigenschap <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> zelfs als de bron <> </> *> eigenschap was<xref uid=&quot;langword_csharp_true.&quot; name=&quot;true.&quot; href=&quot;&quot;></xref>"
  overload: System.Windows.Interop.D3DImage.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  id: CloneCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCore(Freezable)
  nameWithType: D3DImage.CloneCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Maakt het exemplaar van een kloon (grondige kopiëren) van de opgegeven <xref href=&quot;System.Windows.Freezable&quot;> </xref> met base eigenschapswaarden (zonder animatie)."
  syntax:
    content: protected override void CloneCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "Het object voor het klonen."
  overload: System.Windows.Interop.D3DImage.CloneCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue
  id: CloneCurrentValue
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCurrentValue()
  nameWithType: D3DImage.CloneCurrentValue()
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValue()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Maakt een kloon kan worden gewijzigd van deze <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> object, grondige kopieën van de huidige waarden van dit object. Resource-verwijzingen en gegevensbindingen animaties worden niet gekopieerd, maar de huidige waarden worden gekopieerd."
  remarks: "Deze methode wordt gebruikt voor het produceren van bewerkbaar kopieën van bevroren <xref:System.Windows.Freezable>objecten (of een <xref:System.Windows.Freezable>object).</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> Deze methode schaduwen voor het gemak de overgenomen versie door een implementatie met een sterk getypeerde.       Zie voor meer informatie <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.</xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Interop.D3DImage CloneCurrentValue ();
    parameters: []
    return:
      type: System.Windows.Interop.D3DImage
      description: "Een bewerkbaar kloon van het huidige object. Het gekloonde object <> </> *> eigenschap <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> zelfs als de bron <> </> *> eigenschap was <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.CloneCurrentValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  id: CloneCurrentValueCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCurrentValueCore(Freezable)
  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValueCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Maakt het exemplaar een bewerkbaar kloon (grondige kopiëren) van de opgegeven <xref href=&quot;System.Windows.Freezable&quot;> </xref> met behulp van de huidige eigenschapwaarden."
  syntax:
    content: protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "De <xref href=&quot;System.Windows.Freezable&quot;> </xref> om te worden gekloond."
  overload: System.Windows.Interop.D3DImage.CloneCurrentValueCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer
  id: CopyBackBuffer
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CopyBackBuffer()
  nameWithType: D3DImage.CopyBackBuffer()
  fullName: System.Windows.Interop.D3DImage.CopyBackBuffer()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Maakt een kopie van de software van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "De methode CopyBackBuffer wordt aangeroepen door clients, zoals het afdruksysteem en de <xref:System.Windows.Media.Imaging.RenderTargetBitmap>klasse.</xref:System.Windows.Media.Imaging.RenderTargetBitmap>       Eventueel Negeer de methode CopyBackBuffer aangepaste logica implementeren en een andere <xref:System.Windows.Media.Imaging.BitmapSource>.</xref:System.Windows.Media.Imaging.BitmapSource> retourneren U kunt bijvoorbeeld een tijdelijke aanduiding <xref:System.Windows.Media.Imaging.BitmapSource>Als de standaardimplementatie CopyBackBuffer retourneert `null`.</xref:System.Windows.Media.Imaging.BitmapSource>"
  syntax:
    content: protected virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();
    parameters: []
    return:
      type: System.Windows.Media.Imaging.BitmapSource
      description: "Een <xref href=&quot;System.Windows.Media.Imaging.BitmapSource&quot;> </xref> die een software-kopie van de huidige status van de backbuffer, anders wordt <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als de back-buffer kan niet worden gelezen."
  overload: System.Windows.Interop.D3DImage.CopyBackBuffer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore
  id: CreateInstanceCore
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CreateInstanceCore()
  nameWithType: D3DImage.CreateInstanceCore()
  fullName: System.Windows.Interop.D3DImage.CreateInstanceCore()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Wanneer in een afgeleide klasse geïmplementeerd, maakt u een nieuw exemplaar van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> afgeleide klasse."
  remarks: "Als u afgeleid van de <xref:System.Windows.Interop.D3DImage>klasse, moet u de methode CreateInstanceCore zodat de juiste klonen overschrijven.</xref:System.Windows.Interop.D3DImage> De standaardimplementatie voert een `return new D3DImage()`, die niet zijn in juiste als het exemplaar een andere klasse."
  syntax:
    content: protected override System.Windows.Freezable CreateInstanceCore ();
    parameters: []
    return:
      type: System.Windows.Freezable
      description: "Het nieuwe exemplaar."
  overload: System.Windows.Interop.D3DImage.CreateInstanceCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Finalize
  id: Finalize
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Finalize()
  nameWithType: D3DImage.Finalize()
  fullName: System.Windows.Interop.D3DImage.Finalize()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Resources maakt en andere opschoonacties vereisen voordat voert de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> door de garbage collector is vrijgemaakt."
  remarks: "Deze methode overschrijft <xref:System.Object.Finalize%2A>.</xref:System.Object.Finalize%2A> Toepassingscode moet niet aanroepen voor deze methode; een object `Finalize` methode wordt automatisch geactiveerd tijdens garbagecollection, tenzij voltooiing door de garbage collector is uitgeschakeld door een aanroep naar de <xref:System.GC.SuppressFinalize%2A>methode.</xref:System.GC.SuppressFinalize%2A>       Zie voor meer informatie [methoden voltooien en Destructors](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [onbeheerde hulpbronnen reinigen](~/add/includes/ajax-current-ext-md.md), en [vervangt de methode voltooien](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~D3DImage ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  id: FreezeCore(System.Boolean)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: FreezeCore(Boolean)
  nameWithType: D3DImage.FreezeCore(Boolean)
  fullName: System.Windows.Interop.D3DImage.FreezeCore(Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Maakt de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> unmodifiable of om te bepalen of deze kan worden gemaakt unmodifiable."
  remarks: "De <xref:System.Windows.Interop.D3DImage>klasse is niet toegestaan omdat wijzigingen altijd mogelijk vanwege voorste buffer beschikbaarheid zijn bevriezing.</xref:System.Windows.Interop.D3DImage>"
  syntax:
    content: protected override sealed bool FreezeCore (bool isChecking);
    parameters:
    - id: isChecking
      type: System.Boolean
      description: "Heeft geen effect."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>in alle gevallen."
  overload: System.Windows.Interop.D3DImage.FreezeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  id: GetAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: GetAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetAsFrozenCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Maakt het exemplaar een bevroren kloon van de opgegeven <xref href=&quot;System.Windows.Freezable&quot;> </xref> met base eigenschapswaarden (zonder animatie)."
  syntax:
    content: protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "Het exemplaar te kopiëren."
  overload: System.Windows.Interop.D3DImage.GetAsFrozenCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  id: GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: GetCurrentValueAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Maakt het huidige exemplaar van een bevroren kloon van de opgegeven <xref href=&quot;System.Windows.Freezable&quot;> </xref>. Als het object animatie afhankelijkheidseigenschappen heeft, worden hun huidige animatie waarden gekopieerd."
  syntax:
    content: protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "De <xref href=&quot;System.Windows.Freezable&quot;> </xref> kopiëren en te blokkeren."
  overload: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Height
  id: Height
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Height
  nameWithType: D3DImage.Height
  fullName: System.Windows.Interop.D3DImage.Height
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Met deze eigenschap wordt de hoogte van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "De waarde van de hoogte kunt wijzigen wanneer een nieuwe backbuffer is toegewezen door een aanroep naar de <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>methode.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  syntax:
    content: public override sealed double Height { get; }
    return:
      type: System.Double
      description: "De hoogte van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>in eenheden meten. Een meting-eenheid is 1/96th inch."
  overload: System.Windows.Interop.D3DImage.Height*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  id: IsFrontBufferAvailable
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Haalt een waarde die aangeeft of een front-buffer bestaat."
  remarks: "In sommige gevallen kan de front-buffer niet beschikbaar. Dit gebrek aan beschikbaarheid kan zijn veroorzaakt door scherm vergrendelen, volledig scherm exclusieve Direct3D toepassingen, gebruikerswisseling of andere systeemactiviteiten. Wanneer dit gebeurt, uw WPF-toepassing is gemeld door het verwerken de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>gebeurtenis.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Hoe uw toepassing reageert op de front-buffer niet langer beschikbaar is, is afhankelijk van of WPF terugvallen op Softwarerendering is ingeschakeld. De <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>methode heeft een overbelasting waarvoor een parameter die aangeeft of WPF terugvalt op het Softwarerendering.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Voor meer informatie, Zie de opmerkingen in de <xref:System.Windows.Interop.D3DImage>klasse.</xref:System.Windows.Interop.D3DImage>      <a name=&quot;dependencyPropertyInfo_IsFrontBufferAvailable&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`| Geen |</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>"
  example:
  - "The following code example shows how to check the IsFrontBufferAvailable property when rendering the composition target. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#2](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#2)]"
  syntax:
    content: public bool IsFrontBufferAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als een front-buffer bestaat; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  id: IsFrontBufferAvailableChanged
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailableChanged
  nameWithType: D3DImage.IsFrontBufferAvailableChanged
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Deze gebeurtenis treedt op wanneer de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>eigenschapswijzigingen.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>"
  remarks: "De IsFrontBufferAvailableChanged wilt worden gewaarschuwd wanneer de status van de front-buffer worden verwerkt. Hoe uw toepassing reageert op de front-buffer niet langer beschikbaar is, is afhankelijk van of WPF terugvallen op Softwarerendering is ingeschakeld. De <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>methode heeft een overbelasting waarvoor een parameter die aangeeft of WPF terugvalt op het Softwarerendering.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Voor meer informatie, Zie de opmerkingen in de <xref:System.Windows.Interop.D3DImage>klasse.</xref:System.Windows.Interop.D3DImage>"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  id: IsFrontBufferAvailableProperty
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailableProperty
  nameWithType: D3DImage.IsFrontBufferAvailableProperty
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Identificeert de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>afhankelijkheidseigenschap.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Lock
  id: Lock
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Lock()
  nameWithType: D3DImage.Lock()
  fullName: System.Windows.Interop.D3DImage.Lock()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Hiermee vergrendelt u de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> en kunt u bewerkingen op de backbuffer."
  remarks: "Roep de methode vergrendelen als u wilt de backbuffer wijzigen door het aanroepen van de <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>en <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>methoden.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Terwijl de <xref:System.Windows.Interop.D3DImage>is vergrendeld, uw toepassing kan ook weergeven aan het oppervlak Direct3D is toegewezen aan de backbuffer.</xref:System.Windows.Interop.D3DImage>      > [!NOTE] > De Lock-methode blokkeert wanneer het systeem rendering de backbuffer leest bijwerken van de front-buffer. Gebruik de <xref:System.Windows.Interop.D3DImage.TryLock%2A>methode om te voorkomen voor onbepaalde tijd worden geblokkeerd.</xref:System.Windows.Interop.D3DImage.TryLock%2A>"
  example:
  - "The following code example shows how to call the Lock method to enable updates to the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void Lock ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Lock*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het aantal is gelijk aan <xref:System.UInt32.MaxValue>.</xref:System.UInt32.MaxValue>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Metadata
  id: Metadata
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Metadata
  nameWithType: D3DImage.Metadata
  fullName: System.Windows.Interop.D3DImage.Metadata
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Haalt de metagegevens gekoppeld aan de installatiekopiebron."
  syntax:
    content: public override sealed System.Windows.Media.ImageMetadata Metadata { get; }
    return:
      type: System.Windows.Media.ImageMetadata
      description: "<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>in alle gevallen."
  overload: System.Windows.Interop.D3DImage.Metadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.PixelHeight
  id: PixelHeight
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
  fullName: System.Windows.Interop.D3DImage.PixelHeight
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Met deze eigenschap wordt de hoogte van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, in pixels."
  remarks: "De waarde van PixelHeight kunt wijzigen wanneer een nieuwe backbuffer is toegewezen door een aanroep naar de <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>methode.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  example:
  - "The following code example shows how to use the PixelHeight property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public int PixelHeight { get; }
    return:
      type: System.Int32
      description: "De hoogte van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, in pixels."
  overload: System.Windows.Interop.D3DImage.PixelHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.PixelWidth
  id: PixelWidth
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
  fullName: System.Windows.Interop.D3DImage.PixelWidth
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Hiermee wordt de breedte van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, in pixels."
  remarks: "De waarde van PixelWidth kunt wijzigen wanneer een nieuwe backbuffer is toegewezen door een aanroep naar de <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>methode.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  example:
  - "The following code example shows how to use the PixelWidth property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public int PixelWidth { get; }
    return:
      type: System.Int32
      description: "De breedte van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, in pixels."
  overload: System.Windows.Interop.D3DImage.PixelWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: SetBackBuffer(D3DResourceType,IntPtr)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Een oppervlak Direct3D als de bron van de back-buffer worden toegewezen."
  remarks: "Roep de methode SetBackBuffer een oppervlak Direct3D om aan te wijzen de backbuffer.      > [!NOTE] > Prestaties aanzienlijk afhankelijk is van de instellingen van het oppervlak Direct3D. Zie voor meer informatie [prestatie-overwegingen voor Direct3D9 en WPF-interoperabiliteit](~/add/includes/ajax-current-ext-md.md).       Aanroepen van de overbelasting SetBackBuffer is identiek aan het aanroepen van de <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>overbelasting met de `enableSoftwareFallback` parameter ingesteld op `false`.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Als u aanroept SetBackBuffer of aanroep <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>met de `enableSoftwareFallback` parameter ingesteld op `false`, het systeem rendering heft de verwijzing naar de backbuffer als front-buffer niet meer beschikbaar is en er wordt niets weergegeven.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Wanneer de front-buffer weer beschikbaar is, wordt het systeem rendering gegeven de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>gebeurtenis aan uw toepassing WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Kunt u een gebeurtenis-handler voor de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>gebeurtenis rendering opnieuw met een geldige Direct3D oppervlak opnieuw opstarten.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Als u wilt starten rendering, moet u SetBackBuffer aanroepen.       De volgende lijst bevat de vereiste backbuffer-instellingen voor de `IDirect3DSurface9` type.      - `D3DFMT_A8R8G8B8` of `D3DFMT_X8R8G8B8`       -    `D3DUSAGE_RENDERTARGET`       -    `D3DPOOL_DEFAULT` Multisampling is toegestaan op `IDirect3DSurface9Ex` geeft alleen weer."
  example:
  - "The following code example shows how to call the SetBackBuffer method to assign a Direct3D surface. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);
    parameters:
    - id: backBufferType
      type: System.Windows.Interop.D3DResourceType
      description: "Het type Direct3D voor aanvallen. Moet een geldige <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
    - id: backBuffer
      type: System.IntPtr
      description: "Het oppervlak Direct3D toewijzen als de backbuffer."
  overload: System.Windows.Interop.D3DImage.SetBackBuffer*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> niet is vergrendeld door een aanroep naar de <> </> *> of <> </> *> methoden."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>backBufferType</code>is geen geldige <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De parameters maken voor <code> backBuffer </code> niet voldoen aan de vereisten voor de <code> backBufferType </code>- of -de <code> backBuffer </code> apparaat is niet geldig."
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Een oppervlak Direct3D als de bron van de back-buffer worden toegewezen."
  remarks: "Als u aanroept de <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29>overbelasten of de overload SetBackBuffer aan te roepen de `enableSoftwareFallback` parameter ingesteld op `false`, het systeem weergave releases de verwijzing naar de backbuffer wanneer de front-buffer niet meer beschikbaar is en er wordt niets weergegeven.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Wanneer de front-buffer weer beschikbaar is, wordt het systeem rendering gegeven de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>gebeurtenis aan uw toepassing WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Kunt u een gebeurtenis-handler voor de <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>gebeurtenis rendering opnieuw met een geldige Direct3D oppervlak opnieuw opstarten.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Als u wilt starten rendering, moet u <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> aanroepen       Als u aanroept SetBackBuffer met de `enableSoftwareFallback` parameter ingesteld op `true`, het systeem rendering behoudt de verwijzing naar de backbuffer wanneer de front-buffer niet meer beschikbaar is, dus er is niet nodig om aan te roepen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>wanneer de front-buffer weer beschikbaar is.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Mogelijk zijn er situaties waarin de gebruiker-apparaat niet meer beschikbaar is.  Als dit het geval is, roepen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>vrijgeven van WPF-verwijzing naar de backbuffer.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  U moet uw apparaat opnieuw instelt, belt <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>met `backBuffer` ingesteld op `null`, en vervolgens aanroepen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>opnieuw met `backBuffer` ingesteld op een geldige Direct3D oppervlak.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       De volgende lijst bevat de vereiste backbuffer-instellingen voor de `IDirect3DSurface9` type.      - `D3DFMT_A8R8G8B8` of `D3DFMT_X8R8G8B8`       -    `D3DUSAGE_RENDERTARGET`       -    `D3DPOOL_DEFAULT` Multisampling is toegestaan op `IDirect3DSurface9Ex` geeft alleen weer."
  syntax:
    content: public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);
    parameters:
    - id: backBufferType
      type: System.Windows.Interop.D3DResourceType
      description: "Het type Direct3D voor aanvallen. Moet een geldige <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
    - id: backBuffer
      type: System.IntPtr
      description: "Het oppervlak Direct3D toewijzen als de backbuffer."
    - id: enableSoftwareFallback
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>terugvallen op Softwarerendering; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.SetBackBuffer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  id: TryLock(System.Windows.Duration)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: TryLock(Duration)
  nameWithType: D3DImage.TryLock(Duration)
  fullName: System.Windows.Interop.D3DImage.TryLock(Duration)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Vergrendelen wordt geprobeerd de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> en wacht tot de opgegeven duur."
  syntax:
    content: public bool TryLock (System.Windows.Duration timeout);
    parameters:
    - id: timeout
      type: System.Windows.Duration
      description: "De duur moet worden gewacht tot de vergrendeling worden verkregen."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de vergrendeling is verkregen; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.TryLock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>is ingesteld op <xref:System.Windows.Duration.Automatic*>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het aantal is gelijk aan <xref:System.UInt32.MaxValue>.</xref:System.UInt32.MaxValue>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Unlock
  id: Unlock
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Unlock()
  nameWithType: D3DImage.Unlock()
  fullName: System.Windows.Interop.D3DImage.Unlock()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "De vergrendeling voor tellen verlaagt de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "Wanneer de vergrendeling tellen voor de <xref:System.Windows.Interop.D3DImage>nul is, de <xref:System.Windows.Interop.D3DImage>is volledig ontgrendeld.</xref:System.Windows.Interop.D3DImage> </xref:System.Windows.Interop.D3DImage> De <xref:System.Windows.Interop.D3DImage>is gemarkeerd voor rendering als de installatiekopie is gewijzigd gebieden die zijn opgegeven door eerdere aanroepen naar de <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>methode.</xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> </xref:System.Windows.Interop.D3DImage>       Wanneer de wijzigingen zijn doorgevoerd en rendering optreedt, extra aanroepen naar de <xref:System.Windows.Interop.D3DImage.Lock%2A>methode blokkeren totdat de weergavethread de inhoud van de backbuffer aan de front-buffer is gekopieerd.</xref:System.Windows.Interop.D3DImage.Lock%2A> Deze synchronisatie voorkomt weergeven artefacten, zoals het kwijtraken.      > [!NOTE] > Niet het oppervlak Direct3D tijdens het bijwerken de <xref:System.Windows.Interop.D3DImage>is ontgrendeld.</xref:System.Windows.Interop.D3DImage>"
  example:
  - "The following code example shows how to call the Unlock method to copy the updated back buffer to the front buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void Unlock ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Unlock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Width
  id: Width
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Width
  nameWithType: D3DImage.Width
  fullName: System.Windows.Interop.D3DImage.Width
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Hiermee wordt de breedte van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "De waarde van de breedte kunt wijzigen wanneer een nieuwe backbuffer is toegewezen door een aanroep naar de <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>methode.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  syntax:
    content: public override sealed double Width { get; }
    return:
      type: System.Double
      description: "De breedte van de <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>in eenheden meten. Een meting-eenheid is 1/96th inch."
  overload: System.Windows.Interop.D3DImage.Width*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Media.ImageSource
  isExternal: false
  name: System.Windows.Media.ImageSource
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.Interop.D3DImage.#ctor
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage()
  nameWithType: D3DImage.D3DImage()
  fullName: System.Windows.Interop.D3DImage.D3DImage()
- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage(Double,Double)
  nameWithType: D3DImage.D3DImage(Double,Double)
  fullName: System.Windows.Interop.D3DImage.D3DImage(Double,Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: AddDirtyRect(Int32Rect)
  nameWithType: D3DImage.AddDirtyRect(Int32Rect)
  fullName: System.Windows.Interop.D3DImage.AddDirtyRect(Int32Rect)
- uid: System.Windows.Int32Rect
  parent: System.Windows
  isExternal: false
  name: Int32Rect
  nameWithType: Int32Rect
  fullName: System.Windows.Int32Rect
- uid: System.Windows.Interop.D3DImage.Clone
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Clone()
  nameWithType: D3DImage.Clone()
  fullName: System.Windows.Interop.D3DImage.Clone()
- uid: System.Windows.Interop.D3DImage
  parent: System.Windows.Interop
  isExternal: false
  name: D3DImage
  nameWithType: D3DImage
  fullName: System.Windows.Interop.D3DImage
- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCore(Freezable)
  nameWithType: D3DImage.CloneCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCore(Freezable)
- uid: System.Windows.Freezable
  parent: System.Windows
  isExternal: false
  name: Freezable
  nameWithType: Freezable
  fullName: System.Windows.Freezable
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValue()
  nameWithType: D3DImage.CloneCurrentValue()
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValue()
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValueCore(Freezable)
  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValueCore(Freezable)
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CopyBackBuffer()
  nameWithType: D3DImage.CopyBackBuffer()
  fullName: System.Windows.Interop.D3DImage.CopyBackBuffer()
- uid: System.Windows.Media.Imaging.BitmapSource
  parent: System.Windows.Media.Imaging
  isExternal: false
  name: BitmapSource
  nameWithType: BitmapSource
  fullName: System.Windows.Media.Imaging.BitmapSource
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CreateInstanceCore()
  nameWithType: D3DImage.CreateInstanceCore()
  fullName: System.Windows.Interop.D3DImage.CreateInstanceCore()
- uid: System.Windows.Interop.D3DImage.Finalize
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Finalize()
  nameWithType: D3DImage.Finalize()
  fullName: System.Windows.Interop.D3DImage.Finalize()
- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: FreezeCore(Boolean)
  nameWithType: D3DImage.FreezeCore(Boolean)
  fullName: System.Windows.Interop.D3DImage.FreezeCore(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetAsFrozenCore(Freezable)
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetCurrentValueAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(Freezable)
- uid: System.Windows.Interop.D3DImage.Height
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Height
  nameWithType: D3DImage.Height
  fullName: System.Windows.Interop.D3DImage.Height
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailableChanged
  nameWithType: D3DImage.IsFrontBufferAvailableChanged
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailableProperty
  nameWithType: D3DImage.IsFrontBufferAvailableProperty
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.Interop.D3DImage.Lock
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Lock()
  nameWithType: D3DImage.Lock()
  fullName: System.Windows.Interop.D3DImage.Lock()
- uid: System.Windows.Interop.D3DImage.Metadata
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Metadata
  nameWithType: D3DImage.Metadata
  fullName: System.Windows.Interop.D3DImage.Metadata
- uid: System.Windows.Media.ImageMetadata
  parent: System.Windows.Media
  isExternal: false
  name: ImageMetadata
  nameWithType: ImageMetadata
  fullName: System.Windows.Media.ImageMetadata
- uid: System.Windows.Interop.D3DImage.PixelHeight
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
  fullName: System.Windows.Interop.D3DImage.PixelHeight
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Interop.D3DImage.PixelWidth
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
  fullName: System.Windows.Interop.D3DImage.PixelWidth
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer(D3DResourceType,IntPtr)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
- uid: System.Windows.Interop.D3DResourceType
  parent: System.Windows.Interop
  isExternal: false
  name: D3DResourceType
  nameWithType: D3DResourceType
  fullName: System.Windows.Interop.D3DResourceType
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: TryLock(Duration)
  nameWithType: D3DImage.TryLock(Duration)
  fullName: System.Windows.Interop.D3DImage.TryLock(Duration)
- uid: System.Windows.Duration
  parent: System.Windows
  isExternal: false
  name: Duration
  nameWithType: Duration
  fullName: System.Windows.Duration
- uid: System.Windows.Interop.D3DImage.Unlock
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Unlock()
  nameWithType: D3DImage.Unlock()
  fullName: System.Windows.Interop.D3DImage.Unlock()
- uid: System.Windows.Interop.D3DImage.Width
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Width
  nameWithType: D3DImage.Width
  fullName: System.Windows.Interop.D3DImage.Width
- uid: System.Windows.Interop.D3DImage.#ctor*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage
  nameWithType: D3DImage.D3DImage
- uid: System.Windows.Interop.D3DImage.AddDirtyRect*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: AddDirtyRect
  nameWithType: D3DImage.AddDirtyRect
- uid: System.Windows.Interop.D3DImage.Clone*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Clone
  nameWithType: D3DImage.Clone
- uid: System.Windows.Interop.D3DImage.CloneCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCore
  nameWithType: D3DImage.CloneCore
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValue
  nameWithType: D3DImage.CloneCurrentValue
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValueCore
  nameWithType: D3DImage.CloneCurrentValueCore
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CopyBackBuffer
  nameWithType: D3DImage.CopyBackBuffer
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CreateInstanceCore
  nameWithType: D3DImage.CreateInstanceCore
- uid: System.Windows.Interop.D3DImage.Finalize*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Finalize
  nameWithType: D3DImage.Finalize
- uid: System.Windows.Interop.D3DImage.FreezeCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: FreezeCore
  nameWithType: D3DImage.FreezeCore
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetAsFrozenCore
  nameWithType: D3DImage.GetAsFrozenCore
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetCurrentValueAsFrozenCore
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore
- uid: System.Windows.Interop.D3DImage.Height*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Height
  nameWithType: D3DImage.Height
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
- uid: System.Windows.Interop.D3DImage.Lock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Lock
  nameWithType: D3DImage.Lock
- uid: System.Windows.Interop.D3DImage.Metadata*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Metadata
  nameWithType: D3DImage.Metadata
- uid: System.Windows.Interop.D3DImage.PixelHeight*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
- uid: System.Windows.Interop.D3DImage.PixelWidth*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
- uid: System.Windows.Interop.D3DImage.SetBackBuffer*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer
  nameWithType: D3DImage.SetBackBuffer
- uid: System.Windows.Interop.D3DImage.TryLock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: TryLock
  nameWithType: D3DImage.TryLock
- uid: System.Windows.Interop.D3DImage.Unlock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Unlock
  nameWithType: D3DImage.Unlock
- uid: System.Windows.Interop.D3DImage.Width*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Width
  nameWithType: D3DImage.Width
