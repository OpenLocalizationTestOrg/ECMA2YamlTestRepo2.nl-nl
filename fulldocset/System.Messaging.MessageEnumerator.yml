### YamlMime:ManagedReference
items:
- uid: System.Messaging.MessageEnumerator
  id: MessageEnumerator
  children:
  - System.Messaging.MessageEnumerator.Close
  - System.Messaging.MessageEnumerator.Current
  - System.Messaging.MessageEnumerator.CursorHandle
  - System.Messaging.MessageEnumerator.Dispose
  - System.Messaging.MessageEnumerator.Dispose(System.Boolean)
  - System.Messaging.MessageEnumerator.MoveNext
  - System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)
  - System.Messaging.MessageEnumerator.RemoveCurrent
  - System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)
  - System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)
  - System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)
  - System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)
  - System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)
  - System.Messaging.MessageEnumerator.Reset
  - System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current
  langs:
  - csharp
  name: MessageEnumerator
  nameWithType: MessageEnumerator
  fullName: System.Messaging.MessageEnumerator
  type: Class
  summary: "Biedt een alleen-voorwaarts cursor voor berichten in de berichtenwachtrij van een inventariseren."
  remarks: "Gebruik MessageEnumerator voor dynamische interactie met berichten in een wachtrij. Methoden die beschikbaar is via de <xref:System.Messaging.MessageQueue>klasse ofwel een MessageEnumerator die verwijst naar een dynamische lijst met berichten in de wachtrij of een matrix met een kopie op een gegeven moment - momentopname - van de wachtrij op het moment dat de opgegeven methode is aangeroepen kunt terugkeren.</xref:System.Messaging.MessageQueue>       In tegenstelling tot een statische momentopname kunt een enumerator u de verzameling niet wijzigen. Met een MessageEnumerator, kunt u berichten verwijderen uit de wachtrij en de wijziging onmiddellijk weergegeven in de wachtrij.       Een enumerator wordt niet verwijderd van de berichten uit de wachtrij wanneer deze een query naar de wachtrij. Gegevens over het bericht op de huidige cursorpositie worden geretourneerd, maar laat u het bericht in de wachtrij.       Een MessageEnumerator is een cursor, geïnitialiseerd op de kop van een dynamische lijst. De lijstvolgorde is hetzelfde als de volgorde van de berichten in de wachtrij, volgens de prioriteit van bericht. U kunt de cursor naar het eerste bericht in de wachtrij verplaatsen door het aanroepen van <xref:System.Messaging.MessageEnumerator.MoveNext%2A>.</xref:System.Messaging.MessageEnumerator.MoveNext%2A> Nadat de enumerator is geïnitialiseerd, kunt u <xref:System.Messaging.MessageEnumerator.MoveNext%2A>naar stap vooruit via de resterende berichten.</xref:System.Messaging.MessageEnumerator.MoveNext%2A> U kunt opgeven of de wachttijd voor een bericht beschikbaar komen door een time-out in de <xref:System.Messaging.MessageEnumerator.MoveNext%2A>methode.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>       Omdat de enumerator dynamisch is, kan een bericht dat wordt toegevoegd na de huidige positie van de cursor (bijvoorbeeld door een lage prioriteit), zijn toegankelijk door de enumerator. Een bericht dat wordt ingevoegd voordat de huidige cursorpositie kan niet worden geopend. Het is niet mogelijk naar stap achteruit met een MessageEnumerator. Een cursor kan alleen-voorwaartse beweging. De <xref:System.Messaging.MessageEnumerator.Reset%2A>methode kunt u de cursor terug aan het begin van de wachtrij plaatsen.</xref:System.Messaging.MessageEnumerator.Reset%2A>       Exemplaren van MessageEnumerator voor een bepaalde wachtrij onafhankelijk werken. U kunt twee MessageEnumerator-exemplaren die betrekking hebben op dezelfde wachtrij maken. De wijzigingen die één MessageEnumerator voor de berichten in de wachtrij maakt worden, onmiddellijk weergegeven in een tweede enumerator als de tweede enumerator bevindt zich voor de eerste. Echter, als twee enumerators dezelfde positie hebben en één van deze methode het bericht op die positie verwijdert, er een uitzondering gegenereerd als de andere enumerator probeert op te halen van de waarde van de <xref:System.Messaging.MessageEnumerator.Current%2A>eigenschap voor het bericht nu verwijderd.</xref:System.Messaging.MessageEnumerator.Current%2A>      > [!NOTE] > Als u geen exemplaar van maken <xref:System.Messaging.MessageQueue>met <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=fullName>ingesteld op `true`, er geen andere toepassing kan de berichten in de enumerator niet wijzigen terwijl u de verbinding met de wachtrij hebt.</xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=fullName> </xref:System.Messaging.MessageQueue>"
  example:
  - "The following example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority?displayProperty=fullName>.  \n  \n [!code-cs[MessageQueue.GetMessageEnumerator#1](~/add/codesnippet/csharp/t-system.messaging.messa_2_1.cs)]\n [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/add/codesnippet/cpp/t-system.messaging.messa_2_1.cpp)]\n [!code-vb[MessageQueue.GetMessageEnumerator#1](~/add/codesnippet/visualbasic/t-system.messaging.messa_2_1.vb)]"
  syntax:
    content: 'public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator'
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System.Collections.IEnumerator
  - System.IDisposable
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.Close
  id: Close
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: Close()
  nameWithType: MessageEnumerator.Close()
  fullName: System.Messaging.MessageEnumerator.Close()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Maakt de resources die zijn gekoppeld aan de enumerator."
  remarks: "Het besturingssysteem behoudt een geopende ingang naar de wachtrij tijdens de levensduur van de cursor. Wanneer u klaar bent met de enumerator, vrijgeven aanroep dicht bij de resources die zijn gekoppeld aan de ingang."
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Messaging.MessageEnumerator.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.Current
  id: Current
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: Current
  nameWithType: MessageEnumerator.Current
  fullName: System.Messaging.MessageEnumerator.Current
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "De huidige opgehaald <xref href=&quot;System.Messaging.Message&quot;> </xref> dat deze enumerator naar verwijst."
  remarks: "Wanneer de enumerator is gemaakt, wordt deze verwijst naar de kop van de wachtrij op een locatie voor het eerste bericht. In dit geval huidige is niet geldig en genereert een uitzondering als deze is geopend. U moet aanroepen <xref:System.Messaging.MessageEnumerator.MoveNext%2A>op de cursorpositie het eerste bericht in de wachtrij.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public System.Messaging.Message Current { get; }
    return:
      type: System.Messaging.Message
      description: "Het huidige bericht."
  overload: System.Messaging.MessageEnumerator.Current*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "U huidige aangeroepen voordat de eerste aanroep <> </> *>. De cursor bevindt zich vóór het eerste element van de bericht-opsomming.       - of - u huidige aangeroepen na een aanroep van <> </> *> retourneert <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (waarmee wordt aangegeven van de cursor bevindt zich na het laatste element van de bericht-opsomming.)"
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Het bericht dat de enumerator momenteel niet meer verwijst is bestaat. Het is mogelijk verwijderd."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.CursorHandle
  id: CursorHandle
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: CursorHandle
  nameWithType: MessageEnumerator.CursorHandle
  fullName: System.Messaging.MessageEnumerator.CursorHandle
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "De systeemeigen Message Queuing-cursor koppeling gebruikt om te bladeren berichten in de wachtrij opgehaald."
  remarks: "Deze eigenschap bevat de systeemeigen koppeling voor de opsomming. Wanneer u klaar bent met de enumerator, roept <xref:System.Messaging.MessageEnumerator.Close%2A>deze bron vrij te geven.</xref:System.Messaging.MessageEnumerator.Close%2A>"
  syntax:
    content: public IntPtr CursorHandle { get; }
    return:
      type: System.IntPtr
      description: "De koppeling systeemeigen cursor."
  overload: System.Messaging.MessageEnumerator.CursorHandle*
  exceptions:
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "De ingang bestaat niet."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.Dispose
  id: Dispose
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: Dispose()
  nameWithType: MessageEnumerator.Dispose()
  fullName: System.Messaging.MessageEnumerator.Dispose()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Versies van alle resources die worden gebruikt door de <xref href=&quot;System.Messaging.MessageEnumerator&quot;> </xref>."
  remarks: "Aanroepen van Dispose kan de bronnen die worden gebruikt door de <xref:System.Messaging.MessageEnumerator>naar opnieuw worden toegewezen voor andere doeleinden.</xref:System.Messaging.MessageEnumerator> Zie voor meer informatie over Dispose [onbeheerde hulpbronnen reinigen](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.Messaging.MessageEnumerator.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: MessageEnumerator.Dispose(Boolean)
  fullName: System.Messaging.MessageEnumerator.Dispose(Boolean)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Heft de niet-beheerde bronnen worden gebruikt door de <xref href=&quot;System.Messaging.MessageEnumerator&quot;> </xref> en eventueel de beheerde bronnen vrij."
  remarks: "Deze methode wordt aangeroepen door het publiek <xref:System.Messaging.MessageEnumerator.Dispose%2A>methode en de <xref:System.Object.Finalize%2A>methode.</xref:System.Object.Finalize%2A> </xref:System.Messaging.MessageEnumerator.Dispose%2A> `Dispose()`Hiermee wordt de beveiligde `Dispose(Boolean)` methode met de `disposing` parameter ingesteld op `true`. <xref:System.Object.Finalize%2A>roept `Dispose` met `disposing` ingesteld op `false`.</xref:System.Object.Finalize%2A>       Wanneer de `disposing` parameter `true`, deze methode worden alle resources die beheerde objecten waarover vrijgegeven dat dit <xref:System.Messaging.MessageEnumerator>verwijzingen.</xref:System.Messaging.MessageEnumerator> Deze methode roept de `Dispose()` methode van elk object waarnaar wordt verwezen."
  syntax:
    content: protected virtual void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>voor het vrijgeven van zowel beheerde als onbeheerde hulpbronnen; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om alleen niet-beheerde bronnen vrij te geven."
  overload: System.Messaging.MessageEnumerator.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.MoveNext
  id: MoveNext
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: MoveNext()
  nameWithType: MessageEnumerator.MoveNext()
  fullName: System.Messaging.MessageEnumerator.MoveNext()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "De enumerator verplaatst naar het volgende bericht in de wachtrij als die momenteel beschikbaar is."
  remarks: "Deze overbelasting wordt onmiddellijk geretourneerd als er geen bericht in de wachtrij is. Er is een andere overload die een opgegeven wacht <xref:System.TimeSpan>voor een bericht moet worden uitgevoerd.</xref:System.TimeSpan>       Als een bericht momenteel niet beschikbaar is omdat de wachtrij leeg is of omdat u na het laatste element in de verzameling hebt verplaatst, MoveNext retourneert `false` aan de methode aanroepen.       Nadat deze is gemaakt, een conceptueel enumerator staat voor het eerste bericht van de wachtrij en de eerste aanroep MoveNext wordt het eerste bericht van de wachtrij."
  syntax:
    content: public bool MoveNext ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de enumerator met succes is geavanceerde naar het volgende bericht is; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> als de enumerator heeft het einde van de wachtrij bereikt."
  overload: System.Messaging.MessageEnumerator.MoveNext*
  exceptions:
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Er is een specifiek zijn voor Message Queuing-uitzondering opgetreden."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)
  id: MoveNext(System.TimeSpan)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: MoveNext(TimeSpan)
  nameWithType: MessageEnumerator.MoveNext(TimeSpan)
  fullName: System.Messaging.MessageEnumerator.MoveNext(TimeSpan)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "De enumerator verplaatst naar het volgende bericht in de wachtrij. Als de enumerator bevindt zich aan het einde van de wachtrij <xref:System.Messaging.MessageEnumerator.MoveNext*>Wacht totdat een bericht beschikbaar is of de opgegeven time-out is verlopen.</xref:System.Messaging.MessageEnumerator.MoveNext*>"
  remarks: "Deze overbelasting wacht als er geen bericht in de wachtrij is of als de cursor heeft het einde van de wachtrij bereikt. Als u een bericht is momenteel niet beschikbaar omdat de wachtrij leeg is of omdat u na het laatste element in de verzameling hebt verplaatst <xref:System.Messaging.MessageEnumerator.MoveNext%2A>Wacht van de opgegeven time-out.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>       Als de cursor al aan het einde van de wachtrij is <xref:System.Messaging.MessageEnumerator.MoveNext%2A>retourneert alleen `true` als het nieuw bericht binnen het opgegeven tijdsinterval binnenkomt, lagere prioriteit dan alle berichten momenteel in de wachtrij en aan het einde van de wachtrij is geplaatst.</xref:System.Messaging.MessageEnumerator.MoveNext%2A> Een overbelasting met er is geen parameter wordt onmiddellijk geretourneerd als geen berichten meer in de wachtrij zijn.       Nadat deze is gemaakt, een conceptueel enumerator staat voor het eerste bericht van de inventarisatie en de eerste aanroep <xref:System.Messaging.MessageEnumerator.MoveNext%2A>brengt het eerste bericht van de inventarisatie in weergave.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public bool MoveNext (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "De <xref:System.TimeSpan>wachttijd voor een bericht niet beschikbaar als de enumerator bevindt zich aan het einde van de wachtrij.</xref:System.TimeSpan>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de enumerator is voortgezet naar het volgende bericht; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> als de enumerator het einde van de wachtrij bereikt heeft en een bericht is niet beschikbaar is binnen de tijd die is opgegeven door de <code> timeout </code> parameter."
  overload: System.Messaging.MessageEnumerator.MoveNext*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De opgegeven waarde voor de parameter timeout is ongeldig. Er kan geen negatief getal vertegenwoordigen."
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Er is een specifiek zijn voor Message Queuing-uitzondering opgetreden.       - of - de time-out is verlopen."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent
  id: RemoveCurrent
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent()
  nameWithType: MessageEnumerator.RemoveCurrent()
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Hiermee verwijdert u het huidige bericht in een wachtrij transactioneel of niet-transactionele en retourneert het bericht naar de aanroepende toepassing. Er is geen time-out opgegeven voor een bericht moet worden uitgevoerd in de wachtrij."
  remarks: "RemoveCurrent verwijdert en retourneert het bericht op de huidige cursorpositie.       Als u van logboekregistratie in de wachtrij gebruikmaakt, het bericht verwijdert een kopie worden bewaard in de logboekwachtrij, net zoals de <xref:System.Messaging.MessageQueue>van de klasse <xref:System.Messaging.MessageQueue.Receive%2A>webmethode.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Wanneer u het huidige bericht verwijdert, wordt de cursor naar het volgende bericht verplaatst. U hebt niet aan te roepen <xref:System.Messaging.MessageEnumerator.MoveNext%2A>na het aanroepen van RemoveCurrent.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>       Als u deze overbelasting voor een transactionele wachtrij aanroepen, maakt Message Queuing een enkele interne transactie."
  syntax:
    content: public System.Messaging.Message RemoveCurrent ();
    parameters: []
    return:
      type: System.Messaging.Message
      description: "Een <xref href=&quot;System.Messaging.Message&quot;> </xref> dat verwijst naar het eerste bericht beschikbaar in de wachtrij."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)
  id: RemoveCurrent(System.Messaging.MessageQueueTransaction)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent(MessageQueueTransaction)
  nameWithType: MessageEnumerator.RemoveCurrent(MessageQueueTransaction)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(MessageQueueTransaction)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Hiermee verwijdert u het huidige bericht in een transactionele wachtrij en retourneert het bericht naar de aanroepende toepassing. Er is geen time-out opgegeven voor een bericht moet worden uitgevoerd in de wachtrij."
  remarks: "<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>verwijdert en retourneert het bericht op de huidige locatie van de cursor, met behulp van de context van de interne transactie gedefinieerd door de `transaction` parameter.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>       Als u van logboekregistratie in de wachtrij gebruikmaakt, het bericht verwijdert een kopie worden bewaard in de logboekwachtrij, net zoals de <xref:System.Messaging.MessageQueue>van de klasse <xref:System.Messaging.MessageQueue.Receive%2A>webmethode.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Als u werkt met transactionele wachtrijen, terugdraaien van een transactie zorgt ervoor dat alle berichten die zijn verwijderd door een aanroep naar <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>moeten worden geretourneerd naar de wachtrij.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> De verwijdering is niet niet ongedaan worden gemaakt totdat de transactie doorgevoerd is.       Wanneer u het huidige bericht verwijdert, wordt de cursor naar het volgende bericht verplaatst. U hebt niet aanroepen <xref:System.Messaging.MessageEnumerator.MoveNext%2A>na het aanroepen van <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> </xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);
    parameters:
    - id: transaction
      type: System.Messaging.MessageQueueTransaction
      description: "De <xref href=&quot;System.Messaging.MessageQueueTransaction&quot;> </xref> -object dat de transactie waarin het bericht wordt verwijderd."
    return:
      type: System.Messaging.Message
      description: "Een <xref href=&quot;System.Messaging.Message&quot;> </xref> dat verwijst naar het eerste bericht beschikbaar in de wachtrij."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>transaction</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)
  id: RemoveCurrent(System.Messaging.MessageQueueTransactionType)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent(MessageQueueTransactionType)
  nameWithType: MessageEnumerator.RemoveCurrent(MessageQueueTransactionType)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(MessageQueueTransactionType)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Hiermee verwijdert u het huidige bericht in een wachtrij en retourneert het bericht naar de aanroepende toepassing. Er is geen time-out opgegeven voor een bericht moet worden uitgevoerd in de wachtrij."
  remarks: "<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>verwijdert en retourneert het bericht op de huidige locatie van de cursor, met behulp van een transactiecontext die zijn gedefinieerd door de `transactionType` parameter.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>       Geef `Automatic` voor de `transactionType` parameter als er al een externe transactiecontext gekoppeld aan de thread die u wilt gebruiken om het bericht te ontvangen. Geef `Single` als u wilt ontvangen het bericht als een enkele interne transactie. U kunt opgeven `None` als u wilt een bericht ontvangen van een transactionele wachtrij buiten een transactiecontext.       Als u van logboekregistratie in de wachtrij gebruikmaakt, het bericht verwijdert een kopie worden bewaard in de logboekwachtrij, net zoals de <xref:System.Messaging.MessageQueue>van de klasse <xref:System.Messaging.MessageQueue.Receive%2A>webmethode.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Als u werkt met transactionele wachtrijen, terugdraaien van een transactie zorgt ervoor dat alle berichten die zijn verwijderd door een aanroep naar <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>moeten worden geretourneerd naar de wachtrij.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> De verwijdering is niet niet ongedaan worden gemaakt totdat de transactie doorgevoerd is.       Wanneer u het huidige bericht verwijdert, wordt de cursor naar het volgende bericht verplaatst. U hebt niet aanroepen <xref:System.Messaging.MessageEnumerator.MoveNext%2A>na het aanroepen van <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> </xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);
    parameters:
    - id: transactionType
      type: System.Messaging.MessageQueueTransactionType
      description: "Een van de <xref href=&quot;System.Messaging.MessageQueueTransactionType&quot;> </xref> waarden, de beschrijving van het type van de transactiecontext koppelen aan het bericht."
    return:
      type: System.Messaging.Message
      description: "Een <xref href=&quot;System.Messaging.Message&quot;> </xref> dat verwijst naar het eerste bericht beschikbaar in de wachtrij."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "De <code> transactionType </code> parameter is niet een van de <xref href=&quot;System.Messaging.MessageQueueTransactionType&quot;> </xref> leden."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)
  id: RemoveCurrent(System.TimeSpan)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent(TimeSpan)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Hiermee verwijdert u het huidige bericht uit de wachtrij en retourneert het bericht naar de aanroepende toepassing. Als er een bericht te verwijderen, retourneert de methode deze onmiddellijk. De methode wacht anders de opgegeven time-out voor een nieuw bericht moet worden uitgevoerd."
  remarks: "<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>verwijdert en retourneert het bericht op de huidige cursorpositie.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Als de cursor zich aan het einde van de wachtrij, deze overbelasting van de methode wacht totdat een bericht beschikbaar is of het interval opgegeven door de `timeout` parameter is verlopen.       Als u van logboekregistratie in de wachtrij gebruikmaakt, het bericht verwijdert een kopie worden bewaard in de logboekwachtrij, net zoals de <xref:System.Messaging.MessageQueue>van de klasse <xref:System.Messaging.MessageQueue.Receive%2A>webmethode.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Wanneer u het huidige bericht verwijdert, wordt de cursor naar het volgende bericht verplaatst. U hebt niet aanroepen <xref:System.Messaging.MessageEnumerator.MoveNext%2A>na het aanroepen van <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> </xref:System.Messaging.MessageEnumerator.MoveNext%2A>       Als u deze overbelasting voor een transactionele wachtrij aanroepen, maakt Message Queuing een enkele interne transactie."
  syntax:
    content: public System.Messaging.Message RemoveCurrent (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Het interval van de wachttijd voor een bericht moet worden uitgevoerd in de wachtrij."
    return:
      type: System.Messaging.Message
      description: "Een <xref href=&quot;System.Messaging.Message&quot;> </xref> dat verwijst naar het eerste bericht beschikbaar in de wachtrij."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De opgegeven waarde voor de <code> timeout </code> parameter is ongeldig."
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "De time-out is verlopen."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)
  id: RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent(TimeSpan,MessageQueueTransaction)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransaction)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransaction)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Hiermee verwijdert u het huidige bericht in een transactionele wachtrij en retourneert het bericht naar de aanroepende toepassing. Als er een bericht te verwijderen, retourneert de methode deze onmiddellijk. De methode wacht anders de opgegeven time-out voor een nieuw bericht moet worden uitgevoerd."
  remarks: "<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>verwijdert en retourneert het bericht op de huidige cursorpositie.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Als de cursor zich aan het einde van de wachtrij, deze overbelasting van de methode wacht totdat een bericht beschikbaar is of het interval opgegeven door de `timeout` parameter is verlopen.       Als u werkt met transactionele wachtrijen, terugdraaien van een transactie zorgt ervoor dat alle berichten die zijn verwijderd door een aanroep naar <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>moeten worden geretourneerd naar de wachtrij.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> De verwijdering is niet niet ongedaan worden gemaakt totdat de transactie doorgevoerd is.       Als u van logboekregistratie in de wachtrij gebruikmaakt, het bericht verwijdert een kopie worden bewaard in de logboekwachtrij, net zoals de <xref:System.Messaging.MessageQueue>van de klasse <xref:System.Messaging.MessageQueue.Receive%2A>webmethode.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Wanneer u het huidige bericht verwijdert, wordt de cursor naar het volgende bericht verplaatst. U hebt niet aanroepen <xref:System.Messaging.MessageEnumerator.MoveNext%2A>na het aanroepen van <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> </xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Het interval van de wachttijd voor het bericht moet worden verwijderd."
    - id: transaction
      type: System.Messaging.MessageQueueTransaction
      description: "De <xref href=&quot;System.Messaging.MessageQueueTransaction&quot;> </xref> -object dat de transactiecontext van het bericht aangeeft."
    return:
      type: System.Messaging.Message
      description: "Een <xref href=&quot;System.Messaging.Message&quot;> </xref> dat verwijst naar het eerste bericht beschikbaar in de wachtrij."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De opgegeven waarde voor de <code> timeout </code> parameter is ongeldig."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>transaction</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "De time-out is verlopen."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)
  id: RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent(TimeSpan,MessageQueueTransactionType)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransactionType)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransactionType)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Hiermee verwijdert u het huidige bericht in een wachtrij en retourneert het bericht naar de aanroepende toepassing. Als er een bericht te verwijderen, retourneert de methode deze onmiddellijk. De methode wacht anders de opgegeven time-out voor een nieuw bericht moet worden uitgevoerd."
  remarks: "<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>verwijdert en retourneert het bericht op de huidige locatie van de cursor, met behulp van een transactiecontext die zijn gedefinieerd door de `transactionType` parameter.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Als de cursor zich aan het einde van de wachtrij, deze overbelasting van de methode wacht totdat een bericht beschikbaar is of het interval opgegeven door de `timeout` parameter is verlopen.       Geef `Automatic` voor de `transactionType` parameter als er al een externe transactiecontext gekoppeld aan de thread die u wilt gebruiken om het bericht te ontvangen. Geef `Single` als u wilt ontvangen het bericht als een enkele interne transactie. U kunt opgeven `None` als u wilt een bericht ontvangen van een transactionele wachtrij buiten een transactiecontext.       Als u van logboekregistratie in de wachtrij gebruikmaakt, het bericht verwijdert een kopie worden bewaard in de logboekwachtrij, net zoals de <xref:System.Messaging.MessageQueue>van de klasse <xref:System.Messaging.MessageQueue.Receive%2A>webmethode.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Als u werkt met transactionele wachtrijen, terugdraaien van een transactie zorgt ervoor dat alle berichten die zijn verwijderd door een aanroep naar <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>moeten worden geretourneerd naar de wachtrij.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> De verwijdering is niet niet ongedaan worden gemaakt totdat de transactie doorgevoerd is.       Wanneer u het huidige bericht verwijdert, wordt de cursor naar het volgende bericht verplaatst. U hebt niet aanroepen <xref:System.Messaging.MessageEnumerator.MoveNext%2A>na het aanroepen van <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> </xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Het interval van de wachttijd voor het bericht moet worden verwijderd."
    - id: transactionType
      type: System.Messaging.MessageQueueTransactionType
      description: "Een van de <xref href=&quot;System.Messaging.MessageQueueTransactionType&quot;> </xref> waarden, de beschrijving van het type van de transactiecontext koppelen aan het bericht."
    return:
      type: System.Messaging.Message
      description: "Een <xref href=&quot;System.Messaging.Message&quot;> </xref> dat verwijst naar het eerste bericht beschikbaar in de wachtrij."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De opgegeven waarde voor de <code> timeout </code> parameter is ongeldig."
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "De time-out is verlopen."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "De <code> transactionType </code> parameter is niet een van de <xref href=&quot;System.Messaging.MessageQueueTransactionType&quot;> </xref> leden."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.Reset
  id: Reset
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: Reset()
  nameWithType: MessageEnumerator.Reset()
  fullName: System.Messaging.MessageEnumerator.Reset()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Hiermee stelt u de huidige enumerator zodat deze naar de kop van de wachtrij verwijst."
  remarks: "Een enumerator kan alleen een vooruit verplaatsen. Gebruik deze methode te beginnen aan het begin van de wachtrij.       Na het opnieuw instellen wordt aangeroepen, wordt de cursor verwijst naar het eerste bericht. U hoeft niet aan te roepen <xref:System.Messaging.MessageEnumerator.MoveNext%2A>na het opnieuw instellen voor het verplaatsen van de cursor wordt aangeroepen door te sturen naar het eerste bericht in de wachtrij.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public void Reset ();
    parameters: []
  overload: System.Messaging.MessageEnumerator.Reset*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current
  id: System#Collections#IEnumerator#Current
  isEii: true
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: System.Collections.IEnumerator.Current
  nameWithType: MessageEnumerator.System.Collections.IEnumerator.Current
  fullName: System.Messaging.MessageEnumerator.System.Collections.IEnumerator.Current
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Retourneert een <xref href=&quot;System.Messaging.Message&quot;> </xref> dat verwijst naar het bericht op de cursorpositie."
  syntax:
    content: object System.Collections.IEnumerator.Current { get; }
    return:
      type: System.Object
      description: "Een <xref href=&quot;System.Messaging.Message&quot;> </xref> dat verwijst naar het bericht op de cursorpositie."
  overload: System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current*
  exceptions: []
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Messaging.MessageQueueException
  parent: System.Messaging
  isExternal: false
  name: MessageQueueException
  nameWithType: MessageQueueException
  fullName: System.Messaging.MessageQueueException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Messaging.MessageEnumerator.Close
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Close()
  nameWithType: MessageEnumerator.Close()
  fullName: System.Messaging.MessageEnumerator.Close()
- uid: System.Messaging.MessageEnumerator.Current
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Current
  nameWithType: MessageEnumerator.Current
  fullName: System.Messaging.MessageEnumerator.Current
- uid: System.Messaging.Message
  parent: System.Messaging
  isExternal: false
  name: Message
  nameWithType: Message
  fullName: System.Messaging.Message
- uid: System.Messaging.MessageEnumerator.CursorHandle
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: CursorHandle
  nameWithType: MessageEnumerator.CursorHandle
  fullName: System.Messaging.MessageEnumerator.CursorHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Messaging.MessageEnumerator.Dispose
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Dispose()
  nameWithType: MessageEnumerator.Dispose()
  fullName: System.Messaging.MessageEnumerator.Dispose()
- uid: System.Messaging.MessageEnumerator.Dispose(System.Boolean)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: MessageEnumerator.Dispose(Boolean)
  fullName: System.Messaging.MessageEnumerator.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Messaging.MessageEnumerator.MoveNext
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: MoveNext()
  nameWithType: MessageEnumerator.MoveNext()
  fullName: System.Messaging.MessageEnumerator.MoveNext()
- uid: System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: MoveNext(TimeSpan)
  nameWithType: MessageEnumerator.MoveNext(TimeSpan)
  fullName: System.Messaging.MessageEnumerator.MoveNext(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Messaging.MessageEnumerator.RemoveCurrent
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent()
  nameWithType: MessageEnumerator.RemoveCurrent()
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent()
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent(MessageQueueTransaction)
  nameWithType: MessageEnumerator.RemoveCurrent(MessageQueueTransaction)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(MessageQueueTransaction)
- uid: System.Messaging.MessageQueueTransaction
  parent: System.Messaging
  isExternal: false
  name: MessageQueueTransaction
  nameWithType: MessageQueueTransaction
  fullName: System.Messaging.MessageQueueTransaction
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent(MessageQueueTransactionType)
  nameWithType: MessageEnumerator.RemoveCurrent(MessageQueueTransactionType)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(MessageQueueTransactionType)
- uid: System.Messaging.MessageQueueTransactionType
  parent: System.Messaging
  isExternal: false
  name: MessageQueueTransactionType
  nameWithType: MessageQueueTransactionType
  fullName: System.Messaging.MessageQueueTransactionType
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent(TimeSpan)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan)
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent(TimeSpan,MessageQueueTransaction)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransaction)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransaction)
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent(TimeSpan,MessageQueueTransactionType)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransactionType)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransactionType)
- uid: System.Messaging.MessageEnumerator.Reset
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Reset()
  nameWithType: MessageEnumerator.Reset()
  fullName: System.Messaging.MessageEnumerator.Reset()
- uid: System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: System.Collections.IEnumerator.Current
  nameWithType: MessageEnumerator.System.Collections.IEnumerator.Current
  fullName: System.Messaging.MessageEnumerator.System.Collections.IEnumerator.Current
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Messaging.MessageEnumerator.Close*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Close
  nameWithType: MessageEnumerator.Close
- uid: System.Messaging.MessageEnumerator.Current*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Current
  nameWithType: MessageEnumerator.Current
- uid: System.Messaging.MessageEnumerator.CursorHandle*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: CursorHandle
  nameWithType: MessageEnumerator.CursorHandle
- uid: System.Messaging.MessageEnumerator.Dispose*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Dispose
  nameWithType: MessageEnumerator.Dispose
- uid: System.Messaging.MessageEnumerator.MoveNext*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: MoveNext
  nameWithType: MessageEnumerator.MoveNext
- uid: System.Messaging.MessageEnumerator.RemoveCurrent*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent
  nameWithType: MessageEnumerator.RemoveCurrent
- uid: System.Messaging.MessageEnumerator.Reset*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Reset
  nameWithType: MessageEnumerator.Reset
- uid: System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: System.Collections.IEnumerator.Current
  nameWithType: MessageEnumerator.System.Collections.IEnumerator.Current
