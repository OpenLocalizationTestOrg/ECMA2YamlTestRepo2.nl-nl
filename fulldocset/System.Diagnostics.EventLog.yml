### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.EventLog
  id: EventLog
  children:
  - System.Diagnostics.EventLog.#ctor
  - System.Diagnostics.EventLog.#ctor(System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.BeginInit
  - System.Diagnostics.EventLog.Clear
  - System.Diagnostics.EventLog.Close
  - System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.Delete(System.String)
  - System.Diagnostics.EventLog.Delete(System.String,System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.Dispose(System.Boolean)
  - System.Diagnostics.EventLog.EnableRaisingEvents
  - System.Diagnostics.EventLog.EndInit
  - System.Diagnostics.EventLog.Entries
  - System.Diagnostics.EventLog.EntryWritten
  - System.Diagnostics.EventLog.Exists(System.String)
  - System.Diagnostics.EventLog.Exists(System.String,System.String)
  - System.Diagnostics.EventLog.GetEventLogs
  - System.Diagnostics.EventLog.GetEventLogs(System.String)
  - System.Diagnostics.EventLog.Log
  - System.Diagnostics.EventLog.LogDisplayName
  - System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  - System.Diagnostics.EventLog.MachineName
  - System.Diagnostics.EventLog.MaximumKilobytes
  - System.Diagnostics.EventLog.MinimumRetentionDays
  - System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  - System.Diagnostics.EventLog.OverflowAction
  - System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  - System.Diagnostics.EventLog.Source
  - System.Diagnostics.EventLog.SourceExists(System.String)
  - System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  - System.Diagnostics.EventLog.SynchronizingObject
  - System.Diagnostics.EventLog.WriteEntry(System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  langs:
  - csharp
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
  type: Class
  summary: "Hiermee wordt interactie met Windows-gebeurtenislogboeken."
  remarks: "EventLog kunt u toegang tot of het Windows-gebeurtenislogboeken, informatie over belangrijke gebeurtenissen van software of hardware record aanpassen. EventLog gebruikt, kunt u lezen uit bestaande logboeken, vermeldingen geregistreerd in de logboeken, maken of verwijderen van bronnen van gebeurtenissen, logboeken verwijderen en logboekvermeldingen reageren op. U kunt ook nieuwe logboeken maken bij het maken van een gebeurtenisbron.      > [!IMPORTANT] > Dit type implementeert de <xref:System.IDisposable>interface.</xref:System.IDisposable> Wanneer u klaar bent met het type, moet u beschikken over het direct of indirect. Aanroepen voor het rechtstreeks verwijderen van het type ervan <xref:System.IDisposable.Dispose%2A>methode in een `try` / `catch` blok.</xref:System.IDisposable.Dispose%2A> Gebruiken om de buitengebruikstelling van het indirect, een taal constructie zoals `using` (in C#) of `Using` (in Visual Basic). Zie voor meer informatie de sectie &quot;Met behulp van een Object dat wordt geïmplementeerd IDisposable&quot; in de <xref:System.IDisposable>interface onderwerp.</xref:System.IDisposable>       Naast het bieden van toegang tot afzonderlijke gebeurtenislogboeken en hun vermeldingen in kunt de EventLog-klasse u toegang tot de verzameling van alle gebeurtenislogboeken. U kunt de `static` leden van het gebeurtenislogboek om te verwijderen van Logboeken, het logboek lijsten ophalen, maken of verwijderen van een bron of bepalen of een computer al een bepaalde bron bevat.       Er zijn drie standaard gebeurtenislogboeken: toepassing, systeem en beveiliging. Een beveiligingslogboek is alleen-lezen. Andere toepassingen en services die u hebt geïnstalleerd, zoals Active Directory, wellicht aanvullende gebeurtenislogboeken.       Er zijn beveiligingsoverwegingen bij gebruik van de EventLog-klasse. EventLog vereist <xref:System.Diagnostics.EventLogPermission>machtigingen voor specifieke acties in de .NET Framework 2.0 en nieuwere versies of volledig vertrouwen in .NET Framework 1.0 en 1.1.</xref:System.Diagnostics.EventLogPermission> We raden aan dat <xref:System.Diagnostics.EventLogPermission>niet worden toegekend aan gedeeltelijk vertrouwde code.</xref:System.Diagnostics.EventLogPermission>  U moet nooit een gebeurtenislogboek-object doorgeven inclusief <xref:System.Diagnostics.EventLogEntryCollection>en <xref:System.Diagnostics.EventLogEntry>objecten minder vertrouwde code.</xref:System.Diagnostics.EventLogEntry> </xref:System.Diagnostics.EventLogEntryCollection> Bijvoorbeeld, kunt een EventLog-object maken en vervolgens het doorgeven van het gebeurtenislogboek schrijven van gegevens gedeeltelijk vertrouwde code-object maken een beveiligingsprobleem omdat de mogelijkheid om te lezen en schrijven naar het gebeurtenislogboek kunt code voor het uitvoeren van acties zoals het uitgeven van gebeurtenislogboekberichten naam van een andere toepassing.       Gebruikersaccountbeheer (UAC) is vanaf Windows Vista, bepaalt de referenties van een gebruiker. Als u lid zijn van de ingebouwde groep Administrators, kunt u twee runtime-toegangstokens zijn toegewezen: een standaardgebruikerstoegang en een token voor beheerderstoegang. U bent standaard in de standaard gebruikersrol. De code die toegang heeft tot het beveiligingslogboek uitvoeren, moet u eerst uw referenties van standaardgebruiker uitbreiden naar de beheerder. U kunt dit doen wanneer u een toepassing starten via het snelmenu voor de toepassing (als u een muis gebruikt, met de rechtermuisknop op het toepassingspictogram) en die aangeeft dat u wilt uitvoeren als beheerder.       U kunt EventLog gebruiken voor het maken van aangepaste logboeken die u met behulp van Logboeken van de server bekijken kunt. Gebruik de <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>methode om een gelokaliseerde naam voor uw logboek in logboeken weer te geven.</xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> Gebruik de <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>methode voor het configureren van het gedrag van het gebeurtenislogboek, wanneer het de maximale logboekgrootte is bereikt.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       Als u wilt lezen uit een gebeurtenislogboek, geef de naam van het logboek (<xref:System.Diagnostics.EventLog.Log%2A> eigenschap) en de computernaam van de server (<xref:System.Diagnostics.EventLog.MachineName%2A> eigenschap voor het gebeurtenissenlogboek.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Als u de servernaam, de lokale computer niet opgeeft &quot;. &quot;, wordt uitgegaan. Het is niet nodig om op te geven van de gebeurtenisbron (<xref:System.Diagnostics.EventLog.Source%2A> eigenschap), omdat een bron alleen vereist is voor schrijven naar de logboeken.</xref:System.Diagnostics.EventLog.Source%2A> De <xref:System.Diagnostics.EventLog.Entries%2A>eigenschap wordt automatisch gevuld met de lijst met vermeldingen van het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.Entries%2A>       Voor het schrijven naar een gebeurtenislogboek, Geef op of maak een gebeurtenisbron (<xref:System.Diagnostics.EventLog.Source%2A> eigenschap).</xref:System.Diagnostics.EventLog.Source%2A> U moet beheerdersreferenties hebben op de computer voor het maken van een nieuwe gebeurtenisbron. De gebeurtenisbron registreert uw toepassing met het gebeurtenislogboek als een geldige bron vermeldingen. U kunt de gebeurtenisbron tegelijk naar slechts één logboek schrijven. De <xref:System.Diagnostics.EventLog.Source%2A>eigenschap kan een willekeurige tekenreeks op, maar de naam moet verschillen van de andere bronnen op de computer.</xref:System.Diagnostics.EventLog.Source%2A> De gebeurtenisbron is doorgaans de naam van de toepassing of een andere id-tekenreeks. Bij het maken van een duplicaat <xref:System.Diagnostics.EventLog.Source%2A>waarde er een uitzondering gegenereerd.</xref:System.Diagnostics.EventLog.Source%2A> Een afzonderlijk gebeurtenislogboek kan echter zijn gekoppeld aan meerdere bronnen.       Als de gegevensbron voor het gebeurtenislogboek die zijn gekoppeld aan het EventLog-exemplaar niet bestaat, wordt een nieuwe gebeurtenisbron gemaakt. U moet beheerdersreferenties hebben voor het maken van een gebeurtenisbron in Windows Vista en hoger of Windows Server 2003.       Deze vereiste is, omdat alle gebeurtenislogboeken beveiligingslogboeken, inclusief moet worden gezocht om te bepalen of de gebeurtenisbron uniek is. Vanaf Windows Vista, hebben gebruikers geen toestemming voor toegang tot het beveiligingslogboek; daarom een <xref:System.Security.SecurityException>gegenereerd.</xref:System.Security.SecurityException>      > [!IMPORTANT] > Maken of verwijderen van een gebeurtenisbron vereist synchronisatie van de onderliggende code met behulp van een benoemde mutex. Als een toepassing met bijzondere rechten Hiermee vergrendelt u de benoemde mutex, probeert te maken of verwijderen van een gebeurtenisbron zorgt ervoor dat de toepassing reageert totdat de vergrendeling wordt vrijgegeven. Om te voorkomen dat dit probleem, nooit verlenen <xref:System.Security.Permissions.SecurityPermissionFlag>machtiging voor niet-vertrouwde code.</xref:System.Security.Permissions.SecurityPermissionFlag> Bovendien <xref:System.Security.Permissions.SecurityPermissionFlag>machtiging mogelijk kunnen andere machtigingen moeten worden overgeslagen en moet alleen worden verleend aan uiterst vertrouwde code.</xref:System.Security.Permissions.SecurityPermissionFlag>       Toepassingen en services moeten schrijven naar het toepassingslogboek of naar een aangepast logboek. Apparaatstuurprogramma&quot;s te schrijven naar het systeemlogboek. Als u de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap, de standaardinstellingen van het gebeurtenislogboek wordt geschreven naar het toepassingslogboek.</xref:System.Diagnostics.EventLog.Log%2A> niet expliciet ingesteld      > [!NOTE] > Er is niets om te voorkomen dat een toepassing schrijven als een geregistreerde bron.  Als een toepassing wordt verleend <xref:System.Diagnostics.EventLogPermissionAccess>toestemming hebben, kan deze gebeurtenissen voor een geldige bron geregistreerd op de computer schrijven.</xref:System.Diagnostics.EventLogPermissionAccess>       Gebruik de <xref:System.Diagnostics.EventLog.WriteEvent%2A>en <xref:System.Diagnostics.EventLog.WriteEntry%2A>methoden voor het schrijven van gebeurtenissen naar een gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.WriteEvent%2A> U moet een gebeurtenisbron voor het schrijven van gebeurtenissen; opgeven u moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven.       Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als de lijst met bronnen van gebeurtenissen is niet vernieuwd door het besturingssysteem is geïnstalleerd en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron configureren met behulp van een <xref:System.Diagnostics.EventLogInstaller>object of de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersreferenties hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       Elke bron kan naar slechts één gebeurtenislogboek schrijven tegelijk; uw toepassing kunt gebruiken, meerdere bronnen naar meerdere gebeurtenislogboeken te schrijven. Uw toepassing moet mogelijk meerdere bronnen die zijn geconfigureerd voor verschillende gebeurtenislogboeken of bestanden andere resource. Om de configuratiedetails van een bestaande gegevensbron wijzigt, moet u de bron verwijderen en vervolgens te maken met de nieuwe configuratie. Als andere toepassingen of onderdelen gebruikt de bestaande bron, maakt u een nieuwe bron met de bijgewerkte configuratie in plaats van de bestaande bron verwijderen.       U kunt de gebeurtenisbron registreren met de gelokaliseerde hulpbronnen voor de gebeurtenis categorie en bericht-tekenreeksen. Uw toepassing kunt logboekvermeldingen schrijven met behulp van de resource-id in plaats van de werkelijke string-waarden opgeven. Raadpleeg de <xref:System.Diagnostics.EventLogInstaller>en <xref:System.Diagnostics.EventSourceCreationData>klassen voor meer informatie over het configureren van de bron met de bronbestanden.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Als uw toepassing tekenreekswaarden rechtstreeks naar het gebeurtenislogboek schrijft, hoeft u niet de bron bestandseigenschappen instellen voor de bron. De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Bij het schrijven van gebeurtenissen, moet u ten minste een tekenreeks voor het bericht of de resource-id voor een bericht tekenreeks opgeven. Andere eigenschappen van gebeurtenis zijn optioneel. Voorbeelden van optionele gebeurtenisinstellingen omvatten het volgende:-u kunt instellen de <xref:System.Diagnostics.EventLogEntryType>opgeven welk pictogram die door de Event Viewer voor de vermelding weergegeven.</xref:System.Diagnostics.EventLogEntryType>      -U kunt een categorie-id voor de gebeurtenis opgeven als uw toepassing gebruikmaakt van categorieën voor het filteren van de gebeurtenissen.      -U kunt binaire gegevens koppelen aan uw gebeurtenis als u wilt koppelen aan een bepaalde gebeurtenis als u meer informatie.      > [!IMPORTANT] > Logboekregistratie schijfruimte, processortijd en andere systeembronnen verbruikt. Het is belangrijk om alleen essentiële informatie te registreren. U wordt aangeraden dat u gesprekken gebeurtenislogboek in een foutbestand plaats in het pad van de hoofdassembly met code, zodat ze niet nadelig beïnvloeden.       Zie voor een lijst met eerste eigenschapswaarden voor een exemplaar van het gebeurtenislogboek, de <xref:System.Diagnostics.EventLog.%23ctor%2A>constructor.</xref:System.Diagnostics.EventLog.%23ctor%2A>"
  example:
  - "The following example creates the event source `MySource` if it doesn't already exist, and writes an entry to the event log `MyNewLog`.  \n  \n> [!NOTE]\n>  Starting with Windows Vista, you must run this application as an administrator.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/t-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/t-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/t-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("EntryWritten")]

      [System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("EventLogDesc")]

      public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor
  id: '#ctor'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> klasse. Heeft het exemplaar niet koppelen aan een logboek."
  remarks: "Voordat u <xref:System.Diagnostics.EventLog.WriteEntry%2A>, geef de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap van de <xref:System.Diagnostics.EventLog>exemplaar.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Als u alleen leest <xref:System.Diagnostics.EventLog.Entries%2A>uit het logboek, kunt u ook opgeven alleen de <xref:System.Diagnostics.EventLog.Log%2A>en <xref:System.Diagnostics.EventLog.MachineName%2A>Eigenschappen.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Als u geen opgeeft een <xref:System.Diagnostics.EventLog.MachineName%2A>, de lokale computer (&quot;. &quot;) wordt verondersteld.</xref:System.Diagnostics.EventLog.MachineName%2A>       De volgende tabel toont de eerste waarden voor een exemplaar van <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Eigenschap | Initiële waarde |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Een lege tekenreeks (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| Een lege tekenreeks (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.MachineName%2A>| De lokale computer (&quot;. &quot;). |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_9_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_9_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_9_1.vb)]"
  syntax:
    content: public EventLog ();
    parameters: []
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> klasse. Het exemplaar koppelt aan een logboekbestand op de lokale computer."
  remarks: "Hiermee stelt u deze overbelasting de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap in op de `logName` parameter.</xref:System.Diagnostics.EventLog.Log%2A> Voordat u <xref:System.Diagnostics.EventLog.WriteEntry%2A>, geef de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap van de <xref:System.Diagnostics.EventLog>exemplaar.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Als u alleen leest <xref:System.Diagnostics.EventLog.Entries%2A>uit het logboek, kunt u ook opgeven alleen de <xref:System.Diagnostics.EventLog.Log%2A>en <xref:System.Diagnostics.EventLog.MachineName%2A>Eigenschappen.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Als u geen opgeeft een <xref:System.Diagnostics.EventLog.MachineName%2A>, de lokale computer (&quot;. &quot;) wordt verondersteld.</xref:System.Diagnostics.EventLog.MachineName%2A> Deze overbelasting van de constructor Hiermee geeft u de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap, maar u kunt dit wijzigen voordat er wordt gelezen de <xref:System.Diagnostics.EventLog.Entries%2A>eigenschap.</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.Log%2A>       Als de bron die u opgeeft in de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap uit andere bronnen op de computer, een volgende aanroep is uniek <xref:System.Diagnostics.EventLog.WriteEntry%2A>wordt een logboekbestand gemaakt met de opgegeven naam, als deze niet al bestaat.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>       De volgende tabel toont de eerste waarden voor een exemplaar van <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Eigenschap | Initiële waarde |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Een lege tekenreeks (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| De `logName` parameter. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| De lokale computer (&quot;. &quot;). |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_13_1.cpp)]\n [!code-cs[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_13_1.cs)]\n [!code-vb[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_13_1.vb)]"
  syntax:
    content: public EventLog (string logName);
    parameters:
    - id: logName
      type: System.String
      description: "De naam van het logboek op de lokale computer."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Naam van het logboek is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Naam van het logboek is ongeldig."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> klasse. Het exemplaar koppelt aan een logboekbestand op de opgegeven computer."
  remarks: "Hiermee stelt u deze overbelasting de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap in op de `logName` parameter en de <xref:System.Diagnostics.EventLog.MachineName%2A>eigenschap in op de `machineName` parameter.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Voordat u aanroept <xref:System.Diagnostics.EventLog.WriteEntry%2A>, geeft u de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap van het <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Als u alleen leest <xref:System.Diagnostics.EventLog.Entries%2A>uit het logboek, kunt u ook opgeven alleen de <xref:System.Diagnostics.EventLog.Log%2A>en <xref:System.Diagnostics.EventLog.MachineName%2A>Eigenschappen.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Deze overbelasting van de constructor Hiermee geeft u de <xref:System.Diagnostics.EventLog.Log%2A>en <xref:System.Diagnostics.EventLog.MachineName%2A>Eigenschappen, maar u kunt ofwel voordat er wordt gelezen wijzigen de <xref:System.Diagnostics.EventLog.Entries%2A>eigenschap.</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>       De volgende tabel toont de eerste waarden voor een exemplaar van <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Eigenschap | Initiële waarde |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Een lege tekenreeks (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| De `logName` parameter. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| De `machineName` parameter. |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the computer \"myServer\".  \n  \n [!code-cs[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: "De naam van het logboek op de opgegeven computer."
    - id: machineName
      type: System.String
      description: "De computer waarop het logboek bestaat."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Naam van het logboek is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Naam van het logboek is ongeldig.       - of - naam van de computer is ongeldig."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  id: '#ctor(System.String,System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> klasse. Het exemplaar worden gekoppeld aan een logboekbestand op de opgegeven computer en maakt of toewijst van de opgegeven bron voor de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>."
  remarks: "Hiermee stelt u deze constructor de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap in op de `logName` parameter, de <xref:System.Diagnostics.EventLog.MachineName%2A>eigenschap in op de `machineName` parameter, en de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap in op de `source` parameter.</xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> De <xref:System.Diagnostics.EventLog.Source%2A>eigenschap is vereist bij het schrijven naar een gebeurtenislogboek.</xref:System.Diagnostics.EventLog.Source%2A> Echter, als u alleen lezen van een gebeurtenislogboek, alleen de <xref:System.Diagnostics.EventLog.Log%2A>en <xref:System.Diagnostics.EventLog.MachineName%2A>eigenschappen vereist zijn (zo lang het gebeurtenislogboek op de server heeft een bron die reeds gekoppeld).</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Als u alleen lezen van het gebeurtenislogboek, kan een andere overload van de constructor voldoende.       De volgende tabel toont de eerste waarden voor een exemplaar van <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Eigenschap | Initiële waarde |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| De `source` parameter. |   | <xref:System.Diagnostics.EventLog.Log%2A>| De `logName` parameter. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| De `machineName` parameter. |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example writes an entry to an event log, \"MyNewLog\", on the local computer, using the source \"MySource\".  \n  \n [!code-cs[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/csharp/fd99d44e-2d79-45f8-97e3-_1.cs)]\n [!code-cpp[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/cpp/fd99d44e-2d79-45f8-97e3-_1.cpp)]\n [!code-vb[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/visualbasic/fd99d44e-2d79-45f8-97e3-_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName, string source);
    parameters:
    - id: logName
      type: System.String
      description: "De naam van het logboek op de opgegeven computer"
    - id: machineName
      type: System.String
      description: "De computer waarop het logboek bestaat."
    - id: source
      type: System.String
      description: "De bron van de vermeldingen in gebeurtenislogboeken."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Naam van het logboek is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Naam van het logboek is ongeldig.       - of - naam van de computer is ongeldig."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.BeginInit
  id: BeginInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "De initialisatie van begint een <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> gebruikt op een formulier of gebruikt door een ander onderdeel. De initialisatie van deze gebeurtenis treedt op tijdens runtime."
  remarks: "De [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] ontwerp omgeving maakt gebruik van deze methode voor het starten van de initialisatie van een onderdeel dat wordt gebruikt op een formulier of een ander onderdeel. De <xref:System.Diagnostics.EventLog.EndInit%2A>methode eindigt de initialisatie.</xref:System.Diagnostics.EventLog.EndInit%2A> Met behulp van de BeginInit en <xref:System.Diagnostics.EventLog.EndInit%2A>methoden voorkomen dat het besturingselement wordt gebruikt voordat deze volledig is geïnitialiseerd.</xref:System.Diagnostics.EventLog.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.BeginInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>is al geïnitialiseerd."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Clear
  id: Clear
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee verwijdert u alle vermeldingen uit het gebeurtenislogboek."
  remarks: "Logboeken worden ingesteld met een maximale grootte die bepaalt hoeveel vermeldingen die ze kunnen bevatten. Wanneer een gebeurtenislogboek vol is, stopt met het opnemen van informatie over de nieuwe gebeurtenis of begint met het overschrijven van eerdere vermeldingen. Als de registratie van de gebeurtenis is gestopt, kunt u deze methode gebruiken om te wissen van het logboek van bestaande gegevens en toe te staan om gebeurtenissen van de opname opnieuw starten. U moet beheerdersmachtigingen voor de computer waarop het logboek om te wissen logboekvermeldingen zich bevindt.       Schakel sluit u het gebeurtenislogboek, de ingangen gebeurtenis vrijgegeven haalt nieuwe lezen en schrijven ingangen, en opent u het gebeurtenislogboek opnieuw. Gebeurtenissen ontvangen na de aanroep van de methode samen met de huidige gebeurtenissen niet gewist."
  example:
  - "The following example clears an event log.  \n  \n> [!CAUTION]\n>  Because Application, System, Security, and other non-custom logs can contain crucial information; be sure to specify a custom log before executing this example code. This example deletes the custom log `myNewLog`.  \n  \n [!code-cs[Classic EventLog.Clear Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_11_1.cs)]\n [!code-vb[Classic EventLog.Clear Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_11_1.vb)]\n [!code-cpp[Classic EventLog.Clear Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_11_1.cpp)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Diagnostics.EventLog.Clear*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het gebeurtenislogboek is niet gewist.       - of - het logboek kan niet worden geopend. Een Windows-foutcode is niet beschikbaar."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Is geen waarde opgegeven voor de <xref:System.Diagnostics.EventLog.Log*>eigenschap.</xref:System.Diagnostics.EventLog.Log*> Zorg ervoor dat de dat naam van het logboek is niet een lege tekenreeks."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het logboek bestaat niet."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Close
  id: Close
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Sluit het gebeurtenislogboek en releases lezen en schrijven verwerkt."
  remarks: "De methode Close is aangeroepen door de beveiligde <xref:System.ComponentModel.Component.Dispose%2A>methode.</xref:System.ComponentModel.Component.Dispose%2A> U hoeft niet sluiten voordat u <xref:System.ComponentModel.Component.Dispose%2A>.</xref:System.ComponentModel.Component.Dispose%2A> aanroepen"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.EventLog.Close*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het gebeurtenislogboek lezen ingang of schrijven ingang is niet is vrijgegeven."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  id: CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een geldig gebeurtenisbron voor het schrijven van gelokaliseerde gebeurtenis vaststelt berichten, met behulp van de opgegeven configuratie-eigenschappen voor de gebeurtenisbron en de bijbehorende gebeurtenislogboek."
  remarks: "Use this overload to configure a new source for writing entries to an event log on the local computer or a remote computer. It is not necessary to use this method to read from an event log.  \n  \n The CreateEventSource method uses the input `sourceData`<xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> and <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> properties to create registry values on the target computer for the new source and its associated event log. A new source name cannot match an existing source name or an existing event log name on the target computer. If the <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> property is not set, the source is registered for the Application event log. If the <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> is not set, the source is registered on the local computer.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  Starting with Windows Vista, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n Each source can only write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n You can register the event source with localized resource file(s) for your event category and message strings. Your application can write event log entries using resource identifiers, rather than specifying the actual string. The Event Viewer uses the resource identifier to find and display the corresponding string from the localized resource file based on current language settings. You can register a separate file for event categories, messages and parameter insertion strings, or you can register the same resource file for all three types of strings. Use the <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, and <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> properties to configure the source to write localized entries to the event log. If your application writes strings values directly to the event log, you do not need to set these properties.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source is configured for an event log, and you reconfigure it for another event log, you must restart the computer for the changes to take effect."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/4fd418fb-73e7-42a9-9ba2-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/4fd418fb-73e7-42a9-9ba2-_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/4fd418fb-73e7-42a9-9ba2-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);
    parameters:
    - id: sourceData
      type: System.Diagnostics.EventSourceCreationData
      description: "De configuratie-eigenschappen voor de gebeurtenisbron en de doel-gebeurtenislogboek."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The computer name specified in <code>sourceData</code> is not valid.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid. Event log names must consist of printable characters and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid for user log creation. The Event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of the log name specified in <code>sourceData</code> are not unique.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is already registered.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>sourceData</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  id: CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee stelt de naam van de opgegeven als een geldige gebeurtenisbron voor het schrijven van gegevens in een logboek op de lokale computer. Deze methode kunt ook een nieuwe aangepaste logboek maken op de lokale computer."
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the local computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the local computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log on the local computer. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A> when reading from a log, the local computer (\".\") is assumed.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_15_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_15_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_15_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName);
    parameters:
    - id: source
      type: System.String
      description: "De naam van de bron waarmee de toepassing is geregistreerd op de lokale computer."
    - id: logName
      type: System.String
      description: "De naam van het logboek dat naar items in de gegevensbron worden geschreven. Mogelijke waarden zijn toepassing, systeembestanden of een aangepaste gebeurtenislogboek."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the local computer.  \n  \n \\- or -  \n  \n The source name matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend op de lokale computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  id: CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee stelt de naam van de opgegeven als een geldige gebeurtenisbron voor het schrijven van gegevens in een logboek op de opgegeven computer. Deze methode kan ook worden gebruikt voor het maken van een nieuwe aangepaste logboek op de opgegeven computer."
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the specified computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the specified computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. In Windows Vista and later, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/86732307-05e6-4c1a-b98e-_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/86732307-05e6-4c1a-b98e-_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/86732307-05e6-4c1a-b98e-_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "De bron waarmee de toepassing is geregistreerd op de opgegeven computer."
    - id: logName
      type: System.String
      description: "De naam van het logboek dat naar items in de gegevensbron worden geschreven. Mogelijke waarden zijn toepassing, systeembestanden of een aangepaste gebeurtenislogboek. Als u een waarde niet opgeeft `logName` standaard ingesteld op de toepassing."
    - id: machineName
      type: System.String
      description: "De naam van de computer, de bron van deze gebeurtenis te registreren of &quot;. &quot; voor de lokale computer."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> is not a valid computer name.  \n  \n \\- or -  \n  \n <code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name on the specified computer.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the specified computer.  \n  \n \\- or -  \n  \n The source name matches an existing event source name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend op de opgegeven computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String)
  id: Delete(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee verwijdert u een gebeurtenislogboek van de lokale computer."
  remarks: "Gebruik deze methode als het logboek dat u wilt verwijderen op de lokale computer. Mits u de juiste registermachtigingen hebt, kunt u een logboek op de computer verwijderen.       Verwijderen wordt verwijderd van het logboek opgegeven door `logName` vanaf de lokale computer. Als u verwijderen, alleen de bron die zijn geregistreerd in een logboek wilt, <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> aanroepen Als u alleen de logboekvermeldingen verwijderen wilt, roept u <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> Verwijderen en <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>zijn `static` methoden, zodat ze kunnen worden aangeroepen op de klasse zelf.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Het is niet nodig voor het maken van een nieuw exemplaar van <xref:System.Diagnostics.EventLog>beide methode niet aanroepen.</xref:System.Diagnostics.EventLog>       De Delete-methode verwijdert eerst het bestand waarin de inhoud van het logboek. Vervolgens toegang heeft tot het register en verwijdert u alle de bronnen van gebeurtenissen voor het logboek geregistreerd. Als u het logboek op een later tijdstip opnieuw maken, moet u de bronnen van gebeurtenissen opnieuw registreren als ze opnieuw worden gebruikt. Als u niet de bronnen van gebeurtenissen registreert en andere gebruikers naar een gebeurtenisbron schrijven zonder op te geven van de naam van een logboek, wordt de gebeurtenisbron gemaakt in het logboek voor toepassingsgebeurtenissen. Daarom worden toepassingen die eerder waren kunnen vermeldingen schrijven naar het logboek u verwijderd en opnieuw gemaakt geschreven naar het toepassingslogboek in plaats daarvan omdat nu de gebeurtenisbron bevat.      > [!NOTE] > Opnieuw maken van een gebeurtenislogboek, kan een moeilijk proces zijn. Voorkomen dat een van de gebeurtenislogboeken systeem gemaakt zoals het toepassingslogboek wordt verwijderd.       Een logboek via het aanroepen van Delete verwijdert automatisch de gegevensbronnen die zijn geregistreerd in het logboekbestand. Hierdoor kunt u andere toepassingen die gebruikmaken van niet-werkende logboek."
  example:
  - "The following example deletes a log from the local computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_12_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_12_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public static void Delete (string logName);
    parameters:
    - id: logName
      type: System.String
      description: 'De naam van het logboek te verwijderen. Mogelijke waarden zijn: toepassing, beveiliging, systeem en eventuele aangepaste logboeken op de computer.'
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code>een lege tekenreeks (&quot;&quot;) of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the local computer.  \n  \n \\- or -  \n  \n The log does not exist on the local computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het gebeurtenislogboek is niet gewist.       - of - het logboek kan niet worden geopend. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  id: Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Verwijdert een gebeurtenislogboek van de opgegeven computer."
  remarks: "Gebruik deze methode als het logboek dat u wilt verwijderen op een externe computer. Mits u de juiste registermachtigingen hebt, kunt u een logboek op de computer verwijderen.       <xref:System.Diagnostics.EventLog.Delete%2A>Hiermee verwijdert u het logboek opgegeven door `logName` van de computer die is opgegeven door `machineName`.</xref:System.Diagnostics.EventLog.Delete%2A> Als u verwijderen, alleen de bron die zijn geregistreerd in een logboek wilt, <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> aanroepen Als u alleen de logboekvermeldingen verwijderen wilt, roept u <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>en <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>zijn `static` methoden, zodat ze kunnen worden aangeroepen op de klasse zelf.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> Het is niet nodig voor het maken van een exemplaar van <xref:System.Diagnostics.EventLog>beide methode niet aanroepen.</xref:System.Diagnostics.EventLog>       Deze methode worden eerst verwijderd van het bestand waarin de inhoud van het logboek. Vervolgens toegang heeft tot het register en verwijdert u alle de bronnen van gebeurtenissen voor het logboek geregistreerd. Als u het logboek op een later tijdstip opnieuw maken, moet u de bronnen van gebeurtenissen opnieuw registreren als ze opnieuw worden gebruikt. Als u niet de bronnen van gebeurtenissen registreert en andere gebruikers naar een gebeurtenisbron schrijven zonder op te geven van de naam van een logboek, wordt de gebeurtenisbron gemaakt in het logboek voor toepassingsgebeurtenissen. Daarom worden toepassingen die eerder waren kunnen vermeldingen schrijven naar het logboek u verwijderd en opnieuw gemaakt geschreven naar het toepassingslogboek in plaats daarvan omdat nu de gebeurtenisbron bevat.      > [!NOTE] > Opnieuw maken van een gebeurtenislogboek, kan een moeilijk proces zijn. Voorkomen dat een van de gebeurtenislogboeken systeem gemaakt zoals het toepassingslogboek wordt verwijderd.       Verwijderen van een logboek via een aanroep van <xref:System.Diagnostics.EventLog.Delete%2A>de gegevensbronnen die zijn geregistreerd voor dit logboek automatisch verwijderd</xref:System.Diagnostics.EventLog.Delete%2A> Hierdoor kunt u andere toepassingen die gebruikmaken van niet-werkende logboek."
  example:
  - "The following example deletes a log from the specified computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_17_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_17_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public static void Delete (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: 'De naam van het logboek te verwijderen. Mogelijke waarden zijn: toepassing, beveiliging, systeem en eventuele aangepaste logboeken op de opgegeven computer.'
    - id: machineName
      type: System.String
      description: "De naam van de computer te verwijderen van het logboek vanaf, of &quot;. &quot; voor de lokale computer."
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>machineName</code> is not a valid computer name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the specified computer.  \n  \n \\- or -  \n  \n The log does not exist on the specified computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het gebeurtenislogboek is niet gewist.       - of - het logboek kan niet worden geopend. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  id: DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee verwijdert u de bron-gebeurtenisregistratie uit het gebeurtenislogboek van de lokale computer."
  remarks: "Gebruik deze methode om te verwijderen van de registratie van een <xref:System.Diagnostics.EventLog.Source%2A>vanaf de lokale computer.</xref:System.Diagnostics.EventLog.Source%2A> DeleteEventSource toegang heeft tot het register op de lokale computer en verwijdert u de registratie van uw toepassing als een geldige bron van gebeurtenissen.       Als u deze vermeldingen in het logboekbestand schrijven niet langer nodig hebt, kunt u uw onderdeel als een geldige bron van gebeurtenissen. U kunt dit bijvoorbeeld doen als u moet uw onderdeel van één logboek wijzigen. Omdat een bron kan alleen in een logboek worden geregistreerd, moet het wijzigen van het logboek u de huidige registratie ongedaan gemaakt.       DeleteEventSource verwijdert alleen de bron in een logboek geregistreerd. Als u verwijderen van het logboek zelf wilt, <xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> aanroepen Als u alleen de logboekvermeldingen verwijderen wilt, roept u <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>en DeleteEventSource zijn `static` methoden, zodat ze kunnen worden aangeroepen op de klasse zelf.</xref:System.Diagnostics.EventLog.Delete%2A> Het is niet nodig voor het maken van een exemplaar van <xref:System.Diagnostics.EventLog>beide methode niet aanroepen.</xref:System.Diagnostics.EventLog>       Verwijderen van een logboek via een aanroep van <xref:System.Diagnostics.EventLog.Delete%2A>de gegevensbronnen die zijn geregistreerd voor dit logboek automatisch verwijderd</xref:System.Diagnostics.EventLog.Delete%2A> Hierdoor kunt u andere toepassingen die gebruikmaken van niet-werkende logboek.      > [!NOTE] > Als een bron al aan een logboek toegewezen is en u het opnieuw aan een nieuwe logboek toewijzen, moet opnieuw opstarten om de wijzigingen van kracht te laten worden."
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_8_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_8_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_8_1.cs)]"
  syntax:
    content: public static void DeleteEventSource (string source);
    parameters:
    - id: source
      type: System.String
      description: "De naam waarmee de toepassing is geregistreerd in het gebeurtenislogboek van systeem."
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> parameter does not exist in the registry of the local computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  id: DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Verwijdert de gebeurtenisregistratie bron van de toepassing van de opgegeven computer."
  remarks: "Gebruik deze overbelasting verwijderen van de registratie van een <xref:System.Diagnostics.EventLog.Source%2A>vanaf een externe computer.</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>heeft toegang tot het register op de computer die is opgegeven door `machineName` en verwijdert u de registratie van uw toepassing als een geldige bron van gebeurtenissen.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A>       Als u deze vermeldingen in het logboekbestand schrijven niet langer nodig hebt, kunt u uw onderdeel als een geldige bron van gebeurtenissen. U kunt dit bijvoorbeeld doen als u moet uw onderdeel van één logboek wijzigen. Omdat een bron kan alleen in een logboek worden geregistreerd, moet het wijzigen van het logboek u de huidige registratie ongedaan gemaakt.       <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>Hiermee verwijdert u alleen de bron in een logboek geregistreerd.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Als u verwijderen van het logboek zelf wilt, <xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> aanroepen Als u alleen de logboekvermeldingen verwijderen wilt, roept u <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>en <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>zijn `static` methoden, zodat ze kunnen worden aangeroepen op de klasse zelf.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> Het is niet nodig voor het maken van een exemplaar van <xref:System.Diagnostics.EventLog>beide methode niet aanroepen.</xref:System.Diagnostics.EventLog>       Verwijderen van een logboek via een aanroep van <xref:System.Diagnostics.EventLog.Delete%2A>de gegevensbronnen die zijn geregistreerd voor dit logboek automatisch verwijderd</xref:System.Diagnostics.EventLog.Delete%2A> Hierdoor kunt u andere toepassingen die gebruikmaken van niet-werkende logboek.      > [!NOTE] > Als een bron al aan een logboek toegewezen is en u het opnieuw aan een nieuwe logboek toewijzen, moet opnieuw opstarten om de wijzigingen van kracht te laten worden."
  example:
  - "The following example deletes a source from the specified computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_6_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_6_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_6_1.vb)]"
  syntax:
    content: public static void DeleteEventSource (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "De naam waarmee de toepassing is geregistreerd in het gebeurtenislogboek van systeem."
    - id: machineName
      type: System.String
      description: "De naam van de computer te verwijderen van de registratie van, of &quot;. &quot; voor de lokale computer."
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> parameter is invalid.  \n  \n \\- or -  \n  \n The <code>source</code> parameter does not exist in the registry of the specified computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>source</code>kan niet worden verwijderd omdat in het register, de bovenliggende registersleutel voor <code>source</code> bevat geen een subsleutel met dezelfde naam."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Heft de niet-beheerde bronnen worden gebruikt door de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>, en desgewenst de beheerde bronnen vrij."
  remarks: "Deze methode wordt aangeroepen door het publiek `Dispose()`methode en de <xref:System.Object.Finalize%2A>methode.</xref:System.Object.Finalize%2A> `Dispose()`Hiermee wordt de beveiligde `Dispose(Boolean)` methode met de `disposing` parameter ingesteld op `true`. <xref:System.Object.Finalize%2A>roept `Dispose` met `disposing` ingesteld op `false`.</xref:System.Object.Finalize%2A>       Wanneer de `disposing` parameter is ingesteld op true, wordt deze methode worden alle resources die beheerde objecten waarover vrijgegeven dat dit <xref:System.Diagnostics.EventLog>verwijzingen.</xref:System.Diagnostics.EventLog> Deze methode roept de `Dispose()` methode van elk object waarnaar wordt verwezen."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>voor het vrijgeven van zowel beheerde als onbeheerde hulpbronnen; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om alleen niet-beheerde bronnen vrij te geven."
  overload: System.Diagnostics.EventLog.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld met een waarde die aangeeft of de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> ontvangt <xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;> </xref> gebeurtenismeldingen."
  remarks: "De eigenschap EnableRaisingEvents bepaalt of de <xref:System.Diagnostics.EventLog>wordt gegeven gebeurtenissen als items worden geschreven in het logboek.</xref:System.Diagnostics.EventLog> Als de eigenschap is `true`, onderdelen die ontvangen de <xref:System.Diagnostics.EventLog.EntryWritten>gebeurtenis ontvangt een melding elk gewenst moment een vermelding is opgenomen in het logboek dat is opgegeven in de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap.</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.EntryWritten> Als EnableRaisingEvents `false`, er zijn geen gebeurtenissen worden gegenereerd.      > [!NOTE] > Kunt u meldingen ontvangen, alleen wanneer items op de lokale computer worden geschreven. U kunt geen meldingen voor vermeldingen geschreven op externe computers ontvangen."
  example:
  - "The following example handles an <xref:System.Diagnostics.EventLog.EntryWritten> event.  \n  \n [!code-cs[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_32_1.cs)]\n [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_32_1.vb)]\n [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_32_1.cpp)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> melding ontvangt wanneer een vermelding naar het logboek zijn geschreven, anders wordt is <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.EnableRaisingEvents*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het gebeurtenislogboek is op een externe computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EndInit
  id: EndInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "De initialisatie van eindigt een <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> gebruikt op een formulier of een ander onderdeel. De initialisatie van deze gebeurtenis treedt op tijdens runtime."
  remarks: "De [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] ontwerp omgeving maakt gebruik van deze methode om te beëindigen van de initialisatie van een onderdeel dat wordt gebruikt op een formulier of een ander onderdeel. De <xref:System.Diagnostics.EventLog.BeginInit%2A>methode de initialisatie wordt gestart.</xref:System.Diagnostics.EventLog.BeginInit%2A> Met behulp van de <xref:System.Diagnostics.EventLog.BeginInit%2A>en EndInit methoden voorkomt u dat het besturingselement wordt gebruikt voordat deze volledig is geïnitialiseerd.</xref:System.Diagnostics.EventLog.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Entries
  id: Entries
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de inhoud van het gebeurtenislogboek."
  remarks: "Het lid vermeldingen gebruikt bij het lezen van het gebeurtenislogboek.       Omdat de eigenschap alleen-lezen is, kan een vermelding niet wijzigen of schrijven naar het logboek met behulp van gegevens. Geef in plaats daarvan een <xref:System.Diagnostics.EventLog.Source%2A>en roep <xref:System.Diagnostics.EventLog.WriteEntry%2A>schrijven van een nieuwe logboekvermelding.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A> Kunt u items gebruiken om het aantal vermeldingen in het gebeurtenislogboek en elk bekijken <xref:System.Diagnostics.EventLogEntry>in de verzameling.</xref:System.Diagnostics.EventLogEntry> Gebruik de geïndexeerde <xref:System.Diagnostics.EventLogEntryCollection.Item%2A>lid informatie ophalen over een bepaalde vermelding zoals <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, of <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.</xref:System.Diagnostics.EventLogEntry.EntryType%2A> </xref:System.Diagnostics.EventLogEntry.TimeWritten%2A> </xref:System.Diagnostics.EventLogEntry.Category%2A> </xref:System.Diagnostics.EventLogEntry.Message%2A> </xref:System.Diagnostics.EventLogEntryCollection.Item%2A>       Het is niet nodig om op te geven van een <xref:System.Diagnostics.EventLog.Source%2A>bij het alleen lezen van een logbestand.</xref:System.Diagnostics.EventLog.Source%2A> Kunt u alleen de <xref:System.Diagnostics.EventLog.Log%2A>naam en <xref:System.Diagnostics.EventLog.MachineName%2A>(servernaam)-eigenschappen voor de <xref:System.Diagnostics.EventLog>exemplaar.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> In beide gevallen wordt het lid vermeldingen automatisch ingevuld met het gebeurtenislogboek lijst met items. In deze lijst om te lezen van afzonderlijke items kunt u de juiste index voor een item selecteren.       Een belangrijk verschil tussen lezen en schrijven van vermeldingen in het logboek is het is niet nodig expliciet een lezen methode niet aanroepen. Na de <xref:System.Diagnostics.EventLog.Log%2A>en <xref:System.Diagnostics.EventLog.MachineName%2A>zijn opgegeven, wordt de eigenschap vermeldingen wordt automatisch ingevuld.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Als u de waarde van de <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.MachineName%2A>eigenschap, de eigenschap wordt de volgende keer dat u deze lezen nieuwe vermeldingen</xref:System.Diagnostics.EventLog.MachineName%2A> of</xref:System.Diagnostics.EventLog.Log%2A> wijzigen      > [!NOTE] > U niet nodig zijn om op te geven het <xref:System.Diagnostics.EventLog.MachineName%2A>Als u een verbinding met een logbestand.</xref:System.Diagnostics.EventLog.MachineName%2A> Als u niet geeft de <xref:System.Diagnostics.EventLog.MachineName%2A>, de lokale computer &quot;. &quot;, wordt uitgegaan.</xref:System.Diagnostics.EventLog.MachineName%2A>"
  example:
  - "The following example reads entries in the event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.Entries Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_23_1.cs)]\n [!code-cpp[Classic EventLog.Entries Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_23_1.cpp)]\n [!code-vb[Classic EventLog.Entries Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_23_1.vb)]"
  syntax:
    content: public System.Diagnostics.EventLogEntryCollection Entries { get; }
    return:
      type: System.Diagnostics.EventLogEntryCollection
      description: "Een <xref href=&quot;System.Diagnostics.EventLogEntryCollection&quot;> </xref> houden van de vermeldingen in het gebeurtenislogboek. Elk item is gekoppeld aan een exemplaar van de <xref href=&quot;System.Diagnostics.EventLogEntry&quot;> </xref> klasse."
  overload: System.Diagnostics.EventLog.Entries*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EntryWritten
  id: EntryWritten
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Deze gebeurtenis treedt op wanneer een vermelding op de lokale computer naar een gebeurtenislogboek wordt geschreven."
  remarks: "Als u meldingen van gebeurtenissen, moet u instellen <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>naar `true`.</xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> U kunt alleen gebeurtenismeldingen ontvangen wanneer vermeldingen op de lokale computer worden geschreven. U kunt geen meldingen voor vermeldingen geschreven op externe computers ontvangen.       Wanneer u een gemachtigde EntryWritten maakt, kunt u de methode waarmee de gebeurtenis wordt afgehandeld identificeren. De gebeurtenis-handler koppelt u de gebeurtenis, een exemplaar van de gemachtigde te toevoegen aan de gebeurtenis. De gebeurtenis-handler wordt aangeroepen wanneer de gebeurtenis plaatsvindt, totdat u de gemachtigde verwijdert. Zie voor meer informatie over het verwerken van gebeurtenissen met gemachtigden [gebeurtenissen](~/add/includes/ajax-current-ext-md.md).       Het systeem reageert op <xref:System.Diagnostics.EventLog.WriteEntry%2A>alleen als de laatste gebeurtenis van schrijven ten minste zes seconden opgetreden.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Dit betekent dat u ontvangt alleen een EntryWritten gebeurtenismelding binnen een interval van zes seconde, zelfs als er meerdere gebeurtenislogboek wijzigt optreedt. Als u een interval lang genoeg slaapstand (ongeveer 10 seconden) tussen aanroepen invoegen <xref:System.Diagnostics.EventLog.WriteEntry%2A>, bent u minder waarschijnlijk een gebeurtenis mogen worden.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Echter, als schrijven gebeurtenissen vaker optreedt, kan niet worden weergegeven de gebeurtenismelding totdat het volgende interval. Normaal gesproken gemiste gebeurtenismeldingen zijn niet verloren, maar vertraagd."
  example:
  - "The following example handles an entry written event.  \n  \n [!code-cs[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/csharp/e-system.diagnostics.eve_1.cs)]\n [!code-cpp[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/cpp/e-system.diagnostics.eve_1.cpp)]\n [!code-vb[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/visualbasic/e-system.diagnostics.eve_1.vb)]"
  syntax:
    content: public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;
    return:
      type: System.Diagnostics.EntryWrittenEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String)
  id: Exists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee wordt bepaald of het logboek op de lokale computer bestaat."
  remarks: "Gebruik deze methode om te bepalen of een logboek op de lokale computer bestaat. Als u bepalen wilt of een bron op de lokale computer bestaat, gebruikt u <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A>       Omdat deze methode heeft toegang het register tot, moet u de juiste registermachtigingen er op de lokale computer; anders wordt de query retourneert `false`.       Omdat u niet kunt een nieuw logboekbestand de naam van een bestaand logboek op dezelfde computer geeft, gebruikt u deze methode voordat een nieuw logboekbestand maken om te bepalen of de opgegeven `logName` bestaat al op de lokale computer. De `logName` parameter is niet hoofdlettergevoelig.       Er bestaat is een `static` methode, zodat deze kan worden aangeroepen voor de klasse zelf. Het is niet nodig voor het maken van een exemplaar van <xref:System.Diagnostics.EventLog>om aan te roepen Exists.</xref:System.Diagnostics.EventLog>"
  example:
  - >-
    [!code-cpp[EventLog_Exists_1#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_4_1.cpp)]
     [!code-vb[EventLog_Exists_1#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_4_1.vb)]
     [!code-cs[EventLog_Exists_1#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_4_1.cs)]
  syntax:
    content: public static bool Exists (string logName);
    parameters:
    - id: logName
      type: System.String
      description: 'De naam van het logboek om te zoeken. Mogelijke waarden zijn: toepassing, beveiliging, systeem, andere logboeken toepassingsspecifieke (zoals die zijn gekoppeld aan Active Directory) of een aangepaste logboek op de computer.'
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het logboek op de lokale computer bestaat; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De logboeknaam wordt <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> of de waarde is leeg."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  id: Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee wordt bepaald of het logboek op de opgegeven computer bestaat."
  remarks: "Gebruik deze methode om te bepalen of een logboek op een externe computer bestaat. Als u bepalen wilt of een bron op een externe computer bestaat, gebruikt u <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A>       Omdat deze methode heeft toegang het register tot, moet u de juiste registermachtigingen hebben op de opgegeven computer. anders wordt de query retourneert `false`.       Omdat u niet kunt een nieuw logboekbestand de naam van een bestaand logboek op dezelfde computer geeft, gebruikt u deze methode voordat een nieuw logboekbestand maken om te bepalen of een met de opgegeven `logName` bestaat al op de server die is opgegeven door de `machineName` parameter. De `logName` en `machineName` parameters zijn niet hoofdlettergevoelig.       <xref:System.Diagnostics.EventLog.Exists%2A>is een `static` methode, zodat deze kan worden aangeroepen voor de klasse zelf.</xref:System.Diagnostics.EventLog.Exists%2A> Het is niet nodig voor het maken van een nieuw exemplaar van <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A> aanroepen</xref:System.Diagnostics.EventLog>"
  syntax:
    content: public static bool Exists (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: 'Het logboek voor waarnaar moet worden gezocht. Mogelijke waarden zijn: toepassing, beveiliging, systeem, andere logboeken toepassingsspecifieke (zoals die zijn gekoppeld aan Active Directory) of een aangepaste logboek op de computer.'
    - id: machineName
      type: System.String
      description: "De naam van de computer waarop u wilt zoeken naar het logboek of &quot;. &quot; voor de lokale computer."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het logboek op de opgegeven computer bestaat. anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De <code> machineName </code> -parameter is een ongeldige indeling. Zorg ervoor dat u hebt de juiste syntaxis gebruikt voor de computer waarop u wilt zoeken.       - of - de <code> logName </code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> of de waarde is leeg."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs
  id: GetEventLogs
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zoekt naar alle gebeurtenislogboeken op de lokale computer en maakt een matrix van <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> objecten die de lijst bevatten."
  remarks: "De matrix van <xref:System.Diagnostics.EventLog>objecten is een momentopname van alle gebeurtenislogboeken op de lokale computer wanneer de aanroep van GetEventLogs wordt gedaan.</xref:System.Diagnostics.EventLog> Dit is niet een dynamische verzameling, zodat deze niet met het verwijderen of maken van Logboeken in realtime overeen komt. U moet controleren of een logboek in de matrix bestaat voordat u lezen of schrijven. De matrix bevat meestal ten minste drie logboeken: toepassing, systeem en beveiliging. Als u aangepaste logboeken op de lokale computer gemaakt, wordt deze weergegeven in de matrix ook.       Voor het ophalen van de lijst met gebeurtenislogboeken, moet u de juiste registermachtigingen hebt. Deze machtigingen zijn identiek aan die nodig zijn om aan te roepen <xref:System.Diagnostics.EventLog.Exists%2A>en <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog.Exists%2A>"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_10_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/m-system.diagnostics.eve_10_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/m-system.diagnostics.eve_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs ();
    parameters: []
    return:
      type: System.Diagnostics.EventLog[]
      description: "Een matrix van het type <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> die staat voor de logboeken op de lokale computer."
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "U hebt geen leestoegang aan het register.       - of - er is geen gebeurtenislogboek-service op de computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  id: GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zoekt naar alle gebeurtenislogboeken op de opgegeven computer en maakt een matrix van <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> objecten die de lijst bevatten."
  remarks: "De matrix van <xref:System.Diagnostics.EventLog>objecten is een momentopname van alle gebeurtenislogboeken op de computer die is opgegeven door de `machineName` parameter bij het aanroepen van <xref:System.Diagnostics.EventLog.GetEventLogs%2A>is gemaakt.</xref:System.Diagnostics.EventLog.GetEventLogs%2A> </xref:System.Diagnostics.EventLog> Dit is niet een dynamische verzameling, zodat deze niet met het verwijderen of maken van Logboeken in realtime overeen komt. U moet controleren of een logboek in de matrix bestaat voordat u lezen of schrijven. De matrix bevat meestal ten minste drie logboeken: toepassing, systeem en beveiliging. Als u aangepaste logboeken op de opgegeven computer gemaakt, worden deze weergegeven in de matrix ook.       <xref:System.Diagnostics.EventLog.GetEventLogs%2A>is een `static` methode, zodat kan worden aangeroepen voor de <xref:System.Diagnostics.EventLog>klasse zelf.</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.GetEventLogs%2A> Het is niet nodig voor het maken van een exemplaar van een <xref:System.Diagnostics.EventLog>-object op voor het maken van een aanroep van de methode.</xref:System.Diagnostics.EventLog>       Voor het ophalen van de lijst met gebeurtenislogboeken, moet u de juiste registermachtigingen hebt. Deze machtigingen zijn identiek aan die nodig zijn om aan te roepen <xref:System.Diagnostics.EventLog.Exists%2A>en <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog.Exists%2A>"
  example:
  - "The following example gets a list of logs on the computer \"myServer\". It then outputs the name of each log.  \n  \n [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_18_1.cpp)]\n [!code-cs[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_18_1.vb)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "De computer waarop u wilt zoeken naar Logboeken."
    return:
      type: System.Diagnostics.EventLog[]
      description: "Een matrix van het type <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> die staat voor de logboeken op de opgegeven computer."
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De <code> machineName </code> -parameter is een ongeldige computernaam."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "U hebt geen leestoegang aan het register.       - of - er is geen gebeurtenislogboek-service op de computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Log
  id: Log
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van de naam van het logboek te lezen uit of schrijven naar."
  remarks: "Three log files exist by default on the server: Application, System, and Security. Applications and services use the Application log file. Device drivers use the System log file. The system generates success and failure audit events in the Security log when auditing is turned on. If you have other applications installed, like Active Directory on Windows servers, there might be other default log files. In addition, you can create custom log files on a local or remote computer. Custom logs help organize your entries in a more detailed way than is allowed when your components write events to the default Application log.  \n  \n> [!NOTE]\n>  Log names are limited to eight characters. According to the system, MyLogSample1 and MyLogSample2 are the same log.  \n  \n If you write to an event log, it is not enough to specify the Log property. You must associate a <xref:System.Diagnostics.EventLog.Source%2A> property with your event log resource to connect it to a particular log. It is not necessary to specify a <xref:System.Diagnostics.EventLog.Source%2A> when only reading from a log, but an event source must be associated with the event log resource in the server's registry. You can specify only the Log name and <xref:System.Diagnostics.EventLog.MachineName%2A> (server computer name) to read from it.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A>, the local computer (\".\") is assumed.  \n  \n If the <xref:System.Diagnostics.EventLog.Source%2A> property has not been specified, a call to Log returns an empty string if Log has not been explicitly set (by setting the Log property, or through the constructor). If the <xref:System.Diagnostics.EventLog.Source%2A> has been specified, Log returns the name of the log to which that source was registered.  \n  \n A source can only be registered to one log at a time. If the <xref:System.Diagnostics.EventLog.Source%2A> property was set for an instance of <xref:System.Diagnostics.EventLog>, you cannot change the Log property for that <xref:System.Diagnostics.EventLog> without changing the value of <xref:System.Diagnostics.EventLog.Source%2A> or calling <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> first. If you change the Log property after the <xref:System.Diagnostics.EventLog.Source%2A> property has been set, writing a log entry throws an exception.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the Log property with the \".evt\" file name extension.  \n  \n You cannot create a new log using the Log property alone (without specifying a source for the log). You can call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, passing in a new log name as a parameter, and then call <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. However, the intent is usually either to create (and write entries to) new application-specific logs, or to read from existing logs.  \n  \n If the Log value changes, the event log is closed and all event handles are released.  \n  \n> [!CAUTION]\n>  If you set the Log property to the name of a log that does not exist, the system attaches the <xref:System.Diagnostics.EventLog> to the Application log, but does not warn you that it is using a log other than the one you specified."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.Log Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_17_1.cpp)]\n [!code-cs[Classic EventLog.Log Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_17_1.cs)]\n [!code-vb[Classic EventLog.Log Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public string Log { get; set; }
    return:
      type: System.String
      description: "De naam van het logboek. Dit kan de toepassing, systeem, beveiliging of een aangepaste logboeknaam zijn. De standaardwaarde is een lege tekenreeks (&quot;&quot;)."
  overload: System.Diagnostics.EventLog.Log*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogDisplayName
  id: LogDisplayName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de beschrijvende naam van het gebeurtenislogboek."
  remarks: "> [!NOTE]> In Windows Vista en hoger, bent gebruikers niet gemachtigd voor toegang tot het beveiligingslogboek. Als u werkt met Windows Vista of hoger als een gebruiker, krijgt u een <xref:System.Security.SecurityException>Als u probeert te krijgen tot de weergavenaam voor een gebeurtenis in het beveiligingslogboek</xref:System.Security.SecurityException>   >> In Windows Vista en hoger, bepaalt Gebruikersaccountbeheer (UAC) de bevoegdheden van een gebruiker. Als u lid zijn van de ingebouwde groep Administrators, kunt u twee runtime-toegangstokens zijn toegewezen: een standaardgebruikerstoegang en een token voor beheerderstoegang. U bent standaard in de standaard gebruikersrol. Voor het uitvoeren van de code die toegang heeft tot het beveiligingslogboek moet u eerst uw bevoegdheden van een standaardgebruiker uitbreiden naar de beheerder. U kunt dit doen wanneer u een toepassing begint met de rechtermuisknop op het pictogram van de toepassing die aangeeft dat u wilt uitvoeren als beheerder."
  example:
  - "The following example enumerates the event logs defined on the local computer and displays the LogDisplayName for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_29_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_29_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_29_1.cs)]"
  syntax:
    content: public string LogDisplayName { get; }
    return:
      type: System.String
      description: "Een naam die het gebeurtenislogboek in Logboeken van het systeem vertegenwoordigt."
  overload: System.Diagnostics.EventLog.LogDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De opgegeven <xref:System.Diagnostics.EventLog.Log*>bestaat niet in het register voor deze computer.</xref:System.Diagnostics.EventLog.Log*>"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  id: LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de naam van het logboek waarbij de opgegeven bron is geregistreerd."
  remarks: "De gebeurtenisbron geeft aan wat registreert de gebeurtenis. Het is vaak de naam van de toepassing of de naam van een subonderdeel van de toepassing, als de toepassing groot is. Toepassingen en services moeten schrijven naar het toepassingslogboek of een aangepast logboek. Apparaatstuurprogramma&quot;s te schrijven naar het systeemlogboek.       Bij het maken van een nieuwe bron slechts naar één logboek op een tijdstip schrijven kan, registreert het systeem uw toepassing met het gebeurtenislogboek als een geldige bron vermeldingen. De <xref:System.Diagnostics.EventLog.Source%2A>eigenschap kan een willekeurige tekenreeks, maar de naam kan niet worden gebruikt door andere bronnen op de computer.</xref:System.Diagnostics.EventLog.Source%2A> Een poging te maken van een gedupliceerde <xref:System.Diagnostics.EventLog.Source%2A>waarde er een uitzondering gegenereerd.</xref:System.Diagnostics.EventLog.Source%2A> Een afzonderlijk gebeurtenislogboek hebben echter veel verschillende bronnen te schrijven."
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_2_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_2_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_2_1.cs)]"
  syntax:
    content: public static string LogNameFromSourceName (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "De naam van de gegevensbron."
    - id: machineName
      type: System.String
      description: "De naam van de computer waarop u wilt zoeken, of &quot;. &quot; voor de lokale computer."
    return:
      type: System.String
      description: "De naam van het logboek die zijn gekoppeld aan de opgegeven bron in het register."
  overload: System.Diagnostics.EventLog.LogNameFromSourceName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MachineName
  id: MachineName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van de naam van de computer waarop u wilt lezen of schrijven van gebeurtenissen."
  remarks: "Als u naar een gebeurtenislogboek schrijft, moet u een koppelen <xref:System.Diagnostics.EventLog.Source%2A>met uw gebeurtenislogboek-object om te verbindt deze met een bepaalde logbestand.</xref:System.Diagnostics.EventLog.Source%2A> Het is niet nodig om op te geven van de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap bij het alleen lezen van een logbestand.</xref:System.Diagnostics.EventLog.Source%2A> Kunt u alleen de <xref:System.Diagnostics.EventLog.Log%2A>naam en MachineName (servernaam).</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > U moet de computernaam niet opgeven als u een verbinding met een logboek. Als u de computernaam, de lokale computer niet opgeeft (&quot;. &quot;) wordt verondersteld.       Een bron kan slechts aan één logboek worden geregistreerd. Als de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap is ingesteld voor een exemplaar van <xref:System.Diagnostics.EventLog>, u kunt de eigenschap MachineName niet wijzigen voor die <xref:System.Diagnostics.EventLog>zonder te wijzigen van de waarde van <xref:System.Diagnostics.EventLog.Source%2A>of aan te roepen <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>eerste.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Als u de eigenschap computernaam, wijzigt de <xref:System.Diagnostics.EventLog>sluit u alle ingangen en reattaches naar het log en source op de nieuwe computer.</xref:System.Diagnostics.EventLog>       De waarde van de computernaam kan niet een lege tekenreeks zijn. Als deze niet expliciet is ingesteld, wordt standaard op de lokale computer (&quot;. &quot;)."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on a specified computer.  \n  \n [!code-cs[Classic EventLog.MachineName Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_6_1.cs)]\n [!code-vb[Classic EventLog.MachineName Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_6_1.vb)]\n [!code-cpp[Classic EventLog.MachineName Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_6_1.cpp)]"
  syntax:
    content: public string MachineName { get; set; }
    return:
      type: System.String
      description: "De naam van de server waarop het gebeurtenissenlogboek zich bevindt. De standaardwaarde is de lokale computer (&quot;. &quot;)."
  overload: System.Diagnostics.EventLog.MachineName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De computernaam is ongeldig."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  id: MaximumKilobytes
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van de maximale logboekgrootte in kB."
  remarks: "De eigenschap MaximumKilobytes geeft de maximale grootte van het gebeurtenislogboek. Wanneer het gebeurtenislogboek van de limiet bereikt, de geconfigureerde <xref:System.Diagnostics.EventLog.OverflowAction%2A>waarde bepaalt of de nieuwe vermeldingen worden verwijderd of nieuwe vermeldingen overschrijven of oudere vermeldingen.</xref:System.Diagnostics.EventLog.OverflowAction%2A>      > [!NOTE] > Deze eigenschap vertegenwoordigt een configuratie-instelling voor het gebeurtenislogboek dat wordt vertegenwoordigd door dit exemplaar. Wanneer het logboek de maximum grootte bereikt, wordt deze eigenschap specificeert hoe nieuwe vermeldingen geschreven door alle bronnen van gebeurtenissen geregistreerd voor het gebeurtenislogboek worden verwerkt door het besturingssysteem."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_15_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_15_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_15_1.cs)]"
  syntax:
    content: public long MaximumKilobytes { get; set; }
    return:
      type: System.Int64
      description: "De maximale logboekgrootte in kB. De standaardwaarde is 512, die wijzen op een maximale grootte van 512 kB."
  overload: System.Diagnostics.EventLog.MaximumKilobytes*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De opgegeven waarde is kleiner dan 64, of groter is dan 4194240 of niet een veelvoud van 64."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  id: MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u het aantal dagen wilt bewaren vermeldingen in het gebeurtenislogboek."
  remarks: "Gebruik de eigenschap MinimumRetentionDays om te onderzoeken van de huidige instelling voor een gebeurtenislogboek. Gebruik <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>wijzigen van het minimum aantal dagen dat elk item in het gebeurtenislogboek moet worden bewaard.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       De waarde MinimumRetentionDays is afhankelijk van het gedrag van de geconfigureerde overloop van het gebeurtenislogboek. Als de <xref:System.Diagnostics.OverflowAction>eigenschap voor een gebeurtenislogboek is ingesteld op <xref:System.Diagnostics.OverflowAction>, en vervolgens de MinimumRetentionDays-waarde 0 is.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> Als de <xref:System.Diagnostics.OverflowAction>eigenschap voor een gebeurtenislogboek is ingesteld op <xref:System.Diagnostics.OverflowAction>, dan is de MinimumRetentionDays waarde -1.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> Als de <xref:System.Diagnostics.OverflowAction>eigenschap voor een gebeurtenislogboek is ingesteld op <xref:System.Diagnostics.OverflowAction>, dan is de waarde MinimumRetentionDays groter zijn dan nul en geeft het aantal dagen logboekvermeldingen behouden wanneer het logboek vol is.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction>       Het gedrag overloop treedt alleen op wanneer een gebeurtenislogboek de opslaglimiet bereikt. Wanneer een <xref:System.Diagnostics.EventLog>heeft de <xref:System.Diagnostics.EventLog.OverflowAction%2A>ingesteld op <xref:System.Diagnostics.OverflowAction>, en het gebeurtenislogboek zijn maximum grootte bereikt, en vervolgens nieuwe items worden alleen geschreven als ze vermeldingen waarvan leeftijd groter is dan de periode MinimumRetentionDays kunnen vervangen.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog> Gebeurtenisvermeldingen behouden gedurende een periode is geschikt als het gebeurtenislogboek regelmatig wordt gearchiveerd. Anders kunnen nieuwe gegevens verliest als de limiet bereikt die het gebeurtenislogboek. Instellen om te voorkomen dat nieuwe gebeurtenisgegevens verloren gaan, de minimale bewaren dagen voor gebeurtenissen op basis van uw planning archief voor een bepaald gebeurtenislogboek."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_12_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_12_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public int MinimumRetentionDays { get; }
    return:
      type: System.Int32
      description: "Het aantal dagen dat de vermeldingen in het gebeurtenislogboek worden bewaard. De standaardwaarde is 7."
  overload: System.Diagnostics.EventLog.MinimumRetentionDays*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  id: ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Wijzigingen van het geconfigureerde gedrag voor het schrijven van nieuwe vermeldingen, wanneer het gebeurtenislogboek van de maximale grootte heeft bereikt."
  remarks: "Het gedrag overloop voor een gebeurtenislogboek bepaalt wat er gebeurt wanneer nieuwe vermeldingen moeten worden vastgelegd in een logboek de maximale grootte heeft bereikt.      > [!NOTE] > Het gedrag overloop heeft alleen effect als een gebeurtenislogboek zijn maximale grootte bereikt. Het gedrag overloop heeft geen invloed op een nieuwe vermelding schrijven naar een logboek dat aanvullende logboekvermeldingen aankan.       De methode ModifyOverflowPolicy configureert u het gedrag overloop van een gebeurtenislogboek. <xref:System.Diagnostics.EventLog>exemplaar.</xref:System.Diagnostics.EventLog> Na het aanroepen van deze methode voor het gebeurtenislogboek die is opgegeven door de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap, de <xref:System.Diagnostics.EventLog.OverflowAction%2A>en <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>eigenschapswaarden overeenstemming met het gedrag van de meest recent geconfigureerde overloop.</xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Deze eigenschap vertegenwoordigt een configuratie-instelling voor het gebeurtenislogboek dat wordt vertegenwoordigd door dit exemplaar. Wanneer het logboek de maximum grootte bereikt, wordt deze eigenschap specificeert hoe nieuwe vermeldingen geschreven door alle bronnen van gebeurtenissen geregistreerd voor het gebeurtenislogboek worden verwerkt door het besturingssysteem.       Stel de `action` -parameter voor <xref:System.Diagnostics.OverflowAction>om aan te geven dat een nieuwe vermelding het oudste item overschrijft wanneer de <xref:System.Diagnostics.EventLog>zijn maximum grootte bereikt.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> Als de `action` parameter is ingesteld op <xref:System.Diagnostics.OverflowAction>, wordt de `retentionDays` waarde voor de parameter wordt genegeerd.</xref:System.Diagnostics.OverflowAction>       Stel de `action` -parameter voor <xref:System.Diagnostics.OverflowAction>om aan te geven dat voor elke nieuwe post oudere vermeldingen worden overschreven wanneer de <xref:System.Diagnostics.EventLog>zijn maximum grootte bereikt.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> Geef het aantal dagen dat gebeurtenissen moeten worden bewaard in het logboek met de `retentionDays` parameter. Gebeurtenissen die worden vastgelegd binnen de bewaartermijn niet worden overschreven door nieuwe vermeldingen.       Stel de `action` -parameter voor <xref:System.Diagnostics.OverflowAction>te verwijderen van de nieuwe gebeurtenissen als de maximale logboekgrootte is bereikt.</xref:System.Diagnostics.OverflowAction> Als de `action` parameter is ingesteld op <xref:System.Diagnostics.OverflowAction>, wordt de `retentionDays` waarde voor de parameter wordt genegeerd.</xref:System.Diagnostics.OverflowAction>      > [!CAUTION] > Als u het beleid overloop op <xref:System.Diagnostics.OverflowAction>geeft aan dat de nieuwe vermeldingen worden verwijderd wanneer het logboek vol is.</xref:System.Diagnostics.OverflowAction> Als u deze instelling gebruikt, controleert u het gebeurtenislogboek regelmatig is gearchiveerd en uitgeschakeld om te voorkomen dat de toegestane maximumgrootte is bereikt."
  example:
  - "The following example displays the configured overflow policy for a specified event log, and allows the user to select a new overflow policy setting for the event log.  \n  \n [!code-vb[EventLogProperties#3](~/add/codesnippet/visualbasic/0b0fc273-a638-4af9-ae99-_1.vb)]\n [!code-cpp[EventLogProperties#3](~/add/codesnippet/cpp/0b0fc273-a638-4af9-ae99-_1.cpp)]\n [!code-cs[EventLogProperties#3](~/add/codesnippet/csharp/0b0fc273-a638-4af9-ae99-_1.cs)]"
  syntax:
    content: public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);
    parameters:
    - id: action
      type: System.Diagnostics.OverflowAction
      description: "De werking van overloop voor het schrijven van nieuwe vermeldingen in het gebeurtenislogboek."
    - id: retentionDays
      type: System.Int32
      description: "Het minimale aantal dagen dat elke logboekvermelding wordt bewaard. Deze parameter wordt alleen gebruikt als `action` is ingesteld op <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>."
  overload: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>action</code>is geen geldige <xref:System.Diagnostics.EventLog.OverflowAction*> waarde."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>retentionDays</code>is kleiner dan 1 of groter zijn dan 365."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.OverflowAction
  id: OverflowAction
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de geconfigureerde gedrag voor het opslaan van nieuwe vermeldingen, wanneer het gebeurtenislogboek van de maximale logboekgrootte bereikt."
  remarks: "Gebeurtenislogboeken steeds groter als nieuwe gebeurtenissen worden naar worden geschreven. Elk logboek heeft een geconfigureerde maximumgrootte; de <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>eigenschap definieert het maximum aantal kilobytes is toegestaan voor de grootte van het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>       Gebruik de waarde van de eigenschap OverflowAction om het gedrag van de geconfigureerde overloop voor een gebeurtenislogboek van de maximale grootte. Gebruik de <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>methode voor het wijzigen van het gedrag overloop voor een gebeurtenislogboek.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>      > [!NOTE] > Het gedrag overloop heeft alleen effect als een gebeurtenislogboek zijn maximale grootte bereikt. Het gedrag overloop heeft geen invloed op een nieuwe vermelding schrijven naar een logboek dat aanvullende logboekvermeldingen aankan."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_28_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_28_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_28_1.cs)]"
  syntax:
    content: public System.Diagnostics.OverflowAction OverflowAction { get; }
    return:
      type: System.Diagnostics.OverflowAction
      description: "De <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref> waarde die hoe geconfigureerd aangeeft voor het opslaan van nieuwe vermeldingen, wanneer het gebeurtenislogboek van de maximale grootte heeft bereikt. De standaardwaarde is <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>."
  overload: System.Diagnostics.EventLog.OverflowAction*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  id: RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee geeft u de gelokaliseerde naam van het gebeurtenislogboek dat wordt weergegeven in de Event Viewer-server."
  remarks: "Gebruik RegisterDisplayName om te registreren en een gelokaliseerde naam wordt weergegeven in de logboeken voor de aangepaste logboeken.       De opgegeven resource-id moet overeenkomen met een gelokaliseerde tekenreeks die is gedefinieerd in het bronbestand. De naam van de aangepaste gebeurtenislogboek met de gelokaliseerde tekenreeks en de huidige cultuurinstellingen in de logboeken weergegeven. U kunt bijvoorbeeld meerdere namen van gebeurtenislogboeken gelokaliseerd voor verschillende culturen in uw bronbestand definiëren. De logboeken weergegeven de gelokaliseerde tekenreeks die overeenkomt met de cultuurinstellingen van de huidige gebruiker.       Als de Event Viewer kan de gelokaliseerde tekenreeks uit het bronbestand niet laden, of als er geen weergavenaam is geregistreerd voor het gebeurtenislogboek, wordt de Event Viewer vervolgens de gebeurtenislogboeknaam gedefinieerd in <xref:System.Diagnostics.EventLog.Log%2A>.</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > U hoeft niet te registreren van een weergavenaam voor de vooraf gedefinieerde gebeurtenislogboeken. Het besturingssysteem registreert de gelokaliseerde weergavenamen voor de gebeurtenislogboeken van toepassing, systeem en beveiliging."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/m-system.diagnostics.eve_1_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_1_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/m-system.diagnostics.eve_1_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void RegisterDisplayName (string resourceFile, long resourceId);
    parameters:
    - id: resourceFile
      type: System.String
      description: "Het volledig opgegeven pad naar een vertaalde bron-bestand."
    - id: resourceId
      type: System.Int64
      description: "De resource-id die een gelokaliseerde tekenreeks binnen het bronbestand geïndexeerd."
  overload: System.Diagnostics.EventLog.RegisterDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceFile </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Source
  id: Source
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van de naam van de bron om te registreren en te gebruiken bij het schrijven naar het gebeurtenislogboek."
  remarks: "De gebeurtenisbron geeft aan wat registreert de gebeurtenis. Het is vaak de naam van de toepassing of de naam van een subonderdeel van de toepassing, als de toepassing groot is. Toepassingen en services moeten schrijven naar het toepassingslogboek of een aangepast logboek. Apparaatstuurprogramma&quot;s te schrijven naar het systeemlogboek.       U moet alleen een gebeurtenisbron opgeven als u een gebeurtenislogboek schrijft. Voordat u een vermelding in het schrijven naar een gebeurtenislogboek, moet u de gebeurtenisbron registreren met het gebeurtenislogboek als een geldige bron van gebeurtenissen. Wanneer u een logboekvermelding schrijft, gebruikt het systeem de eigenschap Source vinden van het juiste logboek voor uw invoer. Als u het gebeurtenislogboek leest, kunt u opgeven de bron- of een <xref:System.Diagnostics.EventLog.Log%2A>en <xref:System.Diagnostics.EventLog.MachineName%2A>.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > U niet nodig zijn om op te geven de <xref:System.Diagnostics.EventLog.MachineName%2A>Als u een verbinding met een logboekbestand op de lokale computer.</xref:System.Diagnostics.EventLog.MachineName%2A> Als u niet geeft de <xref:System.Diagnostics.EventLog.MachineName%2A>, de lokale computer (&quot;. &quot;) wordt aangenomen dat.</xref:System.Diagnostics.EventLog.MachineName%2A>       Gebruik van <xref:System.Diagnostics.EventLog.WriteEvent%2A>en <xref:System.Diagnostics.EventLog.WriteEntry%2A>schrijven van gebeurtenissen naar een gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.WriteEvent%2A> U moet een gebeurtenisbron voor het schrijven van gebeurtenissen; opgeven u moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven.       Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       U kunt een gebeurtenisbron voor een bestaande gebeurtenislogboek of een nieuw gebeurtenislogboek maken. Wanneer u een nieuwe bron voor een nieuw gebeurtenislogboek maakt, wordt het systeem wordt de bron voor het logboek geregistreerd, maar het logboek is niet gemaakt totdat het eerste item wordt geschreven naar het.       De bron moet uniek zijn op de lokale computer; een nieuwe naam voor de gegevensbron mag niet overeenkomen met de naam van een bestaande gegevensbron of de naam van een bestaande gebeurtenislogboek. Elke bron kan naar slechts één gebeurtenislogboek schrijven tegelijk; uw toepassing kunt gebruiken, meerdere bronnen naar meerdere gebeurtenislogboeken te schrijven. Uw toepassing moet mogelijk meerdere bronnen die zijn geconfigureerd voor verschillende gebeurtenislogboeken of bestanden andere resource.       Als u de bronwaarde wijzigt de <xref:System.Diagnostics.EventLog>op die deze is geregistreerd is gesloten en alle gebeurtenis-ingangen zijn vrijgegeven.</xref:System.Diagnostics.EventLog>       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Om de configuratiedetails van een bestaande gegevensbron wijzigt, moet u de bron verwijderen en vervolgens te maken met de nieuwe configuratie. Als andere toepassingen of onderdelen gebruikt de bestaande bron, maakt u een nieuwe bron met de bijgewerkte configuratie in plaats van de bestaande bron verwijderen.      > [!NOTE] > Als een bron al aan een logboek toegewezen is en u het opnieuw aan een nieuwe logboek toewijzen, moet opnieuw opstarten om de wijzigingen van kracht te laten worden."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_18_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_18_1.cpp)]"
  syntax:
    content: public string Source { get; set; }
    return:
      type: System.String
      description: "De naam geregistreerd bij het gebeurtenislogboek als bron van de vermeldingen. De standaardwaarde is een lege tekenreeks (&quot;&quot;)."
  overload: System.Diagnostics.EventLog.Source*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De bronnaam resulteert in een pad van registersleutel langer zijn dan 254 tekens."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  id: SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee wordt bepaald of de bron van een gebeurtenis is geregistreerd op de lokale computer."
  remarks: "Gebruik deze methode om te bepalen of een gebeurtenisbron op de lokale computer bestaat. Als u bepalen wilt of een logboek op de lokale computer bestaat, gebruikt u <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       Omdat deze methode heeft toegang het register tot, moet u de juiste registermachtigingen hebben op de lokale computer; anders wordt een <xref:System.Security.SecurityException>gegenereerd.</xref:System.Security.SecurityException>      > [!NOTE] > Wilt zoeken naar een gebeurtenisbron in Windows Vista en hoger of Windows Server 2003, moet u over administratorbevoegdheden beschikken.   >> De reden voor deze vereiste is dat alle gebeurtenislogboeken, met inbegrip van beveiliging, moet worden gezocht om te bepalen of de gebeurtenisbron uniek is. Vanaf Windows Vista, hebben gebruikers geen toestemming voor toegang tot het beveiligingslogboek; daarom een <xref:System.Security.SecurityException>gegenereerd.</xref:System.Security.SecurityException>   >> Vanaf Windows Vista Gebruikersaccountbeheer (UAC) bepaalt de bevoegdheden van een gebruiker. Als u lid zijn van de ingebouwde groep Administrators, kunt u twee runtime-toegangstokens zijn toegewezen: een standaardgebruikerstoegang en een token voor beheerderstoegang. U bent standaard in de standaard gebruikersrol. Voor het uitvoeren van de code die toegang heeft tot prestatiemeteritems, moet u eerst uw bevoegdheden van een standaardgebruiker uitbreiden naar beheerder. U kunt dit doen wanneer u een toepassing begint met de rechtermuisknop op het pictogram van de toepassing die aangeeft dat u wilt uitvoeren als beheerder.      > [!NOTE] > Een service die wordt uitgevoerd onder de <xref:System.ServiceProcess.ServiceAccount>account niet beschikt over de vereiste bevoegdheden voor het uitvoeren van deze methode.</xref:System.ServiceProcess.ServiceAccount> De oplossing is om te controleren of de gebeurtenisbron voorkomt in de <xref:System.ServiceProcess.ServiceInstaller>, en als deze niet bestaat, voor het maken van de bron in het installatieprogramma.</xref:System.ServiceProcess.ServiceInstaller>       Omdat u niet kunt een nieuwe bron de naam van een bestaande gegevensbron op dezelfde computer geeft, gebruiken deze methode voordat u probeert aan te roepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ervoor te zorgen dat een bron met de naam die is opgegeven door `source` nog niet bestaat op de lokale computer.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> De `source` parameter is niet hoofdlettergevoelig."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_14_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_14_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_14_1.cpp)]"
  syntax:
    content: public static bool SourceExists (string source);
    parameters:
    - id: source
      type: System.String
      description: "De naam van de gegevensbron."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de bron van de gebeurtenis is geregistreerd op de lokale computer; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>is niet gevonden, maar sommige of alle gebeurtenislogboeken kan niet worden gezocht."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  id: SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee wordt bepaald of een gebeurtenisbron op een opgegeven computer is geregistreerd."
  remarks: "Gebruik deze methode om te bepalen of een gebeurtenisbron op de computer die is opgegeven bestaat door de `machineName` parameter. Als u bepalen wilt of een logboek op de opgegeven computer bestaat, gebruikt u <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       Omdat deze methode heeft toegang het register tot, moet u de juiste registermachtigingen hebben op de opgegeven server. anders wordt een <xref:System.Security.SecurityException>gegenereerd.</xref:System.Security.SecurityException>      > [!NOTE] > Wilt zoeken naar een gebeurtenisbron in Windows Vista en hoger of Windows Server 2003, moet u over administratorbevoegdheden beschikken.   >> De reden voor deze vereiste is dat alle gebeurtenislogboeken, met inbegrip van beveiliging, moet worden gezocht om te bepalen of de gebeurtenisbron uniek is. Vanaf Windows Vista, hebben gebruikers geen toestemming voor toegang tot het beveiligingslogboek; daarom een <xref:System.Security.SecurityException>gegenereerd.</xref:System.Security.SecurityException>   >> Vanaf Windows Vista Gebruikersaccountbeheer (UAC) bepaalt de bevoegdheden van een gebruiker. Als u lid zijn van de ingebouwde groep Administrators, kunt u twee runtime-toegangstokens zijn toegewezen: een standaardgebruikerstoegang en een token voor beheerderstoegang. U bent standaard in de standaard gebruikersrol. Voor het uitvoeren van de code die toegang heeft tot prestatiemeteritems, moet u eerst uw bevoegdheden van een standaardgebruiker uitbreiden naar beheerder. U kunt dit doen wanneer u een toepassing begint met de rechtermuisknop op het pictogram van de toepassing die aangeeft dat u wilt uitvoeren als beheerder.      > [!NOTE] > Een service die wordt uitgevoerd onder de <xref:System.ServiceProcess.ServiceAccount>account niet beschikt over de vereiste bevoegdheden voor het uitvoeren van deze methode.</xref:System.ServiceProcess.ServiceAccount> De oplossing is om te controleren of de gebeurtenisbron voorkomt in de <xref:System.ServiceProcess.ServiceInstaller>, en als deze niet bestaat, voor het maken van de bron in het installatieprogramma.</xref:System.ServiceProcess.ServiceInstaller>       Omdat u niet kunt een nieuwe bron de naam van een bestaande gegevensbron op dezelfde computer geeft, gebruiken deze methode voordat u probeert aan te roepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>ervoor te zorgen dat een bron met de naam die is opgegeven door `source` nog niet bestaat op de computer.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> De `source` en `machineName` parameters zijn niet hoofdlettergevoelig.       <xref:System.Diagnostics.EventLog.SourceExists%2A>is een `static` methode, zodat deze kan worden aangeroepen voor de klasse zelf.</xref:System.Diagnostics.EventLog.SourceExists%2A> Het is niet nodig voor het maken van een exemplaar van <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> aanroepen</xref:System.Diagnostics.EventLog>"
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_16_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_16_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_16_1.vb)]"
  syntax:
    content: public static bool SourceExists (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "De naam van de gegevensbron."
    - id: machineName
      type: System.String
      description: "De naam van de computer waarop u wilt zoeken, of &quot;. &quot; voor de lokale computer."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de bron van de gebeurtenis is geregistreerd op de opgegeven computer. anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>machineName</code>is een ongeldige computernaam."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>is niet gevonden, maar sommige of alle gebeurtenislogboeken kan niet worden gezocht."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van het object dat wordt gebruikt voor het marshallen van aanroepen van de gebeurtenis-handler als gevolg van een <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> vermelding gebeurtenis geschreven."
  remarks: "Wanneer SynchronizingObject is `null`, methoden afhandeling van de <xref:System.Diagnostics.EventLog.EntryWritten>gebeurtenis worden aangeroepen voor een thread van de threadgroep system.</xref:System.Diagnostics.EventLog.EntryWritten> Zie voor meer informatie over thread systeemgroepen <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Wanneer de <xref:System.Diagnostics.EventLog.EntryWritten>gebeurtenis wordt verwerkt door een visual Windows Forms-onderdeel, zoals een knop, toegang tot het onderdeel via de threadgroep systeem werkt mogelijk niet of kan leiden tot een uitzondering.</xref:System.Diagnostics.EventLog.EntryWritten> Dit voorkomen door SynchronizingObject in te stellen op een Windows Forms-onderdeel, waardoor de methoden afhandeling van de <xref:System.Diagnostics.EventLog.EntryWritten>gebeurtenis moet worden aangeroepen op dezelfde thread waarop het onderdeel is gemaakt.</xref:System.Diagnostics.EventLog.EntryWritten>       Als de <xref:System.Diagnostics.EventLog>wordt gebruikt binnen [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] in een Windows Forms-designer SynchronizingObject automatisch ingesteld op het besturingselement dat de <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> Als u bijvoorbeeld een <xref:System.Diagnostics.EventLog>op een ontwerpfunctie voor Form1 (die eigenschappen overneemt van <xref:System.Windows.Forms.Form>) de eigenschap SynchronizingObject van <xref:System.Diagnostics.EventLog>is ingesteld op het exemplaar van Form1.</xref:System.Diagnostics.EventLog> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "De <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> gebruikt voor het marshallen van aanroepen van gebeurtenis-handler als gevolg van een <xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;> </xref> gebeurtenis in het gebeurtenislogboek."
  overload: System.Diagnostics.EventLog.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  id: WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een vermelding van het type informatie, met de tekst van het opgegeven bericht naar het gebeurtenislogboek geschreven."
  remarks: "Deze methode gebruikt een vermelding informatie schrijven naar het gebeurtenislogboek die zijn gekoppeld aan dit <xref:System.Diagnostics.EventLog>exemplaar.</xref:System.Diagnostics.EventLog> Als u een andere wilt <xref:System.Diagnostics.EventLogEntryType>, gebruikt u een andere overload van <xref:System.Diagnostics.EventLog.WriteEntry%2A>.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLogEntryType> opgeven      > [!NOTE] > De `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden.       U stelt de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap op uw <xref:System.Diagnostics.EventLog>onderdeel voordat u schrijven vermeldingen in het logboek kunt.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven.       Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       Als de bron die is opgegeven in de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap van dit <xref:System.Diagnostics.EventLog>exemplaar is niet geregistreerd op de computer waarop het onderdeel wordt geschreven, <xref:System.Diagnostics.EventLog.WriteEntry%2A>aanroepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>en registreert u de bron.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Als u geen opgeeft een <xref:System.Diagnostics.EventLog.MachineName%2A>voor uw <xref:System.Diagnostics.EventLog>exemplaar voordat u aanroepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>of <xref:System.Diagnostics.EventLog.WriteEntry%2A>, de lokale computer (&quot;. &quot;) wordt verondersteld.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Als het systeem moet registreren de <xref:System.Diagnostics.EventLog.Source%2A>via een aanroep van <xref:System.Diagnostics.EventLog.WriteEntry%2A>en de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap is niet ingesteld op uw <xref:System.Diagnostics.EventLog>exemplaar, het logboek wordt standaard ingesteld op het toepassingslogboek.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Veel van de hierboven vermelde uitzonderingen worden gegenereerd door fouten opgetreden tijdens het proces van registreren van de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. De <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode de opgegeven tekenreeks schrijft rechtstreeks naar het gebeurtenislogboek; gebruikt een bronbestand lokaliseerbare bericht niet.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Gebruik de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode gebeurtenissen met behulp van een bronbestand gelokaliseerde bericht schrijven.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als u een vermelding in het schrijven naar een externe computer, de waarde van het bericht (tekenreeks) mogelijk niet wat u verwacht als de externe computer .NET Framework niet wordt uitgevoerd.      > [!NOTE] > Als de `message` parameter een null-teken bevat, wordt het bericht in het gebeurtenislogboek wordt beëindigd bij de null-teken."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_7_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_7_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_7_1.vb)]"
  syntax:
    content: public void WriteEntry (string message);
    parameters:
    - id: message
      type: System.String
      description: "De tekenreeks om te schrijven naar het gebeurtenislogboek."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een fout, waarschuwing, informatie, geslaagde of de vermelding is mislukt met de opgegeven tekst schrijft in het gebeurtenislogboek."
  remarks: "Gebruik deze methode om te schrijven geen invoer van een opgegeven <xref:System.Diagnostics.EventLogEntryType>naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLogEntryType> De `type` is aangegeven door een pictogram en tekst in de kolom Type in de logboeken voor een logboek.      > [!NOTE] > De `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden.       U stelt de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap op uw <xref:System.Diagnostics.EventLog>onderdeel voordat u schrijven vermeldingen in het logboek kunt.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven.       Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       Als de bron die is opgegeven in de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap van dit <xref:System.Diagnostics.EventLog>exemplaar is niet geregistreerd op de computer waarop het onderdeel wordt geschreven, <xref:System.Diagnostics.EventLog.WriteEntry%2A>aanroepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>en registreert u de bron.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Als u geen opgeeft een <xref:System.Diagnostics.EventLog.MachineName%2A>voor uw <xref:System.Diagnostics.EventLog>exemplaar voordat u aanroepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>of <xref:System.Diagnostics.EventLog.WriteEntry%2A>, de lokale computer (&quot;. &quot;) wordt verondersteld.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Als het systeem moet registreren de <xref:System.Diagnostics.EventLog.Source%2A>via een aanroep van <xref:System.Diagnostics.EventLog.WriteEntry%2A>en de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap is niet ingesteld op uw <xref:System.Diagnostics.EventLog>exemplaar, het logboek wordt standaard ingesteld op het toepassingslogboek.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Veel uitzonderingen die hierboven worden genoemd, worden gegenereerd door fouten opgetreden tijdens het proces van registreren van de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. De <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode de opgegeven tekenreeks schrijft rechtstreeks naar het gebeurtenislogboek; gebruikt een bronbestand lokaliseerbare bericht niet.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Gebruik de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode gebeurtenissen met behulp van een bronbestand gelokaliseerde bericht schrijven.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als u een vermelding in het schrijven naar een externe computer, de waarde van het bericht (tekenreeks) mogelijk niet wat u verwacht als de externe computer .NET Framework niet wordt uitgevoerd.      > [!NOTE] > Als de `message` parameter een null-teken bevat, wordt het bericht in het gebeurtenislogboek wordt beëindigd bij de null-teken."
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/cpp/19aeba79-224e-4604-90d9-_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/csharp/19aeba79-224e-4604-90d9-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/visualbasic/19aeba79-224e-4604-90d9-_1.vb)]"
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: message
      type: System.String
      description: "De tekenreeks om te schrijven naar het gebeurtenislogboek."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Een van de <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> waarden."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>is geen geldige <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  id: WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een item van het type informatie met tekst van het opgegeven bericht schrijft naar het gebeurtenislogboek, met behulp van de opgegeven geregistreerde gebeurtenisbron."
  remarks: "Gebruik deze methode een vermelding informatie naar het gebeurtenislogboek, met behulp van een bron die is al geregistreerd als een gebeurtenisbron voor het juiste logboek schrijven. Als u een andere wilt <xref:System.Diagnostics.EventLogEntryType>, gebruikt u een andere overload van <xref:System.Diagnostics.EventLog.WriteEntry%2A>.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLogEntryType> opgeven       U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven. Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. De <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode de opgegeven tekenreeks schrijft rechtstreeks naar het gebeurtenislogboek; gebruikt een bronbestand lokaliseerbare bericht niet.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Gebruik de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode gebeurtenissen met behulp van een bronbestand gelokaliseerde bericht schrijven.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als de `message` parameter een null-teken bevat, wordt het bericht in het gebeurtenislogboek wordt beëindigd bij de null-teken.   >> De `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_3_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_3_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_3_1.vb)]"
  syntax:
    content: public static void WriteEntry (string source, string message);
    parameters:
    - id: source
      type: System.String
      description: "De bron waarmee de toepassing is geregistreerd op de opgegeven computer."
    - id: message
      type: System.String
      description: "De tekenreeks om te schrijven naar het gebeurtenislogboek."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een item met de opgegeven berichttekst en de toepassing gedefinieerde gebeurtenis-id schrijft in het gebeurtenislogboek."
  remarks: "Deze methode gebruiken om te schrijven van een item met een door de toepassing gedefinieerde `eventID` naar het gebeurtenislogboek. De `eventID` samen met de bron unieke identificatie van een gebeurtenis. Elke toepassing kunt definiëren een eigen genummerde gebeurtenissen en de beschrijvende tekenreeksen waarnaar deze worden toegewezen. Gebeurtenis viewers weergeven deze tekenreekswaarden zodat de gebruiker begrijpen wat er mis ging en welke acties te ondernemen voorstellen.      > [!NOTE] > De `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden.       Naast de gebeurtenis-id, kunt u een <xref:System.Diagnostics.EventLogEntryType>voor de gebeurtenis wordt geschreven naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLogEntryType> De `type` is aangegeven door een pictogram en tekst in de kolom Type in de logboeken voor een logboek. Deze parameter geeft aan of het gebeurtenistype fout, waarschuwing, informatie, geslaagde of mislukte pogingen.       U stelt de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap op uw <xref:System.Diagnostics.EventLog>onderdeel voordat u schrijven vermeldingen in het logboek kunt.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven.       Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       Als de bron die is opgegeven in de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap van dit <xref:System.Diagnostics.EventLog>exemplaar is niet geregistreerd op de computer waarop het onderdeel wordt geschreven, <xref:System.Diagnostics.EventLog.WriteEntry%2A>aanroepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>en registreert u de bron.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Als u geen opgeeft een <xref:System.Diagnostics.EventLog.MachineName%2A>voor uw <xref:System.Diagnostics.EventLog>exemplaar voordat u aanroepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>of <xref:System.Diagnostics.EventLog.WriteEntry%2A>, de lokale computer (&quot;. &quot;) wordt verondersteld.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Als het systeem moet registreren de <xref:System.Diagnostics.EventLog.Source%2A>via een aanroep van <xref:System.Diagnostics.EventLog.WriteEntry%2A>en de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap is niet ingesteld op uw <xref:System.Diagnostics.EventLog>exemplaar, het logboek wordt standaard ingesteld op het toepassingslogboek.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Veel uitzonderingen die hierboven worden genoemd, worden gegenereerd door fouten opgetreden tijdens het proces van registreren van de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. De <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode de opgegeven tekenreeks schrijft rechtstreeks naar het gebeurtenislogboek; gebruikt een bronbestand lokaliseerbare bericht niet.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Gebruik de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode gebeurtenissen met behulp van een bronbestand gelokaliseerde bericht schrijven.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als u een vermelding in het schrijven naar een externe computer, de waarde van het bericht (tekenreeks) mogelijk niet wat u verwacht als de externe computer .NET Framework niet wordt uitgevoerd.      > [!NOTE] > Als de `message` parameter een null-teken bevat, wordt het bericht in het gebeurtenislogboek wordt beëindigd bij de null-teken."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/597042ed-6d84-4ccf-a867-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/597042ed-6d84-4ccf-a867-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/597042ed-6d84-4ccf-a867-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: message
      type: System.String
      description: "De tekenreeks om te schrijven naar het gebeurtenislogboek."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Een van de <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> waarden."
    - id: eventID
      type: System.Int32
      description: "De toepassingsspecifieke-id voor de gebeurtenis."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>is geen geldige <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Schrijft een fout, waarschuwing, informatie, geslaagde of de vermelding is mislukt met de opgegeven tekst in het gebeurtenislogboek, met behulp van de opgegeven geregistreerde gebeurtenisbron."
  remarks: "Gebruik deze methode om een item van een opgegeven <xref:System.Diagnostics.EventLogEntryType>in het gebeurtenislogboek met behulp van een bron is al geregistreerd als een gebeurtenisbron voor het juiste logboek</xref:System.Diagnostics.EventLogEntryType> schrijven De `type` is aangegeven door een pictogram en tekst in de kolom Type in de logboeken voor een logboek.      > [!NOTE] > De `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden.       U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven. Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. De <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode de opgegeven tekenreeks schrijft rechtstreeks naar het gebeurtenislogboek; gebruikt een bronbestand lokaliseerbare bericht niet.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Gebruik de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode gebeurtenissen met behulp van een bronbestand gelokaliseerde bericht schrijven.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als de `message` parameter een null-teken bevat, wordt het bericht in het gebeurtenislogboek wordt beëindigd bij de null-teken."
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/csharp/c03f903c-8fbd-441f-afe0-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/visualbasic/c03f903c-8fbd-441f-afe0-_1.vb)]\n [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/cpp/c03f903c-8fbd-441f-afe0-_1.cpp)]"
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: source
      type: System.String
      description: "De bron waarmee de toepassing is geregistreerd op de opgegeven computer."
    - id: message
      type: System.String
      description: "De tekenreeks om te schrijven naar het gebeurtenislogboek."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Een van de <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> waarden."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>is geen geldige <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een item met de opgegeven tekst, toepassingsspecifieke gebeurtenis-id en categorie toepassingsspecifieke schrijft naar het gebeurtenislogboek."
  remarks: "Deze methode gebruiken om te schrijven van een item met een door de toepassing gedefinieerde `category` naar het gebeurtenislogboek. De Event Viewer maakt gebruik van de categorie gebeurtenissen filteren door de bron van een gebeurtenis geschreven. De Event Viewer kan de categorie weergeven als een numerieke waarde, of kunt gebruiken de categorie als een resource-id om een tekenreeks gelokaliseerde categorie weer te geven.      > [!NOTE] > De `category` parameter moet een positieve waarde zijn. Negatieve categoriewaarden worden weergegeven als een aanvullende positief getal in de Event Viewer. Bijvoorbeeld, weergegeven een –10 als 65.526, – 1 als 65.535.      > [!NOTE] > De `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden.       Om weer te geven tekenreeksen voor gelokaliseerde categorie in de logboeken, moet u een gebeurtenisbron geconfigureerd met een bronbestand categorie en stel de `category` aan een resource-id in het bronbestand voor de categorie. Als de gebeurtenisbron beschikt niet over een bronbestand geconfigureerde categorie of de opgegeven `category` een tekenreeks in het bronbestand categorie worden niet geïndexeerd en vervolgens de Event Viewer de categoriewaarde van de numerieke voor deze vermelding geeft. Configureren van het bronbestand categorie, samen met het aantal tekenreeksen van de categorie in het bronbestand gebruikt <xref:System.Diagnostics.EventLogInstaller>of de <xref:System.Diagnostics.EventSourceCreationData>klasse.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Naast de categorie, kunt u een gebeurtenis-id voor de gebeurtenis naar het gebeurtenislogboek worden geschreven. Gebeurtenis-id&quot;s, samen met de gegevensbron is een unieke identificatie voor een gebeurtenis. Elke toepassing kunt definiëren een eigen genummerde gebeurtenissen en de beschrijvende tekenreeksen waarnaar deze worden toegewezen. Gebeurtenis viewers weergeven deze tekenreekswaarden zodat de gebruiker begrijpen wat er mis ging en welke acties te ondernemen voorstellen.       Ten slotte kunt u een <xref:System.Diagnostics.EventLogEntryType>voor de gebeurtenis wordt geschreven naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLogEntryType> De `type` is aangegeven door een pictogram en tekst in de kolom Type in de logboeken voor een logboek. Deze parameter geeft aan of het gebeurtenistype fout, waarschuwing, informatie, geslaagde of mislukte pogingen.       U stelt de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap op uw <xref:System.Diagnostics.EventLog>onderdeel voordat u schrijven vermeldingen in het logboek kunt.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven.       Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       Als de bron die is opgegeven in de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap van dit <xref:System.Diagnostics.EventLog>exemplaar is niet geregistreerd op de computer waarop het onderdeel wordt geschreven, <xref:System.Diagnostics.EventLog.WriteEntry%2A>aanroepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>en registreert u de bron.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Als u geen opgeeft een <xref:System.Diagnostics.EventLog.MachineName%2A>voor uw <xref:System.Diagnostics.EventLog>exemplaar voordat u aanroepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>of <xref:System.Diagnostics.EventLog.WriteEntry%2A>, de lokale computer (&quot;. &quot;) wordt verondersteld.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Als het systeem moet registreren de <xref:System.Diagnostics.EventLog.Source%2A>via een aanroep van <xref:System.Diagnostics.EventLog.WriteEntry%2A>en de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap is niet ingesteld op uw <xref:System.Diagnostics.EventLog>exemplaar, het logboek wordt standaard ingesteld op het toepassingslogboek.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Veel uitzonderingen die hierboven worden genoemd, worden gegenereerd door fouten opgetreden tijdens het proces van registreren van de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. De <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode de opgegeven tekenreeks schrijft rechtstreeks naar het gebeurtenislogboek; gebruikt een bronbestand lokaliseerbare bericht niet.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Gebruik de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode gebeurtenissen met behulp van een bronbestand gelokaliseerde bericht schrijven.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als u een vermelding in het schrijven naar een externe computer, de waarde van het bericht (tekenreeks) mogelijk niet wat u verwacht als de externe computer .NET Framework niet wordt uitgevoerd.      > [!NOTE] > Als de `message` parameter een null-teken bevat, wordt het bericht in het gebeurtenislogboek wordt beëindigd bij de null-teken."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/b3db94bc-a96c-4168-a8f0-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/b3db94bc-a96c-4168-a8f0-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/b3db94bc-a96c-4168-a8f0-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: message
      type: System.String
      description: "De tekenreeks om te schrijven naar het gebeurtenislogboek."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Een van de <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> waarden."
    - id: eventID
      type: System.Int32
      description: "De toepassingsspecifieke-id voor de gebeurtenis."
    - id: category
      type: System.Int16
      description: "De toepassingsspecifieke subcategorie die zijn gekoppeld aan het bericht."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>is geen geldige <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een item met de opgegeven berichttekst en de toepassing gedefinieerde gebeurtenis-id schrijft in het gebeurtenislogboek, met behulp van de opgegeven geregistreerde gebeurtenisbron."
  remarks: "Deze methode gebruiken om te schrijven van een item met een door de toepassing gedefinieerde `eventID` naar het gebeurtenislogboek al een bron gebruiken als een gebeurtenisbron voor het juiste logboek geregistreerd. De `eventID`, samen met de bron, bevatten de unieke identificatie een gebeurtenis. Elke toepassing kunt definiëren een eigen genummerde gebeurtenissen en de beschrijvende tekenreeksen waarnaar deze worden toegewezen. Deze tekenreeksen aanwezig gebeurtenis viewers voor de gebruiker zodat de gebruiker begrijpen wat er mis ging en welke acties te ondernemen voorstellen.      > [!NOTE] > De `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden.       Naast de gebeurtenis-id en deze overbelasting van de <xref:System.Diagnostics.EventLog.WriteEntry%2A>kunt u een opgeven <xref:System.Diagnostics.EventLogEntryType>voor de gebeurtenis wordt geschreven naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLogEntryType> </xref:System.Diagnostics.EventLog.WriteEntry%2A> De `type` is aangegeven door een pictogram en tekst in de kolom Type in de logboeken voor een logboek. Deze parameter geeft aan of het gebeurtenistype fout, waarschuwing, informatie, geslaagde of mislukte pogingen.       U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven. Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. De <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode de opgegeven tekenreeks schrijft rechtstreeks naar het gebeurtenislogboek; gebruikt een bronbestand lokaliseerbare bericht niet.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Gebruik de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode gebeurtenissen met behulp van een bronbestand gelokaliseerde bericht schrijven.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als de `message` parameter een null-teken bevat, wordt het bericht in het gebeurtenislogboek wordt beëindigd bij de null-teken."
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_4#1](~/add/codesnippet/csharp/2d8498b8-a54d-48c9-9ee7-_1.cs)]
     [!code-cpp[EventLog_WriteEntry_4#1](~/add/codesnippet/cpp/2d8498b8-a54d-48c9-9ee7-_1.cpp)]
     [!code-vb[EventLog_WriteEntry_4#1](~/add/codesnippet/visualbasic/2d8498b8-a54d-48c9-9ee7-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: source
      type: System.String
      description: "De bron waarmee de toepassing is geregistreerd op de opgegeven computer."
    - id: message
      type: System.String
      description: "De tekenreeks om te schrijven naar het gebeurtenislogboek."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Een van de <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> waarden."
    - id: eventID
      type: System.Int32
      description: "De toepassingsspecifieke-id voor de gebeurtenis."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>is geen geldige <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een item met de opgegeven tekst, toepassingsspecifieke gebeurtenis-id en categorie toepassingsspecifieke schrijft naar het gebeurtenislogboek en worden binaire gegevens toegevoegd aan het bericht."
  remarks: "Gebruik deze overbelasting toepassingsspecifieke gebeurtenis-specifieke gegevens naar het gebeurtenislogboek schrijven. Deze gegevens; niet worden geïnterpreteerd door de Event Viewer onbewerkte gegevens worden alleen in een gecombineerde hexadecimaal getal en tekst indeling weergegeven. Gebeurtenis-specifieke gegevens gebruiken spaarzaam, met inbegrip van deze alleen als u er zeker van te zijn dat dit is handig voor iemand foutopsporing van het probleem. U kunt ook gebeurtenis-specifieke gegevens gebruiken voor het opslaan van informatie die de toepassing onafhankelijk van de Event Viewer kan verwerken. U kunt bijvoorbeeld een viewer schrijven specifiek voor uw gebeurtenissen of schrijf een programma dat het logboekbestand wordt gescand en maakt rapporten die informatie van de gebeurtenis-specifieke gegevens bevatten.       Naast de binaire gegevens, kunt u een categorie toepassingsspecifieke en een toepassingsspecifieke gebeurtenis-id opgeven. De Event Viewer maakt gebruik van de categorie gebeurtenissen filteren door de bron van een gebeurtenis geschreven. De Event Viewer kan de categorie weergeven als een numerieke waarde, of kunt gebruiken de categorie als een resource-id om een tekenreeks gelokaliseerde categorie weer te geven.      > [!NOTE] > De `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden.      > [!NOTE] > De `category` parameter moet een positieve waarde zijn. Negatieve categoriewaarden worden weergegeven als een aanvullende positief getal in de Event Viewer. Bijvoorbeeld, weergegeven een –10 als 65.526, – 1 als 65.535.       Om weer te geven tekenreeksen voor gelokaliseerde categorie in de logboeken, moet u een gebeurtenisbron geconfigureerd met een bronbestand categorie en stel de `category` aan een resource-id in het bronbestand voor de categorie. Als de gebeurtenisbron beschikt niet over een bronbestand geconfigureerde categorie of de opgegeven `category` een tekenreeks in het bronbestand categorie worden niet geïndexeerd en vervolgens de Event Viewer de categoriewaarde van de numerieke voor deze vermelding geeft. Configureren van het bronbestand categorie, samen met het aantal tekenreeksen van de categorie in het bronbestand gebruikt <xref:System.Diagnostics.EventLogInstaller>of de <xref:System.Diagnostics.EventSourceCreationData>klasse.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Gebeurtenis-id&quot;s, samen met de gegevensbron is een unieke identificatie voor een gebeurtenis. Elke toepassing kunt definiëren een eigen genummerde gebeurtenissen en de beschrijvende tekenreeksen waarnaar deze worden toegewezen. Gebeurtenis viewers weergeven deze tekenreekswaarden zodat de gebruiker begrijpen wat er mis ging en welke acties te ondernemen voorstellen.       Ten slotte kunt u een <xref:System.Diagnostics.EventLogEntryType>voor de gebeurtenis wordt geschreven naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLogEntryType> De `type` is aangegeven door een pictogram en tekst in de kolom Type in de logboeken voor een logboek. Deze parameter geeft aan of het gebeurtenistype fout, waarschuwing, informatie, geslaagde of mislukte pogingen.       U stelt de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap op uw <xref:System.Diagnostics.EventLog>onderdeel voordat u schrijven vermeldingen in het logboek kunt.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven.       Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       Als de bron die is opgegeven in de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap van dit <xref:System.Diagnostics.EventLog>exemplaar is niet geregistreerd op de computer waarop het onderdeel wordt geschreven, <xref:System.Diagnostics.EventLog.WriteEntry%2A>aanroepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>en registreert u de bron.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Als u geen opgeeft een <xref:System.Diagnostics.EventLog.MachineName%2A>voor uw <xref:System.Diagnostics.EventLog>exemplaar voordat u aanroepen <xref:System.Diagnostics.EventLog.CreateEventSource%2A>of <xref:System.Diagnostics.EventLog.WriteEntry%2A>, de lokale computer (&quot;. &quot;) wordt verondersteld.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Als het systeem moet registreren de <xref:System.Diagnostics.EventLog.Source%2A>via een aanroep van <xref:System.Diagnostics.EventLog.WriteEntry%2A>en de <xref:System.Diagnostics.EventLog.Log%2A>eigenschap is niet ingesteld op uw <xref:System.Diagnostics.EventLog>exemplaar, het logboek wordt standaard ingesteld op het toepassingslogboek.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Veel uitzonderingen die hierboven worden genoemd, worden gegenereerd door fouten opgetreden tijdens het proces van registreren van de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. De <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode de opgegeven tekenreeks schrijft rechtstreeks naar het gebeurtenislogboek; gebruikt een bronbestand lokaliseerbare bericht niet.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Gebruik de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode gebeurtenissen met behulp van een bronbestand gelokaliseerde bericht schrijven.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als u een vermelding in het schrijven naar een externe computer, de waarde van het bericht (tekenreeks) mogelijk niet wat u verwacht als de externe computer .NET Framework niet wordt uitgevoerd.      > [!NOTE] > Als de `message` parameter een null-teken bevat, wordt het bericht in het gebeurtenislogboek wordt beëindigd bij de null-teken."
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_5#1](~/add/codesnippet/csharp/1c6518b6-dc55-4c74-9028-_1.cs)]
     [!code-vb[EventLog_WriteEntry_5#1](~/add/codesnippet/visualbasic/1c6518b6-dc55-4c74-9028-_1.vb)]
     [!code-cpp[EventLog_WriteEntry_5#1](~/add/codesnippet/cpp/1c6518b6-dc55-4c74-9028-_1.cpp)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: message
      type: System.String
      description: "De tekenreeks om te schrijven naar het gebeurtenislogboek."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Een van de <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> waarden."
    - id: eventID
      type: System.Int32
      description: "De toepassingsspecifieke-id voor de gebeurtenis."
    - id: category
      type: System.Int16
      description: "De toepassingsspecifieke subcategorie die zijn gekoppeld aan het bericht."
    - id: rawData
      type: System.Byte[]
      description: "Een bytematrix die de binaire gegevens die zijn gekoppeld aan de vermelding bevat."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>is geen geldige <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een item met de opgegeven tekst, toepassingsspecifieke gebeurtenis-id en categorie toepassingsspecifieke schrijft naar het gebeurtenislogboek, met behulp van de opgegeven geregistreerde gebeurtenisbron. De <code> category </code> kunnen worden gebruikt door de Event Viewer gebeurtenissen in het logboek filteren."
  remarks: "Deze methode gebruiken om te schrijven van een item met een door de toepassing gedefinieerde `category` met behulp van een bron die is al geregistreerd als een gebeurtenisbron voor het juiste logboek in het gebeurtenislogboek. De Event Viewer maakt gebruik van de categorie gebeurtenissen filteren door de bron van een gebeurtenis geschreven. De Event Viewer kan de categorie weergeven als een numerieke waarde, of kunt gebruiken de categorie als een resource-id om een tekenreeks gelokaliseerde categorie weer te geven.      > [!NOTE] > De `category` parameter moet een positieve waarde zijn. Negatieve categoriewaarden worden weergegeven als een aanvullende positief getal in de Event Viewer. Bijvoorbeeld, weergegeven een –10 als 65.526, – 1 als 65.535.       Om weer te geven tekenreeksen voor gelokaliseerde categorie in de logboeken, moet u een gebeurtenisbron geconfigureerd met een bronbestand categorie en stel de `category` aan een resource-id in het bronbestand voor de categorie. Als de gebeurtenisbron beschikt niet over een bronbestand geconfigureerde categorie of de opgegeven `category` een tekenreeks in het bronbestand categorie worden niet geïndexeerd en vervolgens de Event Viewer de categoriewaarde van de numerieke voor deze vermelding geeft. Configureren van het bronbestand categorie, samen met het aantal tekenreeksen van de categorie in het bronbestand gebruikt <xref:System.Diagnostics.EventLogInstaller>of de <xref:System.Diagnostics.EventSourceCreationData>klasse.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Naast de categorie, kunt u een gebeurtenis-id voor de gebeurtenis naar het gebeurtenislogboek worden geschreven. Gebeurtenis-id&quot;s, samen met de gegevensbron is een unieke identificatie voor een gebeurtenis. Elke toepassing kunt definiëren een eigen genummerde gebeurtenissen en de beschrijvende tekenreeksen waarnaar deze worden toegewezen. Gebeurtenis viewers weergeven deze tekenreekswaarden zodat de gebruiker begrijpen wat er mis ging en welke acties te ondernemen voorstellen.       Ten slotte kunt u een <xref:System.Diagnostics.EventLogEntryType>voor de gebeurtenis wordt geschreven naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLogEntryType> De `type` is aangegeven door een pictogram en tekst in de kolom Type in de logboeken voor een logboek. Deze parameter geeft aan of het gebeurtenistype fout, waarschuwing, informatie, geslaagde of mislukte pogingen.       U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven. Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. De <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode de opgegeven tekenreeks schrijft rechtstreeks naar het gebeurtenislogboek; gebruikt een bronbestand lokaliseerbare bericht niet.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Gebruik de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode gebeurtenissen met behulp van een bronbestand gelokaliseerde bericht schrijven.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als de `message` parameter een null-teken bevat, wordt het bericht in het gebeurtenislogboek wordt beëindigd bij de null-teken.   >> De `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#1](~/add/codesnippet/cpp/189fd615-c100-4e72-9c0b-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#1](~/add/codesnippet/csharp/189fd615-c100-4e72-9c0b-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#1](~/add/codesnippet/visualbasic/189fd615-c100-4e72-9c0b-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: source
      type: System.String
      description: "De bron waarmee de toepassing is geregistreerd op de opgegeven computer."
    - id: message
      type: System.String
      description: "De tekenreeks om te schrijven naar het gebeurtenislogboek."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Een van de <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> waarden."
    - id: eventID
      type: System.Int32
      description: "De toepassingsspecifieke-id voor de gebeurtenis."
    - id: category
      type: System.Int16
      description: "De toepassingsspecifieke subcategorie die zijn gekoppeld aan het bericht."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>is geen geldige <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een item met de opgegeven tekst, toepassingsspecifieke gebeurtenis-id en categorie toepassingsspecifieke schrijft naar het gebeurtenislogboek (met behulp van de opgegeven geregistreerde gebeurtenisbron) en worden binaire gegevens toegevoegd aan het bericht."
  remarks: "Gebruik deze methode toepassingsspecifieke gebeurtenis-specifieke gegevens naar het gebeurtenislogboek, met behulp van een bron is al geregistreerd als een gebeurtenisbron voor het juiste logboek schrijven. Deze gegevens; niet worden geïnterpreteerd door de Event Viewer onbewerkte gegevens worden alleen in een gecombineerde hexadecimaal getal en tekst indeling weergegeven. Spaarzaam; gebeurtenis-specifieke gegevens gebruiken neemt u deze alleen als u er zeker van te zijn dat deze wordt nuttig zijn. U kunt ook gebeurtenis-specifieke gegevens gebruiken voor het opslaan van informatie die de toepassing onafhankelijk van de Event Viewer kan verwerken. U kunt bijvoorbeeld een viewer schrijven specifiek voor uw gebeurtenissen of schrijf een programma dat het logboekbestand wordt gescand en maakt rapporten die informatie van de gebeurtenis-specifieke gegevens bevatten.       Naast de binaire gegevens, kunt u een categorie toepassingsspecifieke en een toepassingsspecifieke gebeurtenis-id opgeven. De Event Viewer maakt gebruik van de categorie gebeurtenissen filteren door de bron van een gebeurtenis geschreven. De Event Viewer kan de categorie weergeven als een numerieke waarde, of kunt gebruiken de categorie als een resource-id om een tekenreeks gelokaliseerde categorie weer te geven.      > [!NOTE] > De `category` parameter moet een positieve waarde zijn. Negatieve categoriewaarden worden weergegeven als een aanvullende positief getal in de Event Viewer. Bijvoorbeeld, wordt een –10 weergegeven als 65.526, – 1 als 65.535.       Om weer te geven tekenreeksen voor gelokaliseerde categorie in de logboeken, moet u een gebeurtenisbron geconfigureerd met een bronbestand categorie en stel de `category` aan een resource-id in het bronbestand voor de categorie. Als de gebeurtenisbron beschikt niet over een bronbestand geconfigureerde categorie of de opgegeven `category` een tekenreeks in het bronbestand categorie worden niet geïndexeerd en vervolgens de Event Viewer de categoriewaarde van de numerieke voor deze vermelding geeft. Configureren van het bronbestand categorie, samen met het aantal tekenreeksen van de categorie in het bronbestand gebruikt <xref:System.Diagnostics.EventLogInstaller>of de <xref:System.Diagnostics.EventSourceCreationData>klasse.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Gebeurtenis-id&quot;s, samen met de gegevensbron is een unieke identificatie voor een gebeurtenis. Elke toepassing kunt definiëren een eigen genummerde gebeurtenissen en de beschrijvende tekenreeksen waarnaar deze worden toegewezen. Gebeurtenis viewers weergeven deze tekenreekswaarden zodat de gebruiker begrijpen wat er mis ging en welke acties te ondernemen voorstellen.       Ten slotte kunt u een <xref:System.Diagnostics.EventLogEntryType>voor de gebeurtenis wordt geschreven naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLogEntryType> De `type` is aangegeven door een pictogram en tekst in de kolom Type in de logboeken voor een logboek. Deze parameter geeft aan of het gebeurtenistype fout, waarschuwing, informatie, geslaagde of mislukte pogingen.       U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven. Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. De <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode de opgegeven tekenreeks schrijft rechtstreeks naar het gebeurtenislogboek; gebruikt een bronbestand lokaliseerbare bericht niet.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Gebruik de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode gebeurtenissen met behulp van een bronbestand gelokaliseerde bericht schrijven.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als de `message` parameter een null-teken bevat, wordt het bericht in het gebeurtenislogboek wordt beëindigd bij de null-teken.   >> De `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#2](~/add/codesnippet/cpp/0b90a83a-dcc8-46e6-a8db-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#2](~/add/codesnippet/csharp/0b90a83a-dcc8-46e6-a8db-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#2](~/add/codesnippet/visualbasic/0b90a83a-dcc8-46e6-a8db-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: source
      type: System.String
      description: "De bron waarmee de toepassing is geregistreerd op de opgegeven computer."
    - id: message
      type: System.String
      description: "De tekenreeks om te schrijven naar het gebeurtenislogboek."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Een van de <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> waarden."
    - id: eventID
      type: System.Int32
      description: "De toepassingsspecifieke-id voor de gebeurtenis."
    - id: category
      type: System.Int16
      description: "De toepassingsspecifieke subcategorie die zijn gekoppeld aan het bericht."
    - id: rawData
      type: System.Byte[]
      description: "Een bytematrix die de binaire gegevens die zijn gekoppeld aan de vermelding bevat."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>is geen geldige <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een gelokaliseerde vermelding schrijft in het gebeurtenislogboek."
  remarks: "Gebruik deze methode een gelokaliseerde item in het gebeurtenislogboek schrijven. U opgeven de eigenschappen van gebeurtenis met resource-id in plaats van string-waarden. De Event Viewer maakt gebruik van de resource-id&quot;s om de bijbehorende tekenreeksen van de gelokaliseerde bronbestand voor de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> weer te geven Voordat u gebeurtenissen resource-id&quot;s schrijven, moet u de bron registreren met het bijbehorende bronbestand.       De invoer `instance` exemplaar Hiermee geeft u de eigenschappen en gebeurtenisbericht. Stel de <xref:System.Diagnostics.EventInstance.InstanceId%2A>van de `instance` invoer voor de gedefinieerde bericht in het bronbestand voor de bericht-resource.</xref:System.Diagnostics.EventInstance.InstanceId%2A> U kunt desgewenst instellen de <xref:System.Diagnostics.EventInstance.CategoryId%2A>en <xref:System.Diagnostics.EventInstance.EntryType%2A>van de `instance` invoer voor het definiëren van het type categorie en gebeurtenis van uw invoer gebeurtenis.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> U kunt ook een matrix met tekenreeksen worden ingevoegd in de tekst van het gelokaliseerde taalonafhankelijke opgeven. Stel `values` naar `null` als het gebeurtenisbericht bevat geen opmaak tijdelijke aanduidingen voor tekenreeksen voor parametervervanging.       U moet de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap op uw <xref:System.Diagnostics.EventLog>onderdeel voordat u <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> instellen De opgegeven bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen in het logboek; de bron moet minimaal een bronbestand bericht is gedefinieerd.       U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven. Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. Gebruik de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode als uw toepassing tekenreekswaarden rechtstreeks naar het gebeurtenislogboek schrijft.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als u een vermelding in het schrijven naar een externe computer, de waarde van de `message` tekenreeks mogelijk niet wat u verwacht als de externe computer .NET Framework niet wordt uitgevoerd. Ook de `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden."
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/6a714dbf-bcbc-4f5a-a8b4-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/6a714dbf-bcbc-4f5a-a8b4-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/6a714dbf-bcbc-4f5a-a8b4-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Een <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> -exemplaar dat een gelokaliseerde logboekvermelding vertegenwoordigt."
    - id: values
      type: System.Object[]
      description: "Een matrix met tekenreeksen samen te voegen in de berichttekst van vermelding in het gebeurtenislogboek."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Schrijft een logboekvermelding met de opgegeven gebeurtenisgegevens, bericht vervangende tekenreeksen en bijbehorende binaire gegevens."
  remarks: "Gebruik deze methode een gelokaliseerde vermelding met extra gebeurtenis-specifieke gegevens naar het gebeurtenislogboek schrijven. U opgeven de eigenschappen van gebeurtenis met resource-id in plaats van string-waarden. De Event Viewer maakt gebruik van de resource-id&quot;s om de bijbehorende tekenreeksen van de gelokaliseerde bronbestand voor de <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> weer te geven Voordat u gebeurtenissen resource-id&quot;s schrijven, moet u de bron registreren met het bijbehorende bronbestand.       De invoer `instance` exemplaar Hiermee geeft u de eigenschappen en gebeurtenisbericht. Stel de <xref:System.Diagnostics.EventInstance.InstanceId%2A>van de `instance` invoer voor de gedefinieerde bericht in het bronbestand voor de bericht-resource.</xref:System.Diagnostics.EventInstance.InstanceId%2A> U kunt desgewenst instellen de <xref:System.Diagnostics.EventInstance.CategoryId%2A>en <xref:System.Diagnostics.EventInstance.EntryType%2A>van de `instance` invoer voor het definiëren van het type categorie en gebeurtenis van uw invoer gebeurtenis.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> U kunt ook een matrix met tekenreeksen worden ingevoegd in de tekst van het gelokaliseerde taalonafhankelijke opgeven. Stel `values` naar `null` als het gebeurtenisbericht bevat geen opmaak tijdelijke aanduidingen voor tekenreeksen voor parametervervanging.       Binaire gegevens met een gebeurtenis geactiveerd wanneer het is nodig om extra informatie opgeven voor de gebeurtenis opgeven. Gebruik bijvoorbeeld de `data` parameter informatie op een specifieke fout op te nemen. De gekoppelde gebeurtenisgegevens; niet worden geïnterpreteerd door de Event Viewer de gegevens wordt weergegeven in een gecombineerde hexadecimaal getal en tekst-indeling. Spaarzaam; gebeurtenis-specifieke gegevens gebruiken neemt u deze alleen als u er zeker van te zijn dat deze wordt nuttig zijn. U kunt ook gebeurtenis-specifieke gegevens gebruiken voor het opslaan van informatie die de toepassing onafhankelijk van de Event Viewer kan verwerken. U kunt bijvoorbeeld een viewer schrijven specifiek voor uw gebeurtenissen of schrijf een programma dat het logboek gescand en maakt rapporten die informatie van de gebeurtenis-specifieke gegevens bevatten.       U moet de <xref:System.Diagnostics.EventLog.Source%2A>eigenschap op het <xref:System.Diagnostics.EventLog>onderdeel vóór onderdeel voordat u <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> instellen De opgegeven bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen in het logboek; de bron moet minimaal een bronbestand bericht is gedefinieerd.       U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven. Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.      > [!NOTE] > Als u geen opgeeft een <xref:System.Diagnostics.EventLog.MachineName%2A>voor uw <xref:System.Diagnostics.EventLog>exemplaar voordat u aanroepen <xref:System.Diagnostics.EventLog.WriteEvent%2A>, de lokale computer (&quot;. &quot;) wordt verondersteld.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. Gebruik de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode als uw toepassing tekenreekswaarden rechtstreeks naar het gebeurtenislogboek schrijft.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Als u een vermelding in het schrijven naar een externe computer, de waarde van de `message` tekenreeks mogelijk niet wat u verwacht als de externe computer .NET Framework niet wordt uitgevoerd. Ook de `message` tekenreeks mag niet %*n*, waarbij *n* is een geheel getal (bijvoorbeeld: %1), omdat de event viewer wordt dit beschouwd als een invoegingstekenreeks. Omdat een Internet-Protocol versie 6 (IPv6)-adres kan dit bevatten tekenreeks, kunt u een bericht met een IPv6-adres kan niet aanmelden."
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/9c997f17-0108-4c5c-b894-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/9c997f17-0108-4c5c-b894-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/9c997f17-0108-4c5c-b894-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Een <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> -exemplaar dat een gelokaliseerde logboekvermelding vertegenwoordigt."
    - id: data
      type: System.Byte[]
      description: "Een bytematrix die de binaire gegevens die zijn gekoppeld aan de vermelding bevat."
    - id: values
      type: System.Object[]
      description: "Een matrix met tekenreeksen samen te voegen in de berichttekst van vermelding in het gebeurtenislogboek."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een vermelding in gebeurtenislogboek met de gegeven gebeurtenis schrijft gegevens en het bericht vervangende tekenreeksen, met behulp van de opgegeven geregistreerde gebeurtenisbron."
  remarks: "Gebruik deze methode een gelokaliseerde item in het gebeurtenislogboek, met behulp van een bron is al geregistreerd als een gebeurtenisbron voor het juiste logboek schrijven. U opgeven de eigenschappen van gebeurtenis met resource-id in plaats van string-waarden. De Event Viewer maakt gebruik van de resource-id&quot;s om de bijbehorende tekenreeksen van het gelokaliseerde bronbestand voor de bron weer te geven. Voordat u gebeurtenissen resource-id&quot;s schrijven, moet u de bron registreren met het bijbehorende bronbestand.       De invoer `instance` exemplaar Hiermee geeft u de eigenschappen en gebeurtenisbericht. Stel de <xref:System.Diagnostics.EventInstance.InstanceId%2A>van de `instance` invoer voor de gedefinieerde bericht in het bronbestand voor de bericht-resource.</xref:System.Diagnostics.EventInstance.InstanceId%2A> U kunt desgewenst instellen de <xref:System.Diagnostics.EventInstance.CategoryId%2A>en <xref:System.Diagnostics.EventInstance.EntryType%2A>van de `instance` invoer voor het definiëren van het type categorie en gebeurtenis van uw invoer gebeurtenis.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> U kunt ook een matrix met tekenreeksen worden ingevoegd in de tekst van het gelokaliseerde taalonafhankelijke opgeven. Stel `values` naar `null` als het gebeurtenisbericht bevat geen opmaak tijdelijke aanduidingen voor tekenreeksen voor parametervervanging.       De opgegeven bron moet zijn geregistreerd voor een gebeurtenislogboek voordat u <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> De opgegeven bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen in het logboek; de bron moet minimaal een bronbestand bericht is gedefinieerd.       U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven. Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. Gebruik de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode als uw toepassing tekenreekswaarden rechtstreeks naar het gebeurtenislogboek schrijft.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/a57d89b3-94d2-4b9a-803c-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/a57d89b3-94d2-4b9a-803c-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/a57d89b3-94d2-4b9a-803c-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "De naam van de gebeurtenisbron geregistreerd voor de toepassing op de opgegeven computer."
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Een <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> -exemplaar dat een gelokaliseerde logboekvermelding vertegenwoordigt."
    - id: values
      type: System.Object[]
      description: "Een matrix met tekenreeksen samen te voegen in de berichttekst van vermelding in het gebeurtenislogboek."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Schrijft een gebeurtenis met de gegeven gebeurtenis-gegevens, bericht vervangende tekenreeksen, de logboekvermelding en binaire gegevens die zijn gekoppeld en met behulp van de opgegeven bron van gebeurtenis geregistreerd."
  remarks: "Gebruik deze methode een gelokaliseerde vermelding met extra gebeurtenis-specifieke gegevens naar het gebeurtenislogboek, met behulp van een bron is al geregistreerd als een gebeurtenisbron voor het juiste logboek schrijven. U opgeven de eigenschappen van gebeurtenis met resource-id in plaats van string-waarden. De Event Viewer maakt gebruik van de resource-id&quot;s om de bijbehorende tekenreeksen van het gelokaliseerde bronbestand voor de bron weer te geven. Voordat u gebeurtenissen resource-id&quot;s schrijven, moet u de bron registreren met het bijbehorende bronbestand.       De invoer `instance` exemplaar Hiermee geeft u de eigenschappen en gebeurtenisbericht. Stel de <xref:System.Diagnostics.EventInstance.InstanceId%2A>van de `instance` invoer voor de gedefinieerde bericht in het bronbestand voor de bericht-resource.</xref:System.Diagnostics.EventInstance.InstanceId%2A> U kunt desgewenst instellen de <xref:System.Diagnostics.EventInstance.CategoryId%2A>en <xref:System.Diagnostics.EventInstance.EntryType%2A>van de `instance` invoer voor het definiëren van het type categorie en gebeurtenis van uw invoer gebeurtenis.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> U kunt ook een matrix met tekenreeksen worden ingevoegd in de tekst van het gelokaliseerde taalonafhankelijke opgeven. Stel `values` naar `null` als het gebeurtenisbericht bevat geen opmaak tijdelijke aanduidingen voor tekenreeksen voor parametervervanging.       Binaire gegevens met een gebeurtenis geactiveerd wanneer het is nodig om extra informatie opgeven voor de gebeurtenis opgeven. Gebruik bijvoorbeeld de `data` parameter informatie op een specifieke fout op te nemen. De gekoppelde gebeurtenisgegevens; niet worden geïnterpreteerd door de Event Viewer de gegevens wordt weergegeven in een gecombineerde hexadecimaal getal en tekst-indeling. Spaarzaam; gebeurtenis-specifieke gegevens gebruiken neemt u deze alleen als u er zeker van te zijn dat deze wordt nuttig zijn. U kunt ook gebeurtenis-specifieke gegevens gebruiken voor het opslaan van informatie die de toepassing onafhankelijk van de Event Viewer kan verwerken. U kunt bijvoorbeeld een viewer schrijven specifiek voor uw gebeurtenissen of schrijf een programma dat het logboek gescand en maakt rapporten die informatie van de gebeurtenis-specifieke gegevens bevatten.       De opgegeven bron moet zijn geregistreerd voor een gebeurtenislogboek voordat u <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> De opgegeven bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen in het logboek; de bron moet minimaal een bronbestand bericht is gedefinieerd.       U moet maken en configureren van de gebeurtenisbron voordat het eerste item met de bron worden geschreven. Maak de nieuwe gebeurtenisbron tijdens de installatie van uw toepassing. Hierdoor kan de tijd voor het besturingssysteem in de lijst met bronnen van geregistreerde gebeurtenissen en de bijbehorende configuratie te vernieuwen. Als het besturingssysteem is niet vernieuwd voor de lijst met bronnen van gebeurtenissen en u probeert te schrijven van een gebeurtenis met de nieuwe bron, mislukt de bewerking schrijven. U kunt een nieuwe bron met een <xref:System.Diagnostics.EventLogInstaller>, of met behulp van de <xref:System.Diagnostics.EventLog.CreateEventSource%2A>methode.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> U moet beheerdersrechten hebben op de computer voor het maken van een nieuwe gebeurtenisbron.       De bron moet worden geconfigureerd voor het schrijven van gelokaliseerde vermeldingen of voor het schrijven van directe tekenreeksen. Gebruik de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode als uw toepassing tekenreekswaarden rechtstreeks naar het gebeurtenislogboek schrijft.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Als uw toepassing vermeldingen met resource-id&quot;s en tekenreekswaarden schrijft, moet u twee afzonderlijke gegevensbronnen registreren. Bijvoorbeeld een bron configureren met bronbestanden en gebruik vervolgens deze bron in de <xref:System.Diagnostics.EventLog.WriteEvent%2A>methode voor het schrijven van vermeldingen met behulp van de resource-id&quot;s naar het gebeurtenislogboek.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Maak vervolgens een andere bron zonder bronbestanden en gebruik deze bron in de <xref:System.Diagnostics.EventLog.WriteEntry%2A>methode tekenreeksen rechtstreeks naar het gebeurtenislogboek wordt geschreven met behulp van die bron schrijven.</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/d4971002-e0d1-493b-96f8-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/d4971002-e0d1-493b-96f8-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/d4971002-e0d1-493b-96f8-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "De naam van de gebeurtenisbron geregistreerd voor de toepassing op de opgegeven computer."
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "Een <xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> -exemplaar dat een gelokaliseerde logboekvermelding vertegenwoordigt."
    - id: data
      type: System.Byte[]
      description: "Een bytematrix die de binaire gegevens die zijn gekoppeld aan de vermelding bevat."
    - id: values
      type: System.Object[]
      description: "Een matrix met tekenreeksen samen te voegen in de berichttekst van vermelding in het gebeurtenislogboek."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De registersleutel voor het gebeurtenislogboek kan niet worden geopend."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het besturingssysteem, wordt er een fout opgetreden bij het schrijven van de gebeurtenisvermelding in het gebeurtenislogboek. Een Windows-foutcode is niet beschikbaar."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Diagnostics.EventLog.#ctor
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
- uid: System.Diagnostics.EventLog.BeginInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
- uid: System.Diagnostics.EventLog.Clear
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
- uid: System.Diagnostics.EventLog.Close
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
- uid: System.Diagnostics.EventSourceCreationData
  parent: System.Diagnostics
  isExternal: false
  name: EventSourceCreationData
  nameWithType: EventSourceCreationData
  fullName: System.Diagnostics.EventSourceCreationData
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
- uid: System.Diagnostics.EventLog.Delete(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
- uid: System.Diagnostics.EventLog.Entries
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
- uid: System.Diagnostics.EventLogEntryCollection
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryCollection
  nameWithType: EventLogEntryCollection
  fullName: System.Diagnostics.EventLogEntryCollection
- uid: System.Diagnostics.EventLog.EntryWritten
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
- uid: System.Diagnostics.EntryWrittenEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: EntryWrittenEventHandler
  nameWithType: EntryWrittenEventHandler
  fullName: System.Diagnostics.EntryWrittenEventHandler
- uid: System.Diagnostics.EventLog.Exists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
- uid: System.Diagnostics.EventLog.GetEventLogs
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
- uid: System.Diagnostics.EventLog[]
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog[]
  spec.csharp:
  - uid: System.Diagnostics.EventLog
    name: EventLog
    nameWithType: EventLog
    fullName: EventLog[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
- uid: System.Diagnostics.EventLog.Log
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
- uid: System.Diagnostics.EventLog.MachineName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
- uid: System.Diagnostics.OverflowAction
  parent: System.Diagnostics
  isExternal: false
  name: OverflowAction
  nameWithType: OverflowAction
  fullName: System.Diagnostics.OverflowAction
- uid: System.Diagnostics.EventLog.OverflowAction
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
- uid: System.Diagnostics.EventLog.Source
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
- uid: System.Diagnostics.EventLog.SynchronizingObject
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
- uid: System.Diagnostics.EventLogEntryType
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryType
  nameWithType: EventLogEntryType
  fullName: System.Diagnostics.EventLogEntryType
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
- uid: System.Diagnostics.EventInstance
  parent: System.Diagnostics
  isExternal: false
  name: EventInstance
  nameWithType: EventInstance
  fullName: System.Diagnostics.EventInstance
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.#ctor*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog
  nameWithType: EventLog.EventLog
- uid: System.Diagnostics.EventLog.BeginInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit
  nameWithType: EventLog.BeginInit
- uid: System.Diagnostics.EventLog.Clear*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear
  nameWithType: EventLog.Clear
- uid: System.Diagnostics.EventLog.Close*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close
  nameWithType: EventLog.Close
- uid: System.Diagnostics.EventLog.CreateEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource
  nameWithType: EventLog.CreateEventSource
- uid: System.Diagnostics.EventLog.Delete*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete
  nameWithType: EventLog.Delete
- uid: System.Diagnostics.EventLog.DeleteEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource
  nameWithType: EventLog.DeleteEventSource
- uid: System.Diagnostics.EventLog.Dispose*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose
  nameWithType: EventLog.Dispose
- uid: System.Diagnostics.EventLog.EnableRaisingEvents*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit
  nameWithType: EventLog.EndInit
- uid: System.Diagnostics.EventLog.Entries*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
- uid: System.Diagnostics.EventLog.Exists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists
  nameWithType: EventLog.Exists
- uid: System.Diagnostics.EventLog.GetEventLogs*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs
  nameWithType: EventLog.GetEventLogs
- uid: System.Diagnostics.EventLog.Log*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName
  nameWithType: EventLog.LogNameFromSourceName
- uid: System.Diagnostics.EventLog.MachineName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
- uid: System.Diagnostics.EventLog.MinimumRetentionDays*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy
  nameWithType: EventLog.ModifyOverflowPolicy
- uid: System.Diagnostics.EventLog.OverflowAction*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName
  nameWithType: EventLog.RegisterDisplayName
- uid: System.Diagnostics.EventLog.Source*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists
  nameWithType: EventLog.SourceExists
- uid: System.Diagnostics.EventLog.SynchronizingObject*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
- uid: System.Diagnostics.EventLog.WriteEntry*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry
  nameWithType: EventLog.WriteEntry
- uid: System.Diagnostics.EventLog.WriteEvent*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent
  nameWithType: EventLog.WriteEvent
