### YamlMime:ManagedReference
items:
- uid: System.IO.FileStream
  id: FileStream
  children:
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.CanRead
  - System.IO.FileStream.CanSeek
  - System.IO.FileStream.CanWrite
  - System.IO.FileStream.Dispose(System.Boolean)
  - System.IO.FileStream.EndRead(System.IAsyncResult)
  - System.IO.FileStream.EndWrite(System.IAsyncResult)
  - System.IO.FileStream.Finalize
  - System.IO.FileStream.Flush
  - System.IO.FileStream.Flush(System.Boolean)
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Handle
  - System.IO.FileStream.IsAsync
  - System.IO.FileStream.Length
  - System.IO.FileStream.Lock(System.Int64,System.Int64)
  - System.IO.FileStream.Name
  - System.IO.FileStream.Position
  - System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.ReadByte
  - System.IO.FileStream.SafeFileHandle
  - System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.SetLength(System.Int64)
  - System.IO.FileStream.Unlock(System.Int64,System.Int64)
  - System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
  type: Class
  summary: "Biedt een <xref:System.IO.Stream>voor een bestand ondersteunende synchrone en asynchrone lees- en schrijfbewerkingen.</xref:System.IO.Stream>       Om te bladeren naar de broncode van .NET Framework voor dit type, Zie de [Verwijzingsbron](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileStream class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output. You can use the [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations. Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. FileStream buffers input and output for better performance.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously. You specify this value when you create an instance of the FileStream class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter. When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method. When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.  \n  \n The <xref:System.IO.FileStream.Seek%2A> method supports random access to files. <xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file. This is done with byte offset reference point parameters. The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.  \n  \n> [!NOTE]\n>  Disk files always support random access. At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`. Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.  \n  \n If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.  \n  \n For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes. The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of FileStream objects based on file paths. The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the FileStream class.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md).  \n  \n## Detection of Stream Position Changes  \n When a FileStream object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle. In this case, the cached position in the FileStream object and the cached data in the buffer could be compromised. The FileStream object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the FileStream object.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again. This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.  \n  \n A FileStream object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the FileStream object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor."
  example:
  - "The following example demonstrates some of the FileStream constructors.  \n  \n [!code-cs[fstream class#1](~/add/codesnippet/csharp/t-system.io.filestream_1.cs)]\n [!code-vb[fstream class#1](~/add/codesnippet/visualbasic/t-system.io.filestream_1.vb)]\n [!code-cpp[fstream class#1](~/add/codesnippet/cpp/t-system.io.filestream_1.cpp)]  \n  \n The following example shows how to write to a file asynchronously. This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click. The file path needs to be changed to a file than exits on the computer.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/t-system.io.filestream_2.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/t-system.io.filestream_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class FileStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse voor de opgegeven bestandsingang met de opgegeven lezen/schrijven-machtiging."
  remarks: "Wanneer <xref:System.IO.Stream.Close%2A>is aangeroepen, de ingang wordt ook gesloten en de aantal ingangen van het bestand wordt bijgeschreven.</xref:System.IO.Stream.Close%2A>       `FileStream`wordt ervan uitgegaan dat er exclusieve controle over de ingang. Lezen, schrijven of om tijdens een `FileStream` ook bezit is van een greep kan leiden tot beschadiging van gegevens. Bel voor gegevens-veiligheid <xref:System.IO.FileStream.Flush%2A>voordat met behulp van de greep en te voorkomen dat andere dan aanroepen van methoden `Close` nadat u klaar bent met de greep.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > Wanneer u een reeks tekens met een bepaalde instelling culturele compileren en die dezelfde tekens met een andere instelling culturele ophalen, de tekens mogelijk niet interpreteerbare en kan ervoor zorgen dat een uitzondering gegenereerd.       `FileShare.Read`is de standaardoptie voor degenen <xref:System.IO.FileStream>constructors zonder een `FileShare` parameter.</xref:System.IO.FileStream>       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Een bestandsingang voor het bestand dat de huidige <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: access
      type: System.IO.FileAccess
      description: "Een constante waarde die Hiermee stelt u de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>is geen veld van <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout optreedt, zoals een schijffout opgetreden.       - of - de stroom is gesloten."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor de opgegeven bestandsingang, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en de bestandsingang is ingesteld voor alleen-lezen toegang."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  id: '#ctor(System.IntPtr,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse voor de opgegeven bestandsingang met de opgegeven lezen/schrijven-machtiging."
  remarks: "Wanneer <xref:System.IO.Stream.Close%2A>is aangeroepen, de ingang wordt ook gesloten en de aantal ingangen van het bestand wordt bijgeschreven.</xref:System.IO.Stream.Close%2A>       `FileStream`wordt ervan uitgegaan dat er exclusieve controle over de ingang. Lezen, schrijven of om tijdens een `FileStream` ook bezit is van een greep kan leiden tot beschadiging van gegevens. Bel voor gegevens-veiligheid <xref:System.IO.FileStream.Flush%2A>voordat met behulp van de greep en te voorkomen dat andere dan aanroepen van methoden `Close` nadat u klaar bent met de greep.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > Wanneer u een reeks tekens met een bepaalde instelling culturele compileren en die dezelfde tekens met een andere instelling culturele ophalen, de tekens mogelijk niet interpreteerbare en kan ervoor zorgen dat een uitzondering gegenereerd.       `FileShare.Read`is de standaardoptie voor degenen <xref:System.IO.FileStream>constructors zonder een `FileShare` parameter.</xref:System.IO.FileStream>       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Een bestandsingang voor het bestand dat de huidige <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: access
      type: System.IO.FileAccess
      description: "Een constante waarde die Hiermee stelt u de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>is geen veld van <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout optreedt, zoals een schijffout opgetreden.       - of - de stroom is gesloten."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor de opgegeven bestandsingang, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en de bestandsingang is ingesteld voor alleen-lezen toegang."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse met het opgegeven pad en de aanmaak-modus."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).  \n  \n You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.  \n  \n The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode>, <xref:System.IO.FileAccess> is the default access. Otherwise, the access is set to <xref:System.IO.FileAccess>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_0_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Een relatief of absoluut pad voor het bestand dat de huidige <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: mode
      type: System.IO.FileMode
      description: "Een constante waarde die bepaalt hoe openen of maken van het bestand."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>een lege tekenreeks (&quot;&quot;), bevat alleen witruimte of bevat een of meer ongeldige tekens.       - of - <code>path</code> verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een NTFS-omgeving."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een niet-NTFS-omgeving."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Het bestand kan niet worden gevonden, bijvoorbeeld wanneer <code> mode </code> is <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, en het bestand dat is opgegeven door <code> path </code> bestaat niet. Het bestand moet al bestaan in deze modi."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Een i/o-fout optreedt, zoals het opgeven van <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> wanneer het bestand is opgegeven door <code> path </code> al bestaat, is opgetreden.       - of - de stroom is gesloten."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Het opgegeven pad is ongeldig, zoals wordt op een niet-toegewezen station."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Het opgegeven pad, de bestandsnaam of beide groter zijn dan het systeem gedefinieerde maximumlengte. Bijvoorbeeld, op Windows-platforms, paden moet minder dan 248 tekens en bestandsnamen moet minder dan 260 tekens bevatten."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>bevat een ongeldige waarde."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse voor het opgegeven bestand, met de machtiging opgegeven lezen/schrijven en buffergrootte."
  remarks: "`FileStream`wordt ervan uitgegaan dat er exclusieve controle over de ingang. Lezen, schrijven of om tijdens een `FileStream` ook bezit is van een greep kan leiden tot beschadiging van gegevens. Bel voor gegevens-veiligheid <xref:System.IO.FileStream.Flush%2A>voordat met behulp van de greep en te voorkomen dat andere dan aanroepen van methoden `Close` nadat u klaar bent met de greep.</xref:System.IO.FileStream.Flush%2A> U kunt ook lezen en schrijven naar de ingang voordat u dit `FileStream` constructor.       `FileShare.Read`is de standaardoptie voor degenen <xref:System.IO.FileStream>constructors zonder een `FileShare` parameter.</xref:System.IO.FileStream>      > [!CAUTION] > Wanneer u een reeks tekens met een bepaalde instelling culturele compileren en die dezelfde tekens met een andere instelling culturele ophalen, de tekens mogelijk niet interpreteerbare en kan ervoor zorgen dat een uitzondering gegenereerd.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Een bestandsingang voor het bestand dat de huidige <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: access
      type: System.IO.FileAccess
      description: "Een <xref href=&quot;System.IO.FileAccess&quot;> </xref> constante die Hiermee stelt u de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object."
    - id: bufferSize
      type: System.Int32
      description: "Een positief <xref:System.Int32>waarde groter dan 0 die wijzen op de buffergrootte.</xref:System.Int32> De standaardbuffergrootte is 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De <code> handle </code> -parameter is een ongeldige ingang.       - of - de <code> handle </code> parameter is een synchrone ingang en het asynchroon is gebruikt."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De <code> bufferSize </code> parameter is negatief."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout optreedt, zoals een schijffout opgetreden.       - of - de stroom is gesloten."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor de opgegeven bestandsingang, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en de bestandsingang is ingesteld voor alleen-lezen toegang."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse voor de opgegeven bestandsingang met de opgegeven lezen/schrijven-machtiging en <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> eigendom-instantie."
  remarks: "De `FileStream` object de opgegeven toegang krijgt tot het bestand. Het eigendom van de ingang is die is opgegeven. Als dit proces eigenaar is van de greep, een aanroep van de <xref:System.IO.Stream.Close%2A>methode sluit ook de greep en de aantal ingangen van het bestand wordt bijgeschreven.</xref:System.IO.Stream.Close%2A> De `FileStream` object krijgt de standaardbuffergrootte van 4096 bytes.       `FileStream`wordt ervan uitgegaan dat er exclusieve controle over de ingang. Lezen, schrijven of om tijdens een `FileStream` ook bezit is van een greep kan leiden tot beschadiging van gegevens. Bel voor gegevens-veiligheid <xref:System.IO.FileStream.Flush%2A>voordat met behulp van de greep en voorkomen dan andere methoden aanroept `Close` nadat u klaar bent met de greep.</xref:System.IO.FileStream.Flush%2A>       `FileShare.Read`is de standaardoptie voor degenen <xref:System.IO.FileStream>constructors zonder een `FileShare` parameter.</xref:System.IO.FileStream>      > [!CAUTION] > Wanneer u een reeks tekens met een bepaalde instelling culturele compileren en die dezelfde tekens met een andere instelling culturele ophalen, de tekens mogelijk niet interpreteerbare en kan ervoor zorgen dat een uitzondering gegenereerd.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Een bestandsingang voor het bestand dat de huidige <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: access
      type: System.IO.FileAccess
      description: "Een constante waarde die Hiermee stelt u de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de bestandsingang zijn het eigendom van dit <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> exemplaar; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>is geen veld van <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout optreedt, zoals een schijffout opgetreden.       - of - de stroom is gesloten."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor de opgegeven bestandsingang, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en de bestandsingang is ingesteld voor alleen-lezen toegang."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse met het opgegeven pad en de modus voor het maken, en de machtiging lezen/schrijven."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Een relatief of absoluut pad voor het bestand dat de huidige <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: mode
      type: System.IO.FileMode
      description: "Een constante waarde die bepaalt hoe openen of maken van het bestand."
    - id: access
      type: System.IO.FileAccess
      description: "Een constante waarde die hoe het bestand toegankelijk is bepaalt voor de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object. Deze instelling bepaalt ook de waarden die door de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object. <xref:System.IO.FileStream.CanSeek*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> als `path` Hiermee geeft u een schijf-bestand.</xref:System.IO.FileStream.CanSeek*>"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>een lege tekenreeks (&quot;&quot;), bevat alleen witruimte of bevat een of meer ongeldige tekens.       - of - <code>path</code> verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een NTFS-omgeving."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een niet-NTFS-omgeving."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Het bestand kan niet worden gevonden, bijvoorbeeld wanneer <code> mode </code> is <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, en het bestand dat is opgegeven door <code> path </code> bestaat niet. Het bestand moet al bestaan in deze modi."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Een i/o-fout optreedt, zoals het opgeven van <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> wanneer het bestand is opgegeven door <code> path </code> al bestaat, is opgetreden.       - of - de stroom is gesloten."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Het opgegeven pad is ongeldig, zoals wordt op een niet-toegewezen station."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor het opgegeven <code> path </code>, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en het bestand of map wordt ingesteld voor alleen-lezen toegang."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Het opgegeven pad, de bestandsnaam of beide groter zijn dan het systeem gedefinieerde maximumlengte. Bijvoorbeeld, op Windows-platforms, paden moet minder dan 248 tekens en bestandsnamen moet minder dan 260 tekens bevatten."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>bevat een ongeldige waarde."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse voor de opgegeven bestandsingang met de opgegeven lees/schrijfrechten heeft, buffergrootte en synchrone of asynchrone status."
  remarks: "U stelt de `isAsync` -parameter voor `true` de bestandsingang asynchroon openen. Wanneer de parameter is `true`, overlappende i/o om uit te voeren bestandsbewerkingen asynchroon maakt gebruik van de stroom. De parameter hoeft echter niet te worden `true` aan te roepen de <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, of <xref:System.IO.Stream.CopyToAsync%2A>methode.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Wanneer de `isAsync` parameter `false` en aanroepen van asynchrone leesbewerking- en schrijfbewerkingen, de UI-thread nog steeds niet wordt geblokkeerd, maar de werkelijke i/o-bewerking synchroon wordt uitgevoerd.       `FileStream`wordt ervan uitgegaan dat er exclusieve controle over de ingang. Lezen, schrijven of om tijdens een `FileStream` ook bezit is van een greep kan leiden tot beschadiging van gegevens. Bel voor gegevens-veiligheid <xref:System.IO.FileStream.Flush%2A>voordat met behulp van de greep en te voorkomen dat andere dan aanroepen van methoden `Close` nadat u klaar bent met de greep.</xref:System.IO.FileStream.Flush%2A> U kunt ook lezen en schrijven naar de ingang voordat u dit `FileStream` constructor.       `FileShare.Read`is de standaardoptie voor degenen <xref:System.IO.FileStream>constructors zonder een `FileShare` parameter.</xref:System.IO.FileStream>      > [!CAUTION] > Wanneer u een reeks tekens met een bepaalde instelling culturele compileren en die dezelfde tekens met een andere instelling culturele ophalen, de tekens mogelijk niet interpreteerbare en kan ervoor zorgen dat een uitzondering gegenereerd.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Een bestand dat is verwerkt voor het bestand dat dit <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: access
      type: System.IO.FileAccess
      description: "Een constante waarde die Hiermee stelt u de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object."
    - id: bufferSize
      type: System.Int32
      description: "Een positief <xref:System.Int32>waarde groter dan 0 die wijzen op de buffergrootte.</xref:System.Int32> De standaardbuffergrootte is 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als u de koppeling asynchroon is geopend (dat wil zeggen in overlapt i/o-modus); anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De <code> handle </code> -parameter is een ongeldige ingang.       - of - de <code> handle </code> parameter is een synchrone ingang en het asynchroon is gebruikt."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De <code> bufferSize </code> parameter is negatief."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout optreedt, zoals een schijffout opgetreden.       - of - de stroom is gesloten."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor de opgegeven bestandsingang, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en de bestandsingang is ingesteld voor alleen-lezen toegang."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse voor de opgegeven bestandsingang met de machtiging opgegeven lezen/schrijven <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> instantie eigendom en buffergrootte."
  remarks: "De `FileStream` object de opgegeven toegang krijgt tot het bestand. Het eigendom van de ingang is die is opgegeven. Als dit `FileStream` eigenaar is van de greep, een aanroep van de <xref:System.IO.Stream.Close%2A>methode sluit ook de ingang.</xref:System.IO.Stream.Close%2A> In het bijzonder wordt de aantal ingangen van het bestand verlaagd. De `FileStream` object de opgegeven buffergrootte is opgegeven.       `FileStream`wordt ervan uitgegaan dat er exclusieve controle over de ingang. Lezen, schrijven of om tijdens een `FileStream` ook bezit is van een greep kan leiden tot beschadiging van gegevens. Bel voor gegevens-veiligheid <xref:System.IO.FileStream.Flush%2A>voordat met behulp van de greep en te voorkomen dat andere dan aanroepen van methoden `Close` nadat u klaar bent met de greep.</xref:System.IO.FileStream.Flush%2A> U kunt ook lezen en schrijven naar de ingang voordat u dit `FileStream` constructor.       `FileShare.Read`is de standaardoptie voor degenen <xref:System.IO.FileStream>constructors zonder een `FileShare` parameter.</xref:System.IO.FileStream>      > [!CAUTION] > Wanneer u een reeks tekens met een bepaalde instelling culturele compileren en die dezelfde tekens met een andere instelling culturele ophalen, de tekens mogelijk niet interpreteerbare en kan ervoor zorgen dat een uitzondering gegenereerd.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Een bestand dat is verwerkt voor het bestand dat dit <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: access
      type: System.IO.FileAccess
      description: "Een constante waarde die Hiermee stelt u de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de bestandsingang zijn het eigendom van dit <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> exemplaar; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Een positief <xref:System.Int32>waarde groter dan 0 die wijzen op de buffergrootte.</xref:System.Int32> De standaardbuffergrootte is 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>is negatief."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout optreedt, zoals een schijffout opgetreden.       - of - de stroom is gesloten."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor de opgegeven bestandsingang, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en de bestandsingang is ingesteld voor alleen-lezen toegang."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse met het opgegeven pad, modus voor het maken, de machtiging lezen/schrijven en toegangsmachtigingen."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#2](~/add/codesnippet/csharp/904a8302-b9b6-44f1-89c4-_1.cs)]\n [!code-cpp[System.IO.FileStream3#2](~/add/codesnippet/cpp/904a8302-b9b6-44f1-89c4-_1.cpp)]\n [!code-vb[System.IO.FileStream3#2](~/add/codesnippet/visualbasic/904a8302-b9b6-44f1-89c4-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Een relatief of absoluut pad voor het bestand dat de huidige <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: mode
      type: System.IO.FileMode
      description: "Een constante waarde die bepaalt hoe openen of maken van het bestand."
    - id: access
      type: System.IO.FileAccess
      description: "Een constante waarde die hoe het bestand toegankelijk is bepaalt voor de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object. Deze instelling bepaalt ook de waarden die door de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object. <xref:System.IO.FileStream.CanSeek*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> als `path` Hiermee geeft u een schijf-bestand.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Een constante waarde die bepaalt hoe het bestand door processen worden gedeeld."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>een lege tekenreeks (&quot;&quot;), bevat alleen witruimte of bevat een of meer ongeldige tekens.       - of - <code>path</code> verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een NTFS-omgeving."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een niet-NTFS-omgeving."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Het bestand kan niet worden gevonden, bijvoorbeeld wanneer <code> mode </code> is <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, en het bestand dat is opgegeven door <code> path </code> bestaat niet. Het bestand moet al bestaan in deze modi."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Een i/o-fout optreedt, zoals het opgeven van <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> wanneer het bestand is opgegeven door <code> path </code> al bestaat, is opgetreden.       - of - Windows 98 of Windows 98 Tweede editie, wordt het systeem uitgevoerd en <code> share </code> is ingesteld op <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - of - de stroom is gesloten."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Het opgegeven pad is ongeldig, zoals wordt op een niet-toegewezen station."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor het opgegeven <code> path </code>, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en het bestand of map wordt ingesteld voor alleen-lezen toegang."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Het opgegeven pad, de bestandsnaam of beide groter zijn dan het systeem gedefinieerde maximumlengte. Bijvoorbeeld, op Windows-platforms, paden moet minder dan 248 tekens en bestandsnamen moet minder dan 260 tekens bevatten."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>bevat een ongeldige waarde."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse voor de opgegeven bestandsingang met de machtiging opgegeven lezen/schrijven <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> exemplaar eigendom, buffergrootte en synchrone of asynchrone status."
  remarks: "De `FileStream` object de opgegeven toegang krijgt tot het bestand. Het eigendom van de ingang is die is opgegeven. Als dit `FileStream` eigenaar is van de greep, een aanroep van de <xref:System.IO.Stream.Close%2A>methode sluit ook de ingang.</xref:System.IO.Stream.Close%2A> In het bijzonder wordt de aantal ingangen van het bestand verlaagd. De `FileStream` object de opgegeven buffergrootte is opgegeven.       `FileStream`wordt ervan uitgegaan dat er exclusieve controle over de ingang. Lezen, schrijven of om tijdens een `FileStream` ook bezit is van een greep kan leiden tot beschadiging van gegevens. Bel voor gegevens-veiligheid <xref:System.IO.FileStream.Flush%2A>voordat met behulp van de greep en te voorkomen dat andere dan aanroepen van methoden `Close` nadat u klaar bent met de greep.</xref:System.IO.FileStream.Flush%2A> U kunt ook lezen en schrijven naar de ingang voordat u dit `FileStream` constructor.       `FileShare.Read`is de standaardoptie voor degenen <xref:System.IO.FileStream>constructors zonder een `FileShare` parameter.</xref:System.IO.FileStream>      > [!CAUTION] > Wanneer u een reeks tekens met een bepaalde instelling culturele compileren en die dezelfde tekens met een andere instelling culturele ophalen, de tekens mogelijk niet interpreteerbare en kan ervoor zorgen dat een uitzondering gegenereerd.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Een bestand dat is verwerkt voor het bestand dat dit <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: access
      type: System.IO.FileAccess
      description: "Een constante waarde die Hiermee stelt u de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de bestandsingang zijn het eigendom van dit <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> exemplaar; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Een positief <xref:System.Int32>waarde groter dan 0 die wijzen op de buffergrootte.</xref:System.Int32> De standaardbuffergrootte is 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als u de koppeling asynchroon is geopend (dat wil zeggen in overlapt i/o-modus); anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>access</code>is kleiner dan <xref uid=&quot;langword_csharp_FileAccess.Read&quot; name=&quot;FileAccess.Read&quot; href=&quot;&quot;> </xref> of groter dan <xref uid=&quot;langword_csharp_FileAccess.ReadWrite&quot; name=&quot;FileAccess.ReadWrite&quot; href=&quot;&quot;> </xref> of <code>bufferSize</code> is kleiner dan of gelijk zijn aan 0."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De ingang is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout optreedt, zoals een schijffout opgetreden.       - of - de stroom is gesloten."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor de opgegeven bestandsingang, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en de bestandsingang is ingesteld voor alleen-lezen toegang."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse met het opgegeven pad, de modus voor het maken, lezen/schrijven en te delen machtigings- en buffergrootte."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "Een relatief of absoluut pad voor het bestand dat de huidige <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: mode
      type: System.IO.FileMode
      description: "Een constante waarde die bepaalt hoe openen of maken van het bestand."
    - id: access
      type: System.IO.FileAccess
      description: "Een constante waarde die hoe het bestand toegankelijk is bepaalt voor de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object. Deze instelling bepaalt ook de waarden die door de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object. <xref:System.IO.FileStream.CanSeek*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> als `path` Hiermee geeft u een schijf-bestand.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Een constante waarde die bepaalt hoe het bestand door processen worden gedeeld."
    - id: bufferSize
      type: System.Int32
      description: "Een positief <xref:System.Int32>waarde groter dan 0 die wijzen op de buffergrootte.</xref:System.Int32> De standaardbuffergrootte is 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>een lege tekenreeks (&quot;&quot;), bevat alleen witruimte of bevat een of meer ongeldige tekens.       - of - <code>path</code> verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een NTFS-omgeving."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een niet-NTFS-omgeving."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>is negatief of nul.       - of - <code>mode</code>, <code>access</code>, of <code>share</code> bevatten een ongeldige waarde."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Het bestand kan niet worden gevonden, bijvoorbeeld wanneer <code> mode </code> is <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, en het bestand dat is opgegeven door <code> path </code> bestaat niet. Het bestand moet al bestaan in deze modi."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Een i/o-fout optreedt, zoals het opgeven van <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> wanneer het bestand is opgegeven door <code> path </code> al bestaat, is opgetreden.       - of - Windows 98 of Windows 98 Tweede editie, wordt het systeem uitgevoerd en <code> share </code> is ingesteld op <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - of - de stroom is gesloten."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Het opgegeven pad is ongeldig, zoals wordt op een niet-toegewezen station."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor het opgegeven <code> path </code>, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en het bestand of map wordt ingesteld voor alleen-lezen toegang."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Het opgegeven pad, de bestandsnaam of beide groter zijn dan het systeem gedefinieerde maximumlengte. Bijvoorbeeld, op Windows-platforms, paden moet minder dan 248 tekens en bestandsnamen moet minder dan 260 tekens bevatten."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse met het opgegeven pad, de modus voor het maken, lezen/schrijven en de machtiging voor het delen, grootte, en synchrone of asynchrone status van de buffer."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly. A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.  \n  \n [!code-cs[System.IO.FileStream2#1](~/add/codesnippet/csharp/ff94fabb-a26d-4ac2-a74e-_1.cs)]\n [!code-vb[System.IO.FileStream2#1](~/add/codesnippet/visualbasic/ff94fabb-a26d-4ac2-a74e-_1.vb)]\n [!code-cpp[System.IO.FileStream2#1](~/add/codesnippet/cpp/ff94fabb-a26d-4ac2-a74e-_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
    parameters:
    - id: path
      type: System.String
      description: "Een relatief of absoluut pad voor het bestand dat de huidige <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: mode
      type: System.IO.FileMode
      description: "Een constante waarde die bepaalt hoe openen of maken van het bestand."
    - id: access
      type: System.IO.FileAccess
      description: "Een constante waarde die hoe het bestand toegankelijk is bepaalt voor de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object. Deze instelling bepaalt ook de waarden die door de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object. <xref:System.IO.FileStream.CanSeek*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> als `path` Hiermee geeft u een schijf-bestand.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Een constante waarde die bepaalt hoe het bestand door processen worden gedeeld."
    - id: bufferSize
      type: System.Int32
      description: "Een positief <xref:System.Int32>waarde groter dan 0 die wijzen op de buffergrootte.</xref:System.Int32> De standaardbuffergrootte is 4096..."
    - id: useAsync
      type: System.Boolean
      description: "Hiermee geeft u op of asynchrone i/o- of synchrone i/o-wilt gebruiken. Let echter op het onderliggende besturingssysteem mogelijk geen ondersteuning voor asynchrone i/o, dus bij het opgeven van <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, kan de koppeling synchroon afhankelijk van het platform worden geopend. Wanneer u asynchroon, opent de <> </> *> en <> </> *> methoden beter op grote lees- of schrijfbewerkingen uitvoeren, maar ze zijn mogelijk veel trager verloopt voor kleine lees- of schrijfbewerkingen. Als de toepassing is ontworpen om te profiteren van asynchrone i/o, stelt u de `useAsync` -parameter voor <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>. Met behulp van de asynchrone i/o correct kunt versnellen toepassingen door als een factor van 10, maar gebruiken zonder opnieuw ontwerpen van de toepassing voor asynchrone i/o de prestaties door zoveel verminderen kan als een factor van 10."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>een lege tekenreeks (&quot;&quot;), bevat alleen witruimte of bevat een of meer ongeldige tekens.       - of - <code>path</code> verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een NTFS-omgeving."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een niet-NTFS-omgeving."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>is negatief of nul.       - of - <code>mode</code>, <code>access</code>, of <code>share</code> bevatten een ongeldige waarde."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Het bestand kan niet worden gevonden, bijvoorbeeld wanneer <code> mode </code> is <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, en het bestand dat is opgegeven door <code> path </code> bestaat niet. Het bestand moet al bestaan in deze modi."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Een i/o-fout optreedt, zoals het opgeven van <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> wanneer het bestand is opgegeven door <code> path </code> al bestaat, is opgetreden.       - of - Windows 98 of Windows 98 Tweede editie, wordt het systeem uitgevoerd en <code> share </code> is ingesteld op <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - of - de stroom is gesloten."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Het opgegeven pad is ongeldig, zoals wordt op een niet-toegewezen station."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor het opgegeven <code> path </code>, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en het bestand of map wordt ingesteld voor alleen-lezen toegang."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Het opgegeven pad, de bestandsnaam of beide groter zijn dan het systeem gedefinieerde maximumlengte. Bijvoorbeeld, op Windows-platforms, paden moet minder dan 248 tekens en bestandsnamen moet minder dan 260 tekens bevatten."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse met het opgegeven pad en de modus voor het maken, lezen/schrijven en de machtiging, de toegang voor het delen andere oude status kunnen hebben hetzelfde bestand, de buffergrootte en aanvullende opties."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor1#1](~/add/codesnippet/cpp/53f739ba-7c4d-43ff-a387-_1.cpp)]\n [!code-vb[IO.FileStream.ctor1#1](~/add/codesnippet/visualbasic/53f739ba-7c4d-43ff-a387-_1.vb)]\n [!code-cs[IO.FileStream.ctor1#1](~/add/codesnippet/csharp/53f739ba-7c4d-43ff-a387-_1.cs)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Een relatief of absoluut pad voor het bestand dat de huidige <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object wordt inkapselen."
    - id: mode
      type: System.IO.FileMode
      description: "Een constante waarde die bepaalt hoe openen of maken van het bestand."
    - id: access
      type: System.IO.FileAccess
      description: "Een constante waarde die hoe het bestand toegankelijk is bepaalt voor de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object. Deze instelling bepaalt ook de waarden die door de <> </> *> en <> </> *> eigenschappen van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object. <xref:System.IO.FileStream.CanSeek*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> als `path` Hiermee geeft u een schijf-bestand.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Een constante waarde die bepaalt hoe het bestand door processen worden gedeeld."
    - id: bufferSize
      type: System.Int32
      description: "Een positief <xref:System.Int32>waarde groter dan 0 die wijzen op de buffergrootte.</xref:System.Int32> De standaardbuffergrootte is 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Een waarde die aanvullende opties aangeeft."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>een lege tekenreeks (&quot;&quot;), bevat alleen witruimte of bevat een of meer ongeldige tekens.       - of - <code>path</code> verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een NTFS-omgeving."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een niet-NTFS-omgeving."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>is negatief of nul.       - of - <code>mode</code>, <code>access</code>, of <code>share</code> bevatten een ongeldige waarde."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Het bestand kan niet worden gevonden, bijvoorbeeld wanneer <code> mode </code> is <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, en het bestand dat is opgegeven door <code> path </code> bestaat niet. Het bestand moet al bestaan in deze modi."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Een i/o-fout optreedt, zoals het opgeven van <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> wanneer het bestand is opgegeven door <code> path </code> al bestaat, is opgetreden.       - of - de stroom is gesloten."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Het opgegeven pad is ongeldig, zoals wordt op een niet-toegewezen station."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor het opgegeven <code> path </code>, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en het bestand of map wordt ingesteld voor alleen-lezen toegang.       - of - <xref href=&quot;System.IO.FileOptions&quot;> </xref> is opgegeven voor <code> options </code>, maar bestandsversleuteling wordt niet ondersteund op het huidige platform."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Het opgegeven pad, de bestandsnaam of beide groter zijn dan het systeem gedefinieerde maximumlengte. Bijvoorbeeld, op Windows-platforms, paden moet minder dan 248 tekens en bestandsnamen moet minder dan 260 tekens bevatten."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse met de opgegeven pad, de modus voor het maken, de toegangsrechten en de toegangsmachtigingen buffer grootte en aanvullende opties voor het."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Een relatief of absoluut pad voor het bestand dat de huidige <xref href=&quot;System.IO.FileStream&quot;> </xref> object wordt inkapselen."
    - id: mode
      type: System.IO.FileMode
      description: "Een constante waarde die bepaalt hoe openen of maken van het bestand."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Een constante waarde die de toegangsrechten bepaalt voor gebruik bij het maken van toegangsbeleid en controlebeleid regels voor het bestand."
    - id: share
      type: System.IO.FileShare
      description: "Een constante waarde die bepaalt hoe het bestand door processen worden gedeeld."
    - id: bufferSize
      type: System.Int32
      description: "Een positief <xref:System.Int32>waarde groter dan 0 die wijzen op de buffergrootte.</xref:System.Int32> De standaardbuffergrootte is 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Een constante waarmee extra Bestandsopties."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>een lege tekenreeks (&quot;&quot;), bevat alleen witruimte of bevat een of meer ongeldige tekens.       - of - <code>path</code> verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een NTFS-omgeving."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een niet-NTFS-omgeving."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>is negatief of nul.       - of - <code>mode</code>, <code>access</code>, of <code>share</code> bevatten een ongeldige waarde."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Het bestand kan niet worden gevonden, bijvoorbeeld wanneer <code> mode </code> is <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, en het bestand dat is opgegeven door <code> path </code> bestaat niet. Het bestand moet al bestaan in deze modi."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het huidige besturingssysteem is niet Windows NT of hoger."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Een i/o-fout optreedt, zoals het opgeven van <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> wanneer het bestand is opgegeven door <code> path </code> al bestaat, is opgetreden.       - of - de stroom is gesloten."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Het opgegeven pad is ongeldig, zoals wordt op een niet-toegewezen station."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor het opgegeven <code> path </code>, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en het bestand of map wordt ingesteld voor alleen-lezen toegang.       - of - <xref href=&quot;System.IO.FileOptions&quot;> </xref> is opgegeven voor <code> options </code>, maar bestandsversleuteling wordt niet ondersteund op het huidige platform."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "De opgegeven <code> path </code>, bestandsnaam of beide groter zijn dan het systeem gedefinieerde maximumlengte. Bijvoorbeeld, op Windows-platforms, paden moet minder dan 248 tekens en bestandsnamen moet minder dan 260 tekens bevatten."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.IO.FileStream&quot;> </xref> klasse met het opgegeven pad en de modus voor het maken, toegangsrechten en machtigingen, buffergrootte, opties voor aanvullende bestanden delen, toegangsbeheer en beveiliging controleren."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor2#1](~/add/codesnippet/cpp/7f323125-1dac-495a-a4ee-_1.cpp)]\n [!code-cs[IO.FileStream.ctor2#1](~/add/codesnippet/csharp/7f323125-1dac-495a-a4ee-_1.cs)]\n [!code-vb[IO.FileStream.ctor2#1](~/add/codesnippet/visualbasic/7f323125-1dac-495a-a4ee-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Een relatief of absoluut pad voor het bestand dat de huidige <xref href=&quot;System.IO.FileStream&quot;> </xref> object wordt inkapselen."
    - id: mode
      type: System.IO.FileMode
      description: "Een constante waarde die bepaalt hoe openen of maken van het bestand."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Een constante waarde die de toegangsrechten bepaalt voor gebruik bij het maken van toegangsbeleid en controlebeleid regels voor het bestand."
    - id: share
      type: System.IO.FileShare
      description: "Een constante waarde die bepaalt hoe het bestand door processen worden gedeeld."
    - id: bufferSize
      type: System.Int32
      description: "Een positief <xref:System.Int32>waarde groter dan 0 die wijzen op de buffergrootte.</xref:System.Int32> De standaardbuffergrootte is 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Een constante waarmee extra Bestandsopties."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Een constante waarde die het toegangsbeheer bepaalt en beveiliging voor het bestand controleren."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>een lege tekenreeks (&quot;&quot;), bevat alleen witruimte of bevat een of meer ongeldige tekens.       - of - <code>path</code> verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een NTFS-omgeving."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>verwijst naar een apparaat niet-bestand, zoals &quot; con: &quot;, &quot; com1: &quot;, &quot; lpt1: &quot;, enz. in een niet-NTFS-omgeving."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>is negatief of nul.       - of - <code>mode</code>, <code>access</code>, of <code>share</code> bevatten een ongeldige waarde."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Het bestand kan niet worden gevonden, bijvoorbeeld wanneer <code> mode </code> is <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, en het bestand dat is opgegeven door <code> path </code> bestaat niet. Het bestand moet al bestaan in deze modi."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Een i/o-fout optreedt, zoals het opgeven van <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> wanneer het bestand is opgegeven door <code> path </code> al bestaat, is opgetreden.       - of - de stroom is gesloten."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Het opgegeven pad is ongeldig, zoals wordt op een niet-toegewezen station."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "De <code> access </code> aangevraagd is niet toegestaan door het besturingssysteem voor het opgegeven <code> path </code>, bijvoorbeeld wanneer <code> access </code> is <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> en het bestand of map wordt ingesteld voor alleen-lezen toegang.       - of - <xref href=&quot;System.IO.FileOptions&quot;> </xref> is opgegeven voor <code> options </code>, maar bestandsversleuteling wordt niet ondersteund op het huidige platform."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "De opgegeven <code> path </code>, bestandsnaam of beide groter zijn dan het systeem gedefinieerde maximumlengte. Bijvoorbeeld, op Windows-platforms, paden moet minder dan 248 tekens en bestandsnamen moet minder dan 260 tekens bevatten."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het huidige besturingssysteem is niet Windows NT of hoger."
  platform:
  - net462
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Een asynchrone leesbewerking gestart. (Overweeg het gebruik van <xref:System.IO.FileStream.ReadAsync*>in plaats daarvan; Zie de sectie met opmerkingen.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "In de .NET Framework 4 en eerdere versies, die u hebt methoden zoals BeginRead en <xref:System.IO.FileStream.EndRead%2A>voor het implementeren van asynchrone bestandsbewerkingen.</xref:System.IO.FileStream.EndRead%2A> Deze methoden zijn nog steeds beschikbaar in de [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] ter ondersteuning van verouderde code; echter, de nieuwe async-methoden zoals <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, en <xref:System.IO.FileStream.FlushAsync%2A>, help asynchrone bestandsbewerkingen eenvoudiger te implementeren.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndRead%2A>moet precies één keer worden aangeroepen voor elke aanroep van BeginRead.</xref:System.IO.FileStream.EndRead%2A> Een proces te beëindigen lezen voordat u begint met een andere lezen is mislukt, kan ongewenst gedrag zoals impasse veroorzaken.       <xref:System.IO.FileStream>biedt twee verschillende modi: synchrone i/o- en asynchrone i/o.</xref:System.IO.FileStream> Terwijl een kunnen worden gebruikt, het onderliggende besturingssysteem resources staan mogelijk toegang toe in slechts één van deze modi. Standaard <xref:System.IO.FileStream>synchroon Hiermee opent u de ingang van het besturingssysteem.</xref:System.IO.FileStream> In Windows is dit vertraagt de asynchrone methoden. Als u asynchrone methoden worden gebruikt, gebruikt u de <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>constructor.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>      > [!NOTE] > Gebruik de <xref:System.IO.FileStream.CanRead%2A>eigenschap om te bepalen of de huidige instantie lezen ondersteunt.</xref:System.IO.FileStream.CanRead%2A> Zie voor meer informatie, <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>       Als een stroom is gesloten of u een ongeldig argument doorgeven, worden uitzonderingen veroorzaakt onmiddellijk uit BeginRead. Fouten die tijdens een asynchrone leesaanvraag, zoals een schijffout tijdens de i/o-aanvraag optreden optreden in de thread thread-pool en worden weergegeven na een aanroep van <xref:System.IO.FileStream.EndRead%2A>.</xref:System.IO.FileStream.EndRead%2A>       <xref:System.IO.Stream.EndRead%2A>moet worden aangeroepen met deze <xref:System.IAsyncResult>om erachter te komen hoeveel bytes zijn gelezen.</xref:System.IAsyncResult></xref:System.IO.Stream.EndRead%2A>       Meerdere gelijktijdige asynchrone aanvragen weergeven de volgorde van de voltooiing aanvraag onzeker.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/82be2bd0-0603-4287-b351-_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/82be2bd0-0603-4287-b351-_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/82be2bd0-0603-4287-b351-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "De buffer te lezen van gegevens in."
    - id: offset
      type: System.Int32
      description: "De byte-offset in `array` waarop u wilt beginnen met lezen."
    - id: numBytes
      type: System.Int32
      description: "Het maximum aantal bytes te lezen."
    - id: userCallback
      type: System.AsyncCallback
      description: "De methode moet worden aangeroepen wanneer de asynchrone leesbewerking is voltooid."
    - id: stateObject
      type: System.Object
      description: "Een gebruiker gemaakte object dat deze bepaalde asynchrone leesaanvraag van andere aanvragen onderscheidt."
    return:
      type: System.IAsyncResult
      description: "Een object dat verwijst naar de asynchrone leesbewerking."
  overload: System.IO.FileStream.BeginRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De lengte van de matrix min <code> offset </code> is minder dan <code> numBytes </code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>of <code>numBytes</code> negatief is."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Een asynchrone leesbewerking is geprobeerd voorbij het einde van het bestand."
  platform:
  - net462
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Een asynchrone schrijfbewerking begint. (Overweeg het gebruik van <xref:System.IO.FileStream.WriteAsync*>in plaats daarvan; Zie de sectie met opmerkingen.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "In de .NET Framework 4 en eerdere versies, die u hebt methoden zoals BeginWrite en <xref:System.IO.FileStream.EndWrite%2A>voor het implementeren van asynchrone bestandsbewerkingen.</xref:System.IO.FileStream.EndWrite%2A> Deze methoden zijn nog steeds beschikbaar in de [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] ter ondersteuning van verouderde code; echter, de nieuwe async-methoden zoals <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, en <xref:System.IO.FileStream.FlushAsync%2A>, help asynchrone bestandsbewerkingen eenvoudiger te implementeren.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndWrite%2A>moet precies één keer worden aangeroepen voor elke <xref:System.IAsyncResult>van BeginWrite.</xref:System.IAsyncResult></xref:System.IO.FileStream.EndWrite%2A> <xref:System.IO.FileStream.EndWrite%2A>wordt geblokkeerd tot de i/o-bewerking is voltooid.</xref:System.IO.FileStream.EndWrite%2A>       Deze methode overschrijft <xref:System.IO.Stream.BeginWrite%2A>.</xref:System.IO.Stream.BeginWrite%2A>       <xref:System.IO.FileStream>biedt twee verschillende modi: synchrone i/o- en asynchrone i/o.</xref:System.IO.FileStream> Terwijl een kunnen worden gebruikt, het onderliggende besturingssysteem resources staan mogelijk toegang toe in slechts één van deze modi. Standaard <xref:System.IO.FileStream>synchroon Hiermee opent u de ingang van het besturingssysteem.</xref:System.IO.FileStream> In Windows is dit vertraagt de asynchrone methoden. Als u asynchrone methoden worden gebruikt, gebruikt u de <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>constructor.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>       Als een stroom is gesloten of u een ongeldig argument doorgeven, worden uitzonderingen veroorzaakt onmiddellijk uit BeginWrite. Fouten die tijdens een asynchrone schrijfactie-aanvraag, zoals een schijffout tijdens de i/o-aanvraag optreden optreden in de thread thread-pool en worden weergegeven na een aanroep van <xref:System.IO.FileStream.EndWrite%2A>.</xref:System.IO.FileStream.EndWrite%2A>       Meerdere gelijktijdige asynchrone aanvragen weergeven de volgorde van de voltooiing aanvraag onzeker.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/439bdb1f-5241-4046-a4ad-_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/439bdb1f-5241-4046-a4ad-_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/439bdb1f-5241-4046-a4ad-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "De buffer die gegevens naar de huidige stroom schrijven."
    - id: offset
      type: System.Int32
      description: "De op nul gebaseerde byte-offset in `array` waarop u wilt beginnen met het kopiëren van bytes naar de huidige stroom."
    - id: numBytes
      type: System.Int32
      description: "Het maximum aantal bytes te schrijven."
    - id: userCallback
      type: System.AsyncCallback
      description: "De methode die moet worden aangeroepen wanneer de asynchrone schrijfbewerking is voltooid."
    - id: stateObject
      type: System.Object
      description: "Een gebruiker gemaakte object dat deze aanvraag bepaalde asynchrone schrijfactie van andere aanvragen onderscheidt."
    return:
      type: System.IAsyncResult
      description: "Een object dat verwijst naar de asynchrone schrijfbewerking."
  overload: System.IO.FileStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>lengte min <code>offset</code> is minder dan <code>numBytes</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>of <code>numBytes</code> negatief is."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De stroom biedt geen ondersteuning voor schrijven."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden."
  platform:
  - net462
- uid: System.IO.FileStream.CanRead
  id: CanRead
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee wordt een waarde die aangeeft of de huidige stroom lezen ondersteunt."
  remarks: "Als een klasse wordt afgeleid van <xref:System.IO.Stream>lezen wordt niet ondersteund, aanroepen naar de <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, en <xref:System.IO.FileStream.BeginRead%2A>methoden genereert een <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.BeginRead%2A> </xref:System.IO.FileStream.ReadByte%2A> </xref:System.IO.FileStream.Read%2A> </xref:System.IO.Stream>       Als de stroom is gesloten, retourneert deze eigenschap `false`."
  example:
  - "The following example demonstrates a use of the `CanRead` property. The output of this code is \"MyFile.txt is not writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanRead Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_1_1.cs)]\n [!code-cpp[Classic FileStream.CanRead Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_1_1.cpp)]\n [!code-vb[Classic FileStream.CanRead Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_1_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de stroom lezen ondersteunt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> als de stroom is gesloten of is geopend met alleen-schrijven toegang."
  overload: System.IO.FileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanSeek
  id: CanSeek
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee wordt een waarde die aangeeft of de huidige stroom zoekbewerkingen ondersteunt."
  remarks: "Als een klasse wordt afgeleid van <xref:System.IO.Stream>Zoeken niet ondersteunt, roept naar <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, en <xref:System.IO.FileStream.Seek%2A>genereert een <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.Seek%2A> </xref:System.IO.FileStream.Position%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.FileStream.Length%2A> </xref:System.IO.Stream>       Als de stroom is gesloten, retourneert deze eigenschap `false`."
  example:
  - "The following example uses the `CanSeek` property to check whether a stream supports seeking.  \n  \n [!code-cpp[fstream canseek#1](~/add/codesnippet/cpp/p-system.io.filestream.c_0_1.cpp)]\n [!code-vb[fstream canseek#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_0_1.vb)]\n [!code-cs[fstream canseek#1](~/add/codesnippet/csharp/p-system.io.filestream.c_0_1.cs)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de stroom zoekbewerkingen ondersteunt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> als de stroom is gesloten of als de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> is gemaakt van een besturingssysteem-ingang, zoals een pipe of uitvoer naar de console."
  overload: System.IO.FileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanWrite
  id: CanWrite
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee wordt een waarde die aangeeft of de huidige stroom schrijven ondersteunt."
  remarks: "Als een klasse wordt afgeleid van <xref:System.IO.Stream>biedt geen ondersteuning voor het schrijven van een aanroep van <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, of <xref:System.IO.FileStream.WriteByte%2A>er een <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.WriteByte%2A> </xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IO.FileStream.Write%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.Stream>       Als de stroom is gesloten, retourneert deze eigenschap `false`."
  example:
  - "The following example uses the `CanWrite` property to check whether a stream supports writing.  \n  \n [!code-cs[fstream canwrite#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_1.cs)]\n [!code-cpp[fstream canwrite#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_1.cpp)]\n [!code-vb[fstream canwrite#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_1.vb)]  \n  \n The following is an example using the `CanWrite` property. The output of this code is \"MyFile.txt is writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanWrite Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_2.cs)]\n [!code-vb[Classic FileStream.CanWrite Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_2.vb)]\n [!code-cpp[Classic FileStream.CanWrite Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_2.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de stroom schrijven ondersteunt; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> als de stroom is gesloten of is geopend met alleen-lezen toegang."
  overload: System.IO.FileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Heft de niet-beheerde bronnen worden gebruikt door de <xref href=&quot;System.IO.FileStream&quot;> </xref> en eventueel de beheerde bronnen vrij."
  remarks: "Deze methode wordt aangeroepen door het publiek <xref:System.ComponentModel.Component.Dispose%2A>methode en de <xref:System.Object.Finalize%2A>methode.</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>de beveiligde methode Dispose met roept de `disposing` parameter ingesteld op `true`.</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>roept Dispose met `disposing` ingesteld op `false`.</xref:System.Object.Finalize%2A>       Wanneer de `disposing` parameter `true`, deze methode worden alle resources die beheerde objecten waarover vrijgegeven dat dit <xref:System.IO.FileStream>verwijzingen.</xref:System.IO.FileStream> Deze methode roept de <xref:System.ComponentModel.Component.Dispose%2A>methode van elk object waarnaar wordt verwezen.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>voor het vrijgeven van zowel beheerde als onbeheerde hulpbronnen; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om alleen niet-beheerde bronnen vrij te geven."
  overload: System.IO.FileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Wacht tot de in behandeling asynchrone leesbewerking te voltooien. (Overweeg het gebruik van <xref:System.IO.FileStream.ReadAsync*>in plaats daarvan; Zie de sectie met opmerkingen.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "In de .NET Framework 4 en eerdere versies, die u hebt methoden te gebruiken, zoals <xref:System.IO.FileStream.BeginRead%2A>en EndRead voor het implementeren van asynchrone bestandsbewerkingen.</xref:System.IO.FileStream.BeginRead%2A> Deze methoden zijn nog steeds beschikbaar in de [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] ter ondersteuning van verouderde code; echter, de nieuwe async-methoden zoals <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, en <xref:System.IO.FileStream.FlushAsync%2A>, help asynchrone bestandsbewerkingen eenvoudiger te implementeren.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       EndRead moet worden aangeroepen voor elke aanroep <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> precies Een proces te beëindigen lezen voordat u begint met een andere lezen is mislukt, kan ongewenst gedrag zoals impasse veroorzaken.       Deze methode overschrijft <xref:System.IO.Stream.EndRead%2A>.</xref:System.IO.Stream.EndRead%2A>       EndRead kan worden aangeroepen voor elke <xref:System.IAsyncResult>vanuit <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> </xref:System.IAsyncResult> Het aanroepen van EndRead vertelt u hoeveel bytes zijn gelezen uit de stroom. EndRead wordt geblokkeerd tot de i/o-bewerking is voltooid."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/m-system.io.filestream.e_0_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/m-system.io.filestream.e_0_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/m-system.io.filestream.e_0_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "De verwijzing naar de asynchrone aanvraag in behandeling te wachten."
    return:
      type: System.Int32
      description: "Het aantal bytes gelezen uit de stroom, tussen 0 en het aantal bytes dat u hebt aangevraagd. Streams alleen 0 aan het einde van de stream retourneren, kunt u ze moeten anders blokkeren totdat ten minste 1 byte beschikbaar is."
  overload: System.IO.FileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Dit <xref:System.IAsyncResult>object is niet gemaakt door het aanroepen <xref:System.IO.FileStream.BeginRead*>van deze klasse.</xref:System.IO.FileStream.BeginRead*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndRead is meermaals aangeroepen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De stroom is gesloten of is een interne fout opgetreden."
  platform:
  - net462
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Een asynchrone schrijfbewerking en -blokken eindigt totdat de i/o-bewerking voltooid is. (Overweeg het gebruik van <xref:System.IO.FileStream.WriteAsync*>in plaats daarvan; Zie de sectie met opmerkingen.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "In de .NET Framework 4 en eerdere versies, die u hebt methoden te gebruiken, zoals <xref:System.IO.FileStream.BeginWrite%2A>en EndWrite voor het implementeren van asynchrone bestandsbewerkingen.</xref:System.IO.FileStream.BeginWrite%2A> Deze methoden zijn nog steeds beschikbaar in de [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] ter ondersteuning van verouderde code; echter, de nieuwe async-methoden zoals <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, en <xref:System.IO.FileStream.FlushAsync%2A>, help asynchrone bestandsbewerkingen eenvoudiger te implementeren.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       Deze methode overschrijft <xref:System.IO.Stream.EndWrite%2A>.</xref:System.IO.Stream.EndWrite%2A>       EndWrite moet exact één keer worden aangeroepen voor elke <xref:System.IAsyncResult>vanuit <xref:System.IO.FileStream.BeginWrite%2A>.</xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IAsyncResult> EndWrite wordt geblokkeerd tot de i/o-bewerking is voltooid."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/m-system.io.filestream.e_1_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/m-system.io.filestream.e_1_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/m-system.io.filestream.e_1_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "De asynchrone i/o-aanvraag in behandeling."
  overload: System.IO.FileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Dit <xref:System.IAsyncResult>object is niet gemaakt door het aanroepen <xref:System.IO.Stream.BeginWrite*>van deze klasse.</xref:System.IO.Stream.BeginWrite*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndWrite is meermaals aangeroepen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De stroom is gesloten of is een interne fout opgetreden."
  platform:
  - net462
- uid: System.IO.FileStream.Finalize
  id: Finalize
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Zorgt ervoor dat resources zijn vrijgegeven en andere opschonen-bewerkingen worden uitgevoerd wanneer de garbage collector indexrijen de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  remarks: "Het aanroepen van de garbagecollector `Finalize` wanneer het huidige object is gereed om te worden voltooid. `Finalize`Hiermee sluit u de `FileStream`."
  syntax:
    content: ~FileStream ();
    parameters: []
  overload: System.IO.FileStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Flush
  id: Flush
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee wist u buffers voor deze stroom en zorgt ervoor dat de gegevens worden geschreven naar het bestand."
  remarks: "Deze methode overschrijft <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>.</xref:System.IO.Stream.Flush%2A?displayProperty=fullName>       Wanneer u de Flush-methode aanroept, wordt ook het besturingssysteem i/o-buffer leeggemaakt.       Een stroom encoder is geen verwijderde tenzij u expliciet leeggemaakt aanroepen of van het object verwijderen. Instelling <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName>naar `true` betekent dat gegevens uit de buffer wordt leeggemaakt naar de stroom, maar niet de status van de codering wordt leeggemaakt.</xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName> Hiermee kunt het coderingsprogramma behouden (gedeeltelijke tekens) zodat deze het volgende codeblok tekens correct kunt coderen. Dit scenario is van invloed op UTF8 en UTF7 waarin bepaalde tekens kunnen alleen worden gecodeerd nadat het coderingsprogramma de aangrenzende teken of tekens ontvangt.       Omdat een buffer kan worden gebruikt voor het lezen of schrijven, Flush voert de volgende twee functies: - alle gegevens die eerder naar de buffer wordt geschreven naar het bestand wordt gekopieerd en de buffer is uitgeschakeld, met uitzondering van de status van de encoder.      -Als <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName>is `true` en gegevens eerder naar de buffer voor het lezen uit het bestand is gekopieerd, is de huidige positie binnen het bestand door het aantal ongelezen bytes in de buffer verlaagd.</xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName> De buffer wordt vervolgens gewist.       Gebruik de <xref:System.IO.FileStream.Flush%28System.Boolean%29>overbelasting voor methode wanneer u ervoor zorgen wilt dat alle gegevens in het tijdelijke bestand buffers gebufferd is geschreven naar schijf.</xref:System.IO.FileStream.Flush%28System.Boolean%29>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#4](~/add/codesnippet/csharp/m-system.io.filestream.f_1.cs)]\n [!code-cpp[System.IO.FileStream3#4](~/add/codesnippet/cpp/m-system.io.filestream.f_1.cpp)]\n [!code-vb[System.IO.FileStream3#4](~/add/codesnippet/visualbasic/m-system.io.filestream.f_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.FileStream.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  platform:
  - net462
- uid: System.IO.FileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee wist u ook alle tussenliggende bestand buffers buffers voor deze stroom wordt gewist en zorgt ervoor dat de gegevens worden geschreven naar het bestand."
  remarks: "Gebruik deze overbelasting wanneer u ervoor zorgen wilt dat alle gegevens in het tijdelijke bestand buffers gebufferd is geschreven naar schijf.       Wanneer u de Flush-methode aanroept, wordt ook het besturingssysteem i/o-buffer leeggemaakt."
  syntax:
    content: public virtual void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>leegmaken van alle tussenliggende bestand buffers; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchroon alle buffers voor deze stroom wordt gewist, zorgt ervoor dat de gegevens worden geschreven naar de onderliggende apparaat en controleert annulering aanvragen."
  remarks: "Wanneer u de FlushAsync-methode aanroept, wordt ook het besturingssysteem i/o-buffer leeggemaakt.       Als de bewerking is geannuleerd voordat deze is voltooid, wordt de resulterende taak bevat de <xref:System.Threading.Tasks.TaskStatus>waarde voor de <xref:System.Threading.Tasks.Task.Status%2A>eigenschap.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Als de handle naar het bestand is verwijderd en de resulterende taak bevat de <xref:System.ObjectDisposedException>uitzondering in de <xref:System.Threading.Tasks.Task.Exception%2A>eigenschap.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Het token voor annulering aanvragen bewaken."
    return:
      type: System.Threading.Tasks.Task
      description: "Een taak die staat voor de asynchrone bewerking leegmaken."
  overload: System.IO.FileStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is verwijderd."
  platform:
  - net462
- uid: System.IO.FileStream.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileStream
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Haalt een <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> -object dat de toegangsbeheerlijst (ACL) vermeldingen voor toegangsbeheer voor het bestand dat is beschreven door de huidige ingekapseld <xref href=&quot;System.IO.FileStream&quot;> </xref> object."
  remarks: "Terwijl de <xref:System.IO.FileStream>klasse en GetAccessControl kunnen worden gebruikt voor het ophalen van de toegangsbeheerlijst (ACL) vermeldingen voor toegangsbeheer van een bestaand bestand, kunt u overwegen <xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName>methode, zoals deze is eenvoudiger te gebruiken.</xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       Gebruik de methode GetAccessControl voor het ophalen van de ACL-vermeldingen voor een bestand.       Een ACL beschrijft personen en/of groepen die, of beschikt niet over toegangsrechten specifieke acties op het opgegeven bestand. Zie voor meer informatie [hoe: toevoegen of verwijderen van de Access Control List vermeldingen](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "Een object dat de instellingen voor toegangsbeheer voor het bestand dat is beschreven door de huidige ingekapseld <xref href=&quot;System.IO.FileStream&quot;> </xref> object."
  overload: System.IO.FileStream.GetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Het bestand is gesloten."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het openen van het bestand."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Het bestand kan niet worden gevonden."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Deze bewerking wordt niet ondersteund op het huidige platform.       - of - de aanroeper heeft niet de vereiste machtiging."
  platform:
  - net462
- uid: System.IO.FileStream.Handle
  id: Handle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "De bestandsingang besturingssysteem opgehaald voor het bestand dat de huidige <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object ingekapseld."
  remarks: "Deze eigenschap is een besturingssysteem-ingang voor gebruik met een besturingssysteem-systeem geleverde systeemaanroepen (zoals `ReadFile` in Windows). Werkt niet met C bibliotheekfuncties die een descriptor bestand zoals verwacht `fread`.       De ingang van het besturingssysteem mogelijk zijn geopend synchroon of asynchroon, afhankelijk van welke `FileStream` constructor is aangeroepen. Gebruik de <xref:System.IO.FileStream.IsAsync%2A>eigenschap om te detecteren of deze koppeling asynchroon is geopend.</xref:System.IO.FileStream.IsAsync%2A> Win32, betekent dit dat de ingang is geopend voor overlappende i/o en vereist verschillende parameters voor `ReadFile` en `WriteFile`.      > [!CAUTION] > Gegevensbeschadiging optreden als een `FileStream` is gemaakt, de ingang wordt overschreden, wordt een bewerking wordt verplaatst van de greep bestandsaanwijzer, en vervolgens de `FileStream` opnieuw wordt gebruikt. Meerdere threads kunnen niet veilig schrijven naar hetzelfde bestand tegelijk, en `FileStream` buffer code wordt ervan uitgegaan dat het uitsluitend de ingang bestuurt. `FileStream`mogelijk genereert een <xref:System.IO.IOException>Als `FileStream` detecteert dat een ander proces een verwijzing naar het bestand is verplaatst.</xref:System.IO.IOException> Om dit te voorkomen, geen schrijven geen gegevens in een gedeelte van het bestand dat `FileStream` kan hebben in de buffer opgeslagen en terugzetten van de verwijzing naar het bestand naar de locatie die was toen de methoden voor het laatst op zijn aangeroepen `FileStream`."
  syntax:
    content: public virtual IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "De bestandsingang besturingssysteem voor het bestand door deze ingekapseld <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> object of&1; als de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> is gesloten."
  overload: System.IO.FileStream.Handle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  platform:
  - net462
- uid: System.IO.FileStream.IsAsync
  id: IsAsync
  parent: System.IO.FileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Haalt een waarde die aangeeft of de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> synchroon of asynchroon is geopend."
  remarks: "De `IsAsync` eigenschap detecteert of de `FileStream` koppeling asynchroon is geopend, het inschakelen van uw code te gebruiken de <xref:System.IO.FileStream.Handle%2A>eigenschap correct.</xref:System.IO.FileStream.Handle%2A> In Win32 `IsAsync` wordt true betekent dat de ingang is geopend voor I/O en daarom vereist verschillende parameters voor `ReadFile` en `WriteFile`.       U deze waarde opgeven bij het maken van een exemplaar van de <xref:System.IO.FileStream>klasse met behulp van een constructor met een `isAsync`, `useAsync`, of `options` parameter.</xref:System.IO.FileStream> Als de eigenschap is `true`, overlappende i/o om uit te voeren bestandsbewerkingen asynchroon maakt gebruik van de stroom. De eigenschap IsAsync hoeft echter niet te worden `true` aan te roepen de <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, of <xref:System.IO.Stream.CopyToAsync%2A>methode.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Als de eigenschap IsAsync is `false` en aanroepen van asynchrone leesbewerking- en schrijfbewerkingen, de UI-thread nog steeds niet wordt geblokkeerd, maar de werkelijke i/o-bewerking synchroon wordt uitgevoerd."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/p-system.io.filestream.i_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/p-system.io.filestream.i_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/p-system.io.filestream.i_1.cpp)]"
  syntax:
    content: public virtual bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> asynchroon; anders is geopend <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Length
  id: Length
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee haalt de lengte in bytes van de stroom."
  remarks: "Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.l_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.l_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.l_1.vb)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Een lange waarde op voor de lengte van de stroom in bytes."
  overload: System.IO.FileStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref:System.IO.FileStream.CanSeek*>voor deze stroom is <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.IO.FileStream.CanSeek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout optreedt, zoals het bestand wordt gesloten, opgetreden."
  platform:
  - net462
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Voorkomt dat andere processen van lezen van of schrijven naar de <xref href=&quot;System.IO.FileStream&quot;> </xref>."
  remarks: "Vergrendelen van een bereik van een streaming-bestand, geeft de threads van de vergrendeling proces exclusieve toegang tot die variëren van de bestandsstroom.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file. Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.l_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.l_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.l_1.vb)]"
  syntax:
    content: public virtual void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "Het begin van het bereik te vergrendelen. De waarde van deze parameter moet gelijk zijn aan of groter zijn dan nul (0)."
    - id: length
      type: System.Int64
      description: "Het bereik worden vergrendeld."
  overload: System.IO.FileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>of <code>length</code> negatief is."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Het bestand is gesloten."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Het proces kan het bestand niet openen omdat een gedeelte van het bestand is vergrendeld door een ander proces."
  platform:
  - net462
- uid: System.IO.FileStream.Name
  id: Name
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee wordt de naam van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> die aan de constructor is doorgegeven."
  remarks: "Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/p-system.io.filestream.n_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/p-system.io.filestream.n_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/p-system.io.filestream.n_1.cpp)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "Een tekenreeks die de naam van de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Position
  id: Position
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Opgehaald of ingesteld van de huidige positie van deze stroom."
  remarks: "Zoeken naar andere locaties dan de lengte van de stroom wordt ondersteund.  Wanneer u naar voorbij de lengte van het bestand, neemt de grootte van het aantal.  In Microsoft Windows NT en nieuwer, worden alle gegevens die zijn toegevoegd aan het einde van het bestand is ingesteld op nul.  In Microsoft Windows 98 of ouder, alle gegevens die zijn toegevoegd aan het einde van het bestand niet is ingesteld op nul, wat betekent dat eerder gegevens verwijderde zichtbaar voor de stroom is. Als de positie van de stroom op een grote waarde voorbij het einde van de stroom in Windows 98 of eerder kan ertoe leiden dat een uitzondering optreedt.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.p_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.p_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.p_1.vb)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "De huidige positie van deze stroom."
  overload: System.IO.FileStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De stroom biedt geen ondersteuning voor zoekbewerkingen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n The position was set to a very large value beyond the end of the stream in Windows 98 or earlier."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Poging tot instellen van de positie op een negatieve waarde."
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Poging voorbij het einde van een stroom die geen ondersteuning daarvoor zoeken."
  platform:
  - net462
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Een blok van bytes uit de stroom leest en schrijft de gegevens in een opgegeven buffer."
  remarks: "Deze methode overschrijft <xref:System.IO.Stream.Read%2A>.</xref:System.IO.Stream.Read%2A>       De `offset` parameter geeft de verschuiving van de byte in `array` (de bufferindex) waarop u wilt beginnen met lezen, en de `count` parameter geeft het maximum aantal bytes dat moet worden gelezen uit deze stroom. De geretourneerde waarde is het werkelijke aantal bytes dat is gelezen, of nul als het einde van de stroom is bereikt. Als de leesbewerking geslaagd is, wordt de huidige positie van de stroom geavanceerde door het aantal bytes dat is gelezen. Als er een uitzondering optreedt, wordt de huidige positie van de stroom is ongewijzigd.       De methode Read retourneert nul pas na het einde van de stroom is bereikt. Anders leest lezen altijd ten minste één byte uit de stroom voordat u terugkeert. Als er geen gegevens uit de stroom van een aanroep naar lezen beschikbaar is, wordt de methode blokkeren totdat ten minste één byte aan gegevens kan worden geretourneerd. Een implementatie is gratis minder bytes dan aangevraagde retourneren, zelfs als het einde van de stroom niet is bereikt.       Gebruik <xref:System.IO.BinaryReader>voor het lezen van primitieve gegevenstypen.</xref:System.IO.BinaryReader>       Een thread die een leesbewerking uitvoert niet onderbreken. Hoewel de toepassing lijken mogelijk te worden uitgevoerd nadat de thread opgeheven is, kan de onderbreking verminderen, de prestaties en betrouwbaarheid van uw toepassing.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.  \n  \n [!code-vb[FSRead#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_1_1.vb)]\n [!code-cs[FSRead#1](~/add/codesnippet/csharp/m-system.io.filestream.r_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Wanneer deze methode retourneert, bevat de opgegeven byte-matrix met de waarden tussen `offset` en (`offset`  +  `count` - 1`)` vervangen door het aantal bytes lezen uit de huidige bron."
    - id: offset
      type: System.Int32
      description: "De byte-offset in `array` op die de gelezen bytes worden geplaatst."
    - id: count
      type: System.Int32
      description: "Het maximum aantal bytes te lezen."
    return:
      type: System.Int32
      description: "Het totale aantal bytes in de buffer gelezen. Dit kan zijn dat kleiner is dan het aantal bytes aangevraagd als het aantal bytes momenteel niet beschikbaar zijn, of nul als het einde van de stroom is bereikt."
  overload: System.IO.FileStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>of <code>count</code> negatief is."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De stroom biedt geen ondersteuning voor lezen."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>en <code>count</code> beschrijven een ongeldig bereik in <code>array</code>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Methoden zijn aangeroepen nadat de stroom is gesloten."
  platform:
  - net462
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchroon een reeks bytes leest uit de huidige stroom verplaatst van de positie binnen de stroom door het aantal bytes dat is gelezen, en controleert annulering aanvragen."
  remarks: "De methode ReadAsync kunt u bronintensieve bestandsbewerkingen uitvoeren zonder blokkering van de hoofdthread. Dit aandachtspunt prestaties is vooral belangrijk in een [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app of [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app waarbij een tijdrovende stroombewerking kunt blokkeren van de UI-thread en uw App weergegeven als deze niet werkt. De async-methoden worden gebruikt in combinatie met de `async` en `await` trefwoorden in Visual Basic en C#.       Gebruik de <xref:System.IO.FileStream.CanRead%2A>eigenschap om te bepalen of de huidige instantie lezen ondersteunt.</xref:System.IO.FileStream.CanRead%2A>       Als de bewerking is geannuleerd voordat deze is voltooid, wordt de resulterende taak bevat de <xref:System.Threading.Tasks.TaskStatus>waarde voor de <xref:System.Threading.Tasks.Task.Status%2A>eigenschap.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Als de handle naar het bestand is verwijderd en de resulterende taak bevat de <xref:System.ObjectDisposedException>uitzondering in de <xref:System.Threading.Tasks.Task.Exception%2A>eigenschap.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to read from a file asynchronously.  \n  \n [!code-vb[Asynchronous_File_IO_async#4](~/add/codesnippet/visualbasic/9c5ba435-5f90-4f89-b415-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#4](~/add/codesnippet/csharp/9c5ba435-5f90-4f89-b415-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "De buffer om de gegevens in te schrijven."
    - id: offset
      type: System.Int32
      description: "De byte-offset in `buffer` waarop u wilt beginnen met het schrijven van gegevens uit de stroom."
    - id: count
      type: System.Int32
      description: "Het maximum aantal bytes te lezen."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Het token voor annulering aanvragen bewaken."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Een taak die staat voor de asynchrone leesbewerking. De waarde van de <code> TResult </code> parameter bevat het totale aantal bytes dat is gelezen in de buffer. De resultaatwaarde kan zijn dat kleiner is dan het aantal bytes aangevraagd als het aantal bytes momenteel beschikbaar kleiner dan het gevraagde aantal is of kan de waarde 0 (nul) als het einde van de stroom is bereikt."
  overload: System.IO.FileStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>of <code>count</code> negatief is."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De som van <code> offset </code> en <code> count </code> groter is dan de bufferlengte."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De stroom biedt geen ondersteuning voor lezen."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is verwijderd."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De stroom wordt momenteel gebruikt door een eerdere bewerking met lezen."
  platform:
  - net462
- uid: System.IO.FileStream.ReadByte
  id: ReadByte
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Een byte leest uit het bestand en de byte meer positie wordt bestuurd."
  remarks: "Deze methode overschrijft <xref:System.IO.Stream.ReadByte%2A>.</xref:System.IO.Stream.ReadByte%2A>      > [!NOTE] > Gebruik de <xref:System.IO.FileStream.CanRead%2A>eigenschap om te bepalen of de huidige instantie lezen ondersteunt.</xref:System.IO.FileStream.CanRead%2A> Zie voor meer informatie, <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.r_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.r_0_1.cpp)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "De byte geconverteerd naar een <xref:System.Int32>, of -1 als het einde van de stroom is bereikt.</xref:System.Int32>"
  overload: System.IO.FileStream.ReadByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De huidige stroom biedt geen ondersteuning voor lezen."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De huidige stroom is gesloten."
  platform:
  - net462
- uid: System.IO.FileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Haalt een <xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;> </xref> -object met de bestandsingang besturingssysteem voor het bestand dat de huidige <xref href=&quot;System.IO.FileStream&quot;> </xref> object ingekapseld."
  remarks: "De eigenschap SafeFileHandle Leegmaakacties van de stroom automatisch en wordt de huidige stroompositie wordt ingesteld op 0.  Hierdoor kan het bestand wordt verplaatst of de stroompositie opnieuw worden ingesteld door een andere stroom met behulp van de SafeFileHandle geretourneerd door deze eigenschap."
  syntax:
    content: public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Een object dat de bestandsingang besturingssysteem voor het bestand vertegenwoordigt die de huidige <xref href=&quot;System.IO.FileStream&quot;> </xref> object ingekapseld."
  overload: System.IO.FileStream.SafeFileHandle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee stelt u de huidige positie van deze stroom op de opgegeven waarde."
  remarks: "Deze methode overschrijft <xref:System.IO.Stream.Seek%2A?displayProperty=fullName>.</xref:System.IO.Stream.Seek%2A?displayProperty=fullName>      > [!NOTE] > Gebruik de <xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName>eigenschap om te bepalen of de huidige instantie zoekbewerkingen ondersteunt.</xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName> Zie voor meer informatie, <xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>.</xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>       U kunt zoeken naar andere locaties dan de lengte van de stroom. Wanneer u naar voorbij de lengte van het bestand, neemt de grootte van het aantal. In Windows NT en latere versies wordt is toegevoegd aan het einde van het bestand ingesteld op nul. In Windows 98 of eerdere versies, is toegevoegd aan het einde van het bestand niet ingesteld op nul, wat betekent dat eerder gegevens verwijderde zichtbaar voor de stroom is.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_1_1.cpp)]  \n  \n The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the Seek method.  \n  \n [!code-vb[System.IO.FileStream.Seek#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_2.vb)]\n [!code-cs[System.IO.FileStream.Seek#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_2.cs)]"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Het punt relatief `origin` waaruit u wilt beginnen met zoeken."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Hiermee geeft u het begin, het einde of de huidige positie als een referentiepunt voor `offset`, gebruikt u de waarde van het type <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "De nieuwe positie in de stroom."
  overload: System.IO.FileStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De stroom biedt geen ondersteuning voor het zoeken, bijvoorbeeld als de <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> is samengesteld uit een pipe of console-uitvoer."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Zoeken wordt uitgevoerd vóór het begin van de stroom."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Methoden zijn aangeroepen nadat de stroom is gesloten."
  platform:
  - net462
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Van toepassing is de toegangsbeheerlijst (ACL) vermeldingen voor toegangsbeheer beschreven door een <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> object naar het bestand dat is beschreven door de huidige <xref href=&quot;System.IO.FileStream&quot;> </xref> object."
  remarks: "Terwijl de <xref:System.IO.FileStream>klasse en SetAccessControl op een bestaand bestand kan worden gebruikt, kunt u overwegen de <xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName>de methode is eenvoudiger te gebruiken.</xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       De methode SetAccessControl past vermeldingen voor toegangsbeheer toegangsbeheerlijst (ACL) naar een bestand met de noninherited ACL-lijst.      > [!CAUTION] > De ACL die is opgegeven voor de `fileSecurity` parameter vervangt de bestaande ACL voor het bestand. U kunt machtigingen voor een nieuwe gebruiker toevoegen de <xref:System.IO.FileStream.GetAccessControl%2A>back-methode voor het verkrijgen van de bestaande ACL, wijzigen en gebruik vervolgens SetAccessControl toe te passen op het bestand.</xref:System.IO.FileStream.GetAccessControl%2A>       Een ACL beschrijft personen en/of groepen die, of beschikt niet over toegangsrechten specifieke acties op het opgegeven bestand. Zie voor meer informatie [hoe: toevoegen of verwijderen van de Access Control List vermeldingen](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Een object dat een ACL-vermelding toe te passen op het huidige bestand beschrijft."
  overload: System.IO.FileStream.SetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Het bestand is gesloten."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Het bestand kan niet worden gevonden of is gewijzigd."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Het huidige proces heeft geen toegang tot het bestand te openen."
  platform:
  - net462
- uid: System.IO.FileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Hiermee stelt u de lengte van deze stroom op de opgegeven waarde."
  remarks: "Deze methode overschrijft <xref:System.IO.Stream.SetLength%2A>.</xref:System.IO.Stream.SetLength%2A>       Als de opgegeven waarde kleiner dan de huidige lengte van de stroom is, wordt de stroom wordt afgekapt. Als de huidige positie groter dan de lengte van de nieuwe is, wordt de huidige positie in dit scenario wordt verplaatst naar de laatste byte van de stroom. De opgegeven waarde groter is dan de huidige lengte van de stroom, de stroom is uitgevouwen als de huidige positie hetzelfde is gebleven. Als de stroom is uitgevouwen, wordt de inhoud van de stroom tussen de oude en nieuwe lengte zijn niet gedefinieerd.       Een stroom moet ondersteunen zowel schrijven en zoeken voor `SetLength` om te werken.      > [!NOTE] > Gebruik de <xref:System.IO.FileStream.CanWrite%2A>eigenschap om te bepalen of de huidige instantie ondersteuning biedt voor schrijven, en de <xref:System.IO.FileStream.CanSeek%2A>eigenschap om te bepalen of zoekbewerkingen wordt ondersteund.</xref:System.IO.FileStream.CanSeek%2A> </xref:System.IO.FileStream.CanWrite%2A> Zie voor meer informatie <xref:System.IO.Stream.CanWrite%2A>en <xref:System.IO.Stream.CanSeek%2A>.</xref:System.IO.Stream.CanSeek%2A> </xref:System.IO.Stream.CanWrite%2A>       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "De nieuwe lengte van de stroom."
  overload: System.IO.FileStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De stroom biedt geen ondersteuning voor schrijven en het zoeken naar."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Geprobeerd in te stellen de <code> value </code> parameter kleiner is dan 0."
  platform:
  - net462
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Staat toegang door andere processen tot een bestand of een deel van een bestand dat eerder is vergrendeld."
  remarks: "Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file . Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.u_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.u_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.u_1.vb)]"
  syntax:
    content: public virtual void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "Het begin van het bereik voor het ontgrendelen van."
    - id: length
      type: System.Int64
      description: "Het bereik worden ontgrendeld."
  overload: System.IO.FileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>of <code>length</code> negatief is."
  platform:
  - net462
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Schrijft een blok van bytes naar de bestandsstroom."
  remarks: "Deze methode overschrijft <xref:System.IO.Stream.Write%2A>.</xref:System.IO.Stream.Write%2A>       De `offset` parameter geeft de verschuiving van de byte in `array` (de bufferindex) waarop u wilt beginnen met het kopiëren, en de `count` parameter geeft het aantal bytes dat wordt geschreven naar de stroom. Als de write-bewerking geslaagd is, wordt de huidige positie van de stroom geavanceerde door het aantal geschreven bytes. Als er een uitzondering optreedt, wordt de huidige positie van de stroom is ongewijzigd.      > [!NOTE] > Gebruik de <xref:System.IO.FileStream.CanWrite%2A>eigenschap om te bepalen of de huidige instantie schrijven ondersteunt.</xref:System.IO.FileStream.CanWrite%2A> Zie voor meer informatie, <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>       Een thread die een schrijfbewerking uitvoert niet onderbreken. Hoewel de toepassing lijken mogelijk te worden uitgevoerd nadat de thread opgeheven is, kan de onderbreking verminderen, de prestaties en betrouwbaarheid van uw toepassing.       Zie voor een lijst met algemene bestanden en directory-bewerkingen, [algemene i/o-taken](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#3](~/add/codesnippet/csharp/m-system.io.filestream.w_1_1.cs)]\n [!code-cpp[System.IO.FileStream3#3](~/add/codesnippet/cpp/m-system.io.filestream.w_1_1.cpp)]\n [!code-vb[System.IO.FileStream3#3](~/add/codesnippet/visualbasic/m-system.io.filestream.w_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "De buffer die gegevens naar de stroom schrijven."
    - id: offset
      type: System.Int32
      description: "De op nul gebaseerde byte-offset in `array` waaruit u wilt beginnen met het kopiëren van bytes naar de stroom."
    - id: count
      type: System.Int32
      description: "Het maximum aantal bytes te schrijven."
  overload: System.IO.FileStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>en <code>count</code> beschrijven een ongeldig bereik in <code>array</code>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>of <code>count</code> negatief is."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n Another thread may have caused an unexpected change in the position of the operating system's file handle."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Het huidige exemplaar van de stroom biedt geen ondersteuning voor schrijven."
  platform:
  - net462
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchroon een reeks bytes geschreven naar de huidige stroom, verplaatst de huidige positie binnen deze stroom door het aantal geschreven bytes en controleert annulering aanvragen."
  remarks: "De methode WriteAsync kunt u bronintensieve bestandsbewerkingen uitvoeren zonder blokkering van de hoofdthread. Dit aandachtspunt prestaties is vooral belangrijk in een [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app of [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app waarbij een tijdrovende stroombewerking kunt blokkeren van de UI-thread en uw App weergegeven als deze niet werkt. De async-methoden worden gebruikt in combinatie met de `async` en `await` trefwoorden in Visual Basic en C#.       Gebruik de <xref:System.IO.FileStream.CanWrite%2A>eigenschap om te bepalen of de huidige instantie lezen ondersteunt.</xref:System.IO.FileStream.CanWrite%2A>       Als de bewerking is geannuleerd voordat deze is voltooid, wordt de resulterende taak bevat de <xref:System.Threading.Tasks.TaskStatus>waarde voor de <xref:System.Threading.Tasks.Task.Status%2A>eigenschap.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Als de handle naar het bestand is verwijderd en de resulterende taak bevat de <xref:System.ObjectDisposedException>uitzondering in de <xref:System.Threading.Tasks.Task.Exception%2A>eigenschap.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to write asynchronously to a file.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/7726d527-d678-42ba-9864-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/7726d527-d678-42ba-9864-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "De buffer om gegevens uit te schrijven."
    - id: offset
      type: System.Int32
      description: "De op nul gebaseerde byte-offset in `buffer` waaruit u wilt beginnen met het kopiëren van bytes naar de stroom."
    - id: count
      type: System.Int32
      description: "Het maximum aantal bytes te schrijven."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Het token voor annulering aanvragen bewaken."
    return:
      type: System.Threading.Tasks.Task
      description: "Een taak die de asynchrone schrijfbewerking vertegenwoordigt."
  overload: System.IO.FileStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>of <code>count</code> negatief is."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De som van <code> offset </code> en <code> count </code> groter is dan de bufferlengte."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De stroom biedt geen ondersteuning voor schrijven."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is verwijderd."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De stroom wordt momenteel gebruikt door een eerdere bewerking met schrijven."
  platform:
  - net462
- uid: System.IO.FileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Een byte schrijft naar de huidige positie in de bestandsstroom."
  remarks: "Deze methode overschrijft <xref:System.IO.Stream.WriteByte%2A>.</xref:System.IO.Stream.WriteByte%2A>       Gebruik `WriteByte` schrijven van een byte wordt ingesteld op een `FileStream` efficiënt. Als de stroom gesloten of niet schrijfbaar is, wordt er een uitzondering opgetreden.      > [!NOTE] > Gebruik de <xref:System.IO.FileStream.CanWrite%2A>eigenschap om te bepalen of de huidige instantie schrijven ondersteunt.</xref:System.IO.FileStream.CanWrite%2A> Zie voor meer informatie, <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.w_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.w_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.w_0_1.cpp)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Een byte wordt ingesteld op het schrijven naar de stroom."
  overload: System.IO.FileStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De stroom is gesloten."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De stroom biedt geen ondersteuning voor schrijven."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
- uid: System.IO.FileOptions
  parent: System.IO
  isExternal: false
  name: FileOptions
  nameWithType: FileOptions
  fullName: System.IO.FileOptions
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
- uid: System.Security.AccessControl.FileSystemRights
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSystemRights
  nameWithType: FileSystemRights
  fullName: System.Security.AccessControl.FileSystemRights
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.FileStream.CanRead
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
- uid: System.IO.FileStream.CanSeek
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
- uid: System.IO.FileStream.Dispose(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
- uid: System.IO.FileStream.Finalize
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
- uid: System.IO.FileStream.Flush
  parent: System.IO.FileStream
  isExternal: false
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
- uid: System.IO.FileStream.Flush(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.FileStream.GetAccessControl
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
- uid: System.IO.FileStream.Handle
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
- uid: System.IO.FileStream.IsAsync
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
- uid: System.IO.FileStream.Length
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
- uid: System.IO.FileStream.Name
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
- uid: System.IO.FileStream.Position
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.FileStream.ReadByte
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
- uid: System.IO.FileStream.SafeFileHandle
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
- uid: System.IO.FileStream.SetLength(System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.FileStream.WriteByte(System.Byte)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.FileStream.#ctor*
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream
  nameWithType: FileStream.FileStream
- uid: System.IO.FileStream.BeginRead*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead
  nameWithType: FileStream.BeginRead
- uid: System.IO.FileStream.BeginWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite
  nameWithType: FileStream.BeginWrite
- uid: System.IO.FileStream.CanRead*
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
- uid: System.IO.FileStream.CanSeek*
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
- uid: System.IO.FileStream.Dispose*
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose
  nameWithType: FileStream.Dispose
- uid: System.IO.FileStream.EndRead*
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead
  nameWithType: FileStream.EndRead
- uid: System.IO.FileStream.EndWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite
  nameWithType: FileStream.EndWrite
- uid: System.IO.FileStream.Finalize*
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize
  nameWithType: FileStream.Finalize
- uid: System.IO.FileStream.Flush*
  parent: System.IO.FileStream
  isExternal: false
  name: Flush
  nameWithType: FileStream.Flush
- uid: System.IO.FileStream.FlushAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync
  nameWithType: FileStream.FlushAsync
- uid: System.IO.FileStream.GetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl
  nameWithType: FileStream.GetAccessControl
- uid: System.IO.FileStream.Handle*
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
- uid: System.IO.FileStream.IsAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
- uid: System.IO.FileStream.Length*
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
- uid: System.IO.FileStream.Lock*
  parent: System.IO.FileStream
  isExternal: false
  name: Lock
  nameWithType: FileStream.Lock
- uid: System.IO.FileStream.Name*
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
- uid: System.IO.FileStream.Position*
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
- uid: System.IO.FileStream.Read*
  parent: System.IO.FileStream
  isExternal: false
  name: Read
  nameWithType: FileStream.Read
- uid: System.IO.FileStream.ReadAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync
  nameWithType: FileStream.ReadAsync
- uid: System.IO.FileStream.ReadByte*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte
  nameWithType: FileStream.ReadByte
- uid: System.IO.FileStream.SafeFileHandle*
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek*
  parent: System.IO.FileStream
  isExternal: false
  name: Seek
  nameWithType: FileStream.Seek
- uid: System.IO.FileStream.SetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl
  nameWithType: FileStream.SetAccessControl
- uid: System.IO.FileStream.SetLength*
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength
  nameWithType: FileStream.SetLength
- uid: System.IO.FileStream.Unlock*
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock
  nameWithType: FileStream.Unlock
- uid: System.IO.FileStream.Write*
  parent: System.IO.FileStream
  isExternal: false
  name: Write
  nameWithType: FileStream.Write
- uid: System.IO.FileStream.WriteAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync
  nameWithType: FileStream.WriteAsync
- uid: System.IO.FileStream.WriteByte*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte
  nameWithType: FileStream.WriteByte
