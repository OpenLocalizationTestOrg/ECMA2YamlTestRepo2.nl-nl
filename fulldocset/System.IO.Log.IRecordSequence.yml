### YamlMime:ManagedReference
items:
- uid: System.IO.Log.IRecordSequence
  id: IRecordSequence
  children:
  - System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.BaseSequenceNumber
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.CreateReservationCollection
  - System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.Flush
  - System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.LastSequenceNumber
  - System.IO.Log.IRecordSequence.MaximumRecordLength
  - System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.IRecordSequence.ReadRestartAreas
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReservedBytes
  - System.IO.Log.IRecordSequence.RestartSequenceNumber
  - System.IO.Log.IRecordSequence.RetryAppend
  - System.IO.Log.IRecordSequence.TailPinned
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: IRecordSequence
  nameWithType: IRecordSequence
  fullName: System.IO.Log.IRecordSequence
  type: Interface
  summary: "Biedt een algemene interface naar een reeks van records."
  remarks: "De interface IRecordSequence biedt een abstracte interface naar een record gerichte stream. Een IRecordSequence-exemplaar kan worden gebruikt om te lezen en schrijven van logboekrecords.       De interface IRecordSequence biedt de volgende mogelijkheden - logboek toevoegen registreert met behulp van de <xref:System.IO.Log.IRecordSequence.Append%2A>methoden.</xref:System.IO.Log.IRecordSequence.Append%2A>      -Meer informatie over de toegevoegde records met behulp van de <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>methode.</xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>      -Schrijven van een speciale opnieuw registreren met de <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>methode.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>      -Lees opnieuw records van de meest recent geschreven opnieuw registreren met behulp de <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>methode.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>      -De records doorsturen naar duurzame archief met de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A>      -Ruimte gereserveerd voor het toevoegen van records.      -Vrije logboekruimte door geavanceerde de basis van het logboek.      -Ontvangen <xref:System.IO.Log.IRecordSequence.TailPinned>gebeurtenismeldingen verplaatsen van de basis van het logboek ruimte vrij.</xref:System.IO.Log.IRecordSequence.TailPinned>       Logboekrecords worden toegevoegd aan een exemplaar IRecordSequence en elke logboekrecord krijgt een uniek nummer. Volgnummers zijn strikt gestaag toenemende binnen een bepaalde recordreeks. Een logboekrecord bestaat uit ondoorzichtige gegevens, die zijn opgegeven met het exemplaar IRecordSequence in een <xref:System.Collections.IList>van ArraySegments bytes.</xref:System.Collections.IList>       De interface IRecordSequence beschrijft ook enkele basiseigenschappen met informatie over de grenzen van het logboek.      -De <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>eigenschap bevat het volgnummer van de eerste geldige record in de recordreeks.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      -De <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>eigenschap bevat een volgnummer dat kan worden gegarandeerd groter is dan het volgnummer van de laatste toegevoegd record.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>      -De <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>eigenschap bevat het volgnummer van het laatste gedeelte van de schriftelijke opnieuw opstarten.</xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>      -De <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>eigenschap bevat de grootte van de grootste record die kan worden toegevoegd aan of lezen van de reeks.</xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>      -De <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>eigenschap bevat de totale grootte van alle reserveringen in deze record reeks.</xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>      -Als de <xref:System.IO.Log.IRecordSequence.RetryAppend%2A>eigenschap is ingesteld op `true`, en een <xref:System.IO.Log.IRecordSequence.Append%2A>bewerking is mislukt omdat er is geen ruimte in de reeks, de recordreeks probeert te vrije ruimte heeft en probeer het opnieuw toevoegen.</xref:System.IO.Log.IRecordSequence.Append%2A> </xref:System.IO.Log.IRecordSequence.RetryAppend%2A>"
  syntax:
    content: 'public interface IRecordSequence : IDisposable'
  implements:
  - System.IDisposable
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Verplaatst het basispartikel sequence-nummer van het logboek doorsturen."
  remarks: "Als u werkt met een <xref:System.IO.Log.LogRecordSequence>instance en probeer het voortzetten van het volgnummer vrijmaken van ruimte in het logboek het nieuwe base volgnummer moet zich bevinden in een ander logboek gebied voor de vorige mate zijn gemarkeerd als leeg.</xref:System.IO.Log.LogRecordSequence> Vrijmaken gebieden gedeeltelijk wordt niet ondersteund."
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Het nieuwe base volgnummer van de recordreeks."
  overload: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>is ongeldig."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>is niet actief in het logboek."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het aanpassen van de reeks."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks is vol."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, schrijft u een logboekrecord naar de <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       Deze methode wordt normaal gesproken voltooid voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de toegevoegde logboekrecord."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte bevat de nieuwe record maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, voegt u een logboekrecord naar de <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       Deze methode wordt normaal gesproken voltooid voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de toegevoegde logboekrecord."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte bevat de nieuwe record maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, voegt u een logboekrecord naar de <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, met de ruimte die eerder is gereserveerd in de reeks."
  remarks: "Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       De toegevoegde record verbruikt ruimte die is eerder gereserveerd, met behulp van een reservering die is opgegeven door de `reservations` parameter. Als de append slaagt, verbruikt dit het kleinste reservering gebied die de gegevens kan bevatten en reservering gebied wordt verwijderd uit de verzameling.       Deze methode wordt normaal gesproken voltooid voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Een <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> die de reservering die moet worden gebruikt voor deze record bevat."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de toegevoegde logboekrecord."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte bevat de nieuwe record maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, voegt u een logboekrecord naar de <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, met de ruimte die eerder is gereserveerd in de reeks."
  remarks: "Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       De toegevoegde record verbruikt ruimte die is eerder gereserveerd, met behulp van een reservering die is opgegeven door de `reservations` parameter. Als de append slaagt, verbruikt dit het kleinste reservering gebied die de gegevens kan bevatten en reservering gebied wordt verwijderd uit de verzameling.       Deze methode wordt normaal gesproken voltooid voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Een <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> die de reservering die moet worden gebruikt voor deze record bevat."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de toegevoegde logboekrecord."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte bevat de nieuwe record maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, krijgt u het volgnummer van de eerste geldige record in de huidige <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Geldige volgnummers zijn groter dan of gelijk zijn aan BaseSequenceNumber en kleiner dan <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>       De waarde van deze eigenschap kan worden gewijzigd door het aanroepen van de <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>of <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>methode.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> </xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het laagste volgnummer dat overeenkomt met een geldige record in de <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De eigenschap is geopend nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Als in een afgeleide klasse genegeerd, begint een asynchrone bewerking toevoegen."
  remarks: "U moet doorgeven in de <xref:System.IAsyncResult>geretourneerd door deze methode kan worden de <xref:System.IO.Log.IRecordSequence.EndAppend%2A>methode om ervoor te zorgen dat de toevoegbewerking is voltooid en bronnen op de juiste wijze kunnen worden vrijgemaakt.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Als er een fout tijdens een asynchrone toevoegen opgetreden is, wordt een uitzondering niet gegenereerd totdat de <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-methode is aangeroepen met de <xref:System.IAsyncResult>geretourneerd door deze methode.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       Deze methode wordt normaal gesproken voltooid voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    - id: callback
      type: System.AsyncCallback
      description: "Een optionele asynchrone terugpostactie, moet worden aangeroepen wanneer de toevoegen voltooid is."
    - id: state
      type: System.Object
      description: "Een gebruiker gemaakte object die deze asynchrone name onderscheidt toevoeg-aanvraag van andere aanvragen."
    return:
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>die staat voor de asynchrone toevoegen die nog steeds in behandeling kan worden.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte bevat de nieuwe record maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Als in een afgeleide klasse genegeerd, begint een asynchrone bewerkingen, op basis van eerder in de reeks gereserveerde ruimte toevoegen."
  remarks: "U moet doorgeven in de <xref:System.IAsyncResult>geretourneerd door deze methode kan worden de <xref:System.IO.Log.IRecordSequence.EndAppend%2A>methode om ervoor te zorgen dat de toevoegbewerking is voltooid en bronnen op de juiste wijze kunnen worden vrijgemaakt.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Als er een fout tijdens een asynchrone toevoegen opgetreden is, wordt een uitzondering niet gegenereerd totdat de <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-methode is aangeroepen met de <xref:System.IAsyncResult>geretourneerd door deze methode.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       Deze methode wordt normaal gesproken voltooid voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    - id: callback
      type: System.AsyncCallback
      description: "Een optionele asynchrone terugpostactie, moet worden aangeroepen wanneer de toevoegen voltooid is."
    - id: state
      type: System.Object
      description: "Een gebruiker gemaakte object die deze asynchrone name onderscheidt toevoeg-aanvraag van andere aanvragen."
    return:
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>die staat voor de asynchrone toevoegen die nog steeds in behandeling kan worden.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte bevat de nieuwe record maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Als in een afgeleide klasse genegeerd, begint een asynchrone toevoegbewerking met behulp van de ruimte die eerder is gereserveerd in de reeks."
  remarks: "U moet doorgeven in de <xref:System.IAsyncResult>geretourneerd door deze methode kan worden de <xref:System.IO.Log.IRecordSequence.EndAppend%2A>methode om ervoor te zorgen dat de toevoegbewerking is voltooid en bronnen op de juiste wijze kunnen worden vrijgemaakt.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Als er een fout tijdens een asynchrone toevoegen opgetreden is, wordt een uitzondering niet gegenereerd totdat de <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-methode is aangeroepen met de <xref:System.IAsyncResult>geretourneerd door deze methode.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       De toegevoegde record verbruikt ruimte die is eerder gereserveerd, met behulp van een reservering die is opgegeven door de `reservations` parameter. Als de append slaagt, verbruikt dit het kleinste reservering gebied die de gegevens kan bevatten en reservering gebied wordt verwijderd uit de verzameling.       Deze methode wordt normaal gesproken voltooid voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Een <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> die de reservering die moet worden gebruikt voor deze record bevat."
    - id: callback
      type: System.AsyncCallback
      description: "Een optionele asynchrone terugpostactie, moet worden aangeroepen wanneer de toevoegen voltooid is."
    - id: state
      type: System.Object
      description: "Een gebruiker gemaakte object die deze asynchrone name onderscheidt toevoeg-aanvraag van andere aanvragen."
    return:
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>die staat voor de asynchrone toevoegen die nog steeds in behandeling kan worden.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte bevat de nieuwe record maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Als in een afgeleide klasse genegeerd, begint een asynchrone bewerkingen, op basis van eerder in de reeks gereserveerde ruimte toevoegen."
  remarks: "U moet doorgeven in de <xref:System.IAsyncResult>geretourneerd door deze methode kan worden de <xref:System.IO.Log.IRecordSequence.EndAppend%2A>methode om ervoor te zorgen dat de toevoegbewerking is voltooid en bronnen op de juiste wijze kunnen worden vrijgemaakt.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Als er een fout tijdens een asynchrone toevoegen opgetreden is, wordt een uitzondering niet gegenereerd totdat de <xref:System.IO.Log.IRecordSequence.EndAppend%2A>-methode is aangeroepen met de <xref:System.IAsyncResult>geretourneerd door deze methode.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       De toegevoegde record verbruikt ruimte die is eerder gereserveerd, met behulp van een reservering die is opgegeven door de `reservations` parameter. Als de append slaagt, verbruikt dit het kleinste reservering gebied die de gegevens kan bevatten en reservering gebied wordt verwijderd uit de verzameling.       Deze methode wordt normaal gesproken voltooid voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Een <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> die de reservering die moet worden gebruikt voor deze record bevat."
    - id: callback
      type: System.AsyncCallback
      description: "Een optionele asynchrone terugpostactie, moet worden aangeroepen wanneer de toevoegen voltooid is."
    - id: state
      type: System.Object
      description: "Een gebruiker gemaakte object die deze asynchrone name onderscheidt toevoeg-aanvraag van andere aanvragen."
    return:
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>die staat voor de asynchrone toevoegen die nog steeds in behandeling kan worden.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte bevat de nieuwe record maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Als in een afgeleide klasse genegeerd, begint een asynchrone leegmaken bewerking met de ruimte die eerder is gereserveerd in de reeks."
  remarks: "U moet doorgeven in de <xref:System.IAsyncResult>geretourneerd door de huidige methode voor de <xref:System.IO.Log.IRecordSequence.EndFlush%2A>methode om ervoor te zorgen dat de flush is voltooid en resources op de juiste wijze zijn vrijgegeven.</xref:System.IO.Log.IRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> Als er een fout optreedt tijdens een asynchrone opschoonbewerking, er een uitzondering niet gegenereerd totdat de <xref:System.IO.Log.IRecordSequence.EndFlush%2A>-methode is aangeroepen met de <xref:System.IAsyncResult>geretourneerd door deze methode.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndFlush%2A>       Deze methode aanroept, zorgt ervoor dat alle records die zijn toegevoegd aan de <xref:System.IO.Log.IRecordSequence>blijvend worden geschreven.</xref:System.IO.Log.IRecordSequence>       Als een record reeks afgestoten of als u een ongeldig argument doorgeven, worden uitzonderingen veroorzaakt onmiddellijk binnen deze bewerking. Fouten die zijn opgetreden tijdens een asynchrone aanvraag voor het leegmaken, bijvoorbeeld een schijffout tijdens de i/o-aanvraag resulteert in het uitzonderingen optreden wanneer de <xref:System.IO.Log.IRecordSequence.EndFlush%2A>methode wordt aangeroepen.</xref:System.IO.Log.IRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de meest recente records die moet worden geschreven. Als dit <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> is ongeldig, en vervolgens alle records moeten worden geschreven."
    - id: callback
      type: System.AsyncCallback
      description: "Een optionele asynchrone terugpostactie, moet worden aangeroepen wanneer de flush voltooid is."
    - id: state
      type: System.Object
      description: "Een gebruiker gemaakte object dat deze bepaalde asynchrone leegmaken aanvraag van andere aanvragen onderscheidt."
    return:
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>dat vertegenwoordigt de asynchrone leegmaken bewerking, wat kan nog in behandeling zijn.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden bij het leegmaken van de gegevens."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Overschreven in een afgeleide klasse een asynchrone reserve begint als toevoegbewerking."
  remarks: "U moet doorgeven in de <xref:System.IAsyncResult>geretourneerd door deze methode kan worden de <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>methode om ervoor te zorgen dat de toevoegbewerking is voltooid en bronnen op de juiste wijze kunnen worden vrijgemaakt.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Als er een fout tijdens een asynchrone toevoegen opgetreden is, wordt een uitzondering niet gegenereerd totdat de <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>-methode is aangeroepen met de <xref:System.IAsyncResult>geretourneerd door deze methode.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       De opgegeven reserveringen worden toegevoegd aan de opgegeven reservering verzameling in een atomic-bewerking met een record toevoegbewerking. Als de toevoegen is mislukt, wordt er geen ruimte is gereserveerd.       Deze methode kan normaal gesproken voltooien voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Als een record reeks afgestoten of als u een ongeldig argument doorgeven, worden uitzonderingen veroorzaakt onmiddellijk binnen deze bewerking. Fouten die zijn opgetreden tijdens een asynchrone append-aanvraag, bijvoorbeeld een schijffout tijdens de i/o-aanvraag resulteert in het uitzonderingen optreden wanneer de <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>methode wordt aangeroepen.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "De te reserveert in reserveringsverzameling."
    - id: reservations
      type: System.Int64[]
      description: "De reserveringen te maken, in bytes."
    - id: callback
      type: System.AsyncCallback
      description: "Een optionele asynchrone terugpostactie, moet worden aangeroepen wanneer de toevoegen voltooid is."
    - id: state
      type: System.Object
      description: "Een gebruiker gemaakte object die deze asynchrone name onderscheidt toevoeg-aanvraag van andere aanvragen."
    return:
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>die staat voor deze asynchrone bewerking die nog steeds in behandeling kan worden.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte op de nieuwe record bevatten, of op de reservering maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Overschreven in een afgeleide klasse een asynchrone reserve begint als toevoegbewerking."
  remarks: "U moet doorgeven in de <xref:System.IAsyncResult>geretourneerd door deze methode kan worden de <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>methode om ervoor te zorgen dat de toevoegbewerking is voltooid en bronnen op de juiste wijze kunnen worden vrijgemaakt.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Als er een fout tijdens een asynchrone toevoegen opgetreden is, wordt een uitzondering niet gegenereerd totdat de <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>-methode is aangeroepen met de <xref:System.IAsyncResult>geretourneerd door deze methode.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       De opgegeven reserveringen worden toegevoegd aan de opgegeven reservering verzameling in een atomic-bewerking met een record toevoegbewerking. Als de toevoegen is mislukt, wordt er geen ruimte is gereserveerd.       Deze methode kan normaal gesproken voltooien voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Als een record reeks afgestoten of als u een ongeldig argument doorgeven, worden uitzonderingen veroorzaakt onmiddellijk binnen deze bewerking. Fouten die zijn opgetreden tijdens een asynchrone append-aanvraag, bijvoorbeeld een schijffout tijdens de i/o-aanvraag resulteert in het uitzonderingen optreden wanneer de <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>methode wordt aangeroepen.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "De te reserveert in reserveringsverzameling."
    - id: reservations
      type: System.Int64[]
      description: "De reserveringen te maken, in bytes."
    - id: callback
      type: System.AsyncCallback
      description: "Een optionele asynchrone terugpostactie, moet worden aangeroepen wanneer de toevoegen voltooid is."
    - id: state
      type: System.Object
      description: "Een gebruiker gemaakte object die deze asynchrone name onderscheidt toevoeg-aanvraag van andere aanvragen."
    return:
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>die staat voor deze asynchrone bewerking die nog steeds in behandeling kan worden.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte op de nieuwe record bevatten, of op de reservering maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, begint de schrijfbewerking voor een asynchrone herstart gebied, met behulp van eerder in de reeks gereserveerde ruimte."
  remarks: "U moet doorgeven in de <xref:System.IAsyncResult>geretourneerd door deze methode kan worden de <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>methode om te waarborgen dat de herstart gebied write-bewerking is voltooid en bronnen op de juiste wijze kunnen worden vrijgemaakt.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Als er een fout tijdens een schrijfactie voor asynchrone herstart gebied opgetreden is, er een uitzondering niet gegenereerd totdat de <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>-methode is aangeroepen met de <xref:System.IAsyncResult>geretourneerd door deze methode.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       Wanneer de bewerking is voltooid, is het nummer van het basispartikel sequence bijgewerkt. Alle Meld records met volgnummers kleiner is dan het nieuwe base volgnummer niet toegankelijk zijn.       Als een <xref:System.IO.Log.ReservationCollection>is opgegeven, wordt het gebied geschreven herstart verbruikt ruimte die is eerder gereserveerd, met behulp van een reservering opgenomen in de verzameling.</xref:System.IO.Log.ReservationCollection> Als de methode is gelukt, verbruikt dit de kleinste reservering die de gegevens kan bevatten en reservering wordt verwijderd uit de verzameling.       Als een record reeks afgestoten of als u een ongeldig argument doorgeven, worden uitzonderingen veroorzaakt onmiddellijk binnen deze bewerking. Fouten die zijn opgetreden tijdens een asynchrone append-aanvraag, bijvoorbeeld een schijffout tijdens de i/o-aanvraag resulteert in het uitzonderingen optreden wanneer de <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>methode wordt aangeroepen.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Het nieuwe base volgnummer. Het opgegeven volgnummer moet groter dan of gelijk aan het huidige base volgnummer."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Een <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> waarin de reservering die moet worden gebruikt voor dit gebied opnieuw opstarten."
    - id: callback
      type: System.AsyncCallback
      description: "Een optionele asynchrone terugpostactie, moet worden aangeroepen wanneer het schrijven van de gebied opnieuw opstarten voltooid is."
    - id: state
      type: System.Object
      description: "Een gebruiker gemaakte object dat deze schrijfaanvraag voor bepaalde asynchrone herstart gebied kan worden onderscheiden van andere aanvragen."
    return:
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>dat vertegenwoordigt de asynchrone opnieuw opstarten schrijfbewerking gebied, wat kan nog in behandeling zijn.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, begint de schrijfbewerking voor een asynchrone herstart gebied, met behulp van eerder in de reeks gereserveerde ruimte."
  remarks: "U moet doorgeven in de <xref:System.IAsyncResult>geretourneerd door deze methode kan worden de <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>methode om ervoor te zorgen dat de herstart gebied write-bewerking is voltooid en bronnen op de juiste wijze kunnen worden vrijgemaakt.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Als er een fout tijdens een schrijfactie voor asynchrone herstart gebied opgetreden is, er een uitzondering niet gegenereerd totdat de <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>-methode is aangeroepen met de <xref:System.IAsyncResult>geretourneerd door deze methode.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       Wanneer de bewerking is voltooid, is het nummer van het basispartikel sequence bijgewerkt. Alle Meld records met volgnummers kleiner is dan het nieuwe base volgnummer niet toegankelijk zijn.       Als een <xref:System.IO.Log.ReservationCollection>is opgegeven, wordt het gebied geschreven herstart verbruikt ruimte die is eerder gereserveerd, met behulp van een reservering opgenomen in de verzameling.</xref:System.IO.Log.ReservationCollection> Als de methode is gelukt, verbruikt dit de kleinste reservering die de gegevens kan bevatten en reservering wordt verwijderd uit de verzameling.       Als een record reeks afgestoten of als u een ongeldig argument doorgeven, worden uitzonderingen veroorzaakt onmiddellijk binnen deze bewerking. Fouten die zijn opgetreden tijdens een asynchrone append-aanvraag, bijvoorbeeld een schijffout tijdens de i/o-aanvraag resulteert in het uitzonderingen optreden wanneer de <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>methode wordt aangeroepen.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Het nieuwe base volgnummer. Het opgegeven volgnummer moet groter dan of gelijk aan het huidige base volgnummer."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Een <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> waarin de reservering die moet worden gebruikt voor dit gebied opnieuw opstarten."
    - id: callback
      type: System.AsyncCallback
      description: "Een optionele asynchrone terugpostactie, moet worden aangeroepen wanneer het schrijven van de gebied opnieuw opstarten voltooid is."
    - id: state
      type: System.Object
      description: "Een gebruiker gemaakte object dat deze schrijfaanvraag voor bepaalde asynchrone herstart gebied kan worden onderscheiden van andere aanvragen."
    return:
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>dat vertegenwoordigt de asynchrone opnieuw opstarten schrijfbewerking gebied, wat kan nog in behandeling zijn.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het schrijven van het gebied van opnieuw opstarten."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte bevat de nieuwe record maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, maakt u een nieuwe <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "Het zojuist gemaakte <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, toevoegen ends een asynchrone bewerking."
  remarks: "Deze methode worden geblokkeerd totdat het i/o-bewerking is voltooid. Fouten die tijdens een asynchrone schrijfactie-aanvraag, zoals een schijffout tijdens de i/o-aanvraag optreden zichtbaar wanneer EndAppend wordt aangeroepen.       Deze methode moet exact één keer worden aangeroepen voor elke <xref:System.IAsyncResult>geretourneerd door de <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>methode.</xref:System.IO.Log.IRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Een verwijzing naar de openstaande asynchrone i/o-aanvraag."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de toegevoegde logboekrecord."
  overload: System.IO.Log.IRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, eindigt een asynchrone bewerking leegmaken."
  remarks: "Deze methode worden geblokkeerd totdat het i/o-bewerking is voltooid. Fouten die tijdens een asynchrone leegmaken aanvraag, zoals een schijffout tijdens de i/o-aanvraag optreden zichtbaar wanneer EndFlush wordt aangeroepen.       Deze methode moet exact één keer worden aangeroepen voor elke <xref:System.IAsyncResult>geretourneerd door de <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>methode.</xref:System.IO.Log.IRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Een verwijzing naar de openstaande asynchrone i/o-aanvraag."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de laatste record is geschreven."
  overload: System.IO.Log.IRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "In een afgeleide klasse genegeerd, einde van een asynchrone reserveren als toevoegbewerking."
  remarks: "Deze methode worden geblokkeerd totdat het i/o-bewerking is voltooid. Fouten die tijdens een asynchrone schrijfactie-aanvraag, zoals een schijffout tijdens de i/o-aanvraag optreden zichtbaar wanneer EndReserveAndAppend wordt aangeroepen.       Deze methode moet exact één keer worden aangeroepen voor elke <xref:System.IAsyncResult>geretourneerd door de <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>methode.</xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Een verwijzing naar de openstaande asynchrone i/o-aanvraag."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de toegevoegde logboekrecord."
  overload: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, eindigt een schrijfbewerking voor asynchrone herstart gebied."
  remarks: "Deze methode worden geblokkeerd totdat het i/o-bewerking is voltooid. Fouten die tijdens een asynchrone schrijfactie-aanvraag, zoals een schijffout tijdens de i/o-aanvraag optreden zichtbaar wanneer EndWriteRestartArea is aangeroepen.       Deze methode moet exact één keer worden aangeroepen voor elke <xref:System.IAsyncResult>geretourneerd door de <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>methode.</xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Een verwijzing naar de openstaande asynchrone i/o-aanvraag."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de schriftelijke logboekrecord."
  overload: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, zorgt u ervoor dat alle toegevoegde records is geschreven."
  remarks: "Deze methode aanroept, zorgt ervoor dat alle records die zijn toegevoegd aan de <xref:System.IO.Log.IRecordSequence>blijvend is geschreven.</xref:System.IO.Log.IRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de laatste record is geschreven."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden bij het leegmaken van de gegevens."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, zorgt u ervoor dat alle toegevoegde records tot en met de record met het opgegeven volgnummer blijvend is geschreven."
  remarks: "Aanroepen van die deze methode zorgt ervoor dat alle records met sequentie getallen tot en met inbegrip van het opgegeven volgnummer is blijvend geschreven."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de meest recente records die moet worden geschreven. Als dit <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> is ongeldig, en vervolgens alle records moeten worden geschreven."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de laatste record is geschreven."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden bij het leegmaken van de gegevens."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, krijgt u het volgnummer is groter dan de laatste record toegevoegd."
  remarks: "Deze eigenschap bevat een volgnummer dat kan worden gegarandeerd groter is dan het volgnummer van de laatste toegevoegd record. Geldige volgnummers groter zijn dan of gelijk zijn aan <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>en kleiner dan LastSequenceNumber.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      > [!NOTE] > Bij gebruik van een <xref:System.IO.Log.LogRecordSequence>exemplaar, de <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>waarde kunt verouderd raken totdat records worden leeggemaakt op het logboek.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence> Zie <xref:System.IO.Log.IRecordSequence.Flush%2A>en <xref:System.IO.Log.RecordAppendOptions>voor meer informatie over het leegmaken van records...</xref:System.IO.Log.RecordAppendOptions> </xref:System.IO.Log.IRecordSequence.Flush%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Een sequentienummer is groter dan de laatste record toegevoegd."
  overload: System.IO.Log.IRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De eigenschap is geopend nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, krijgt de grootte van de grootste record die kan worden toegevoegd aan of lezen uit deze reeks, in bytes."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "De grootte van de grootste record die kan worden toegevoegd aan of lezen uit deze reeks, in bytes."
  overload: System.IO.Log.IRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De eigenschap is geopend nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, retourneert een verzameling inventariseerbare records in de reeks."
  remarks: "Wanneer in een afgeleide klasse genegeerd, retourneert een verzameling inventariseerbare records in de reeks. De volgorde van de geïnventariseerde records is afhankelijk van de waarde van de `logRecordEnum` parameter."
  example:
  - "This sample demonstrates the use of the ReadLogRecords method.  \n  \n```c#  \nusing System;  \n using System.IO;  \n using System.IO.Log;  \n  \n class ReadRecordsSample  \n {  \n     static SequenceNumber AppendRecord(IRecordSequence sequence,  \n                                        string message,  \n                                        SequenceNumber user,  \n                                        SequenceNumber previous)  \n     {  \n         MemoryStream data = new MemoryStream();  \n         BinaryWriter writer = new BinaryWriter(data);  \n         writer.Write(message);  \n  \n         ArraySegment<byte>[] segments;  \n         segments = new ArraySegment<byte>[1];  \n         segments[0] = new ArraySegment(data.GetBuffer(),  \n                                        0,  \n                                        Data.Length);  \n  \n         return sequence.Append(segments,  \n                                user,  \n                                previous,  \n                                WriteFlags.None);  \n     }  \n  \n     public static void Main(string[] args)  \n     {  \n         IRecordSequence sequence;  \n         sequence = new FileIRecordSequence(args[0]);  \n  \n         SequenceNumber a, b, c, d;  \n  \n         a = AppendRecord(sequence,  \n                          \"This is record A\",  \n                          SequenceNumber.Invalid,  \n                          SequenceNumber.Invalid);  \n         Console.WriteLine(\"Record A has sequence number System.IO.Log\", a);  \n  \n         b = AppendRecord(sequence,  \n                          \"This is record B\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record B has sequence number System.IO.Log\", b);  \n  \n         c = AppendRecord(sequence,  \n                          \"This is record C\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record C has sequence number System.IO.Log\", c);  \n  \n         d = AppendRecord(sequence,  \n                          \"This is record D\",  \n                          b,  \n                          c);  \n         Console.WriteLine(\"Record D has sequence number System.IO.Log\", d);  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(a, ReadDirection.Forward))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.User))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.Previous))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n     }  \n       }  \n```"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de eerste record waarbij lezen wordt gestart."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Een geldige <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> waarde die aangeeft dat de manier (dat wil vooruit of achteruit) in welke records moeten worden gelezen uit een <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Een inventariseerbare verzameling van records in de reeks."
  overload: System.IO.Log.IRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het lezen van de record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, retourneert een verzameling invoeroverzicht van de gebieden opnieuw opstarten in de reeks."
  remarks: "De gebieden opnieuw opstarten worden opgesomd in omgekeerde volgorde numerieke volgorde, dat wil zeggen, van het hoogste volgnummer naar het laagste volgnummer. Alleen gebieden met volgnummers tussen het laatste volgnummer opnieuw te starten en het nummer van het basispartikel sequence worden geïnventariseerd.      > [!NOTE] > Als logboek mate waarin de <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>wordt Veroorzaak beschadigd, kan deze methode gebruiken een <xref:System.IO.IOException>met het foutbericht &quot; de aanvraag kan niet worden uitgevoerd vanwege een onverwachte i/o-uitzondering.</xref:System.IO.IOException> </xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> De volgende foutcode geretourneerd: &quot;80070026&quot; &quot;."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Een verzameling invoeroverzicht van de gebieden opnieuw opstarten in de reeks."
  overload: System.IO.Log.IRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het lezen van de record."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, automatisch maakt een één-reservering en voegt een record met de reeks."
  remarks: "Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       De opgegeven reserveringen worden toegevoegd aan de opgegeven reservering verzameling in een atomic-bewerking met een record toevoegbewerking. Als de toevoegen is mislukt, wordt er geen ruimte is gereserveerd.       Deze methode kan normaal gesproken voltooien voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Een <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> die reserveert in de verzameling bevat."
    - id: reservations
      type: System.Int64[]
      description: "De reserveringen te maken, in bytes."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de toegevoegde logboekrecord."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte op de nieuwe record bevatten, of op de reservering maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, automatisch maakt een één-reservering en voegt een record met de reeks."
  remarks: "Gegevens in de `data` parameter zal worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Echter is geen voorzien verdelen gegevens terug in segmenten van de matrix wanneer de record wordt gelezen.       De opgegeven reserveringen worden toegevoegd aan de opgegeven reservering verzameling in een atomic-bewerking met een record toevoegbewerking. Als de toevoegen is mislukt, wordt er geen ruimte is gereserveerd.       Deze methode kan normaal gesproken voltooien voordat de record is geschreven. Om ervoor te zorgen dat een record is geschreven, geef de <xref:System.IO.Log.RecordAppendOptions>vlag met behulp van de `recordAppendOptions` parameter of een aanroep van de <xref:System.IO.Log.IRecordSequence.Flush%2A>methode.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de volgorde van de gebruiker opgegeven."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de volgende record in de vorige volgorde."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Een geldige waarde van <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> die aangeeft hoe de gegevens worden geschreven."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "De te reserveert in reserveringsverzameling."
    - id: reservations
      type: System.Int64[]
      description: "De reserveringen te maken, in bytes."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de toegevoegde logboekrecord."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het toevoegen van de record."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte op de nieuwe record bevatten, of op de reservering maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, krijgt het totale aantal bytes dat is gereserveerd."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "De totale grootte van alle reserveringen in deze record reeks."
  overload: System.IO.Log.IRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De eigenschap is geopend nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, krijgt het volgnummer van de meest recent geschreven gebied voor opnieuw starten."
  remarks: "Een gebied opnieuw opstarten wordt gebruikt voor het tijdelijk opslaan van gegevens met het laatste controlepuntbewerking van de client. Wanneer een herstel nodig is, kunt u het gebied voor opnieuw starten om alle gegevens ophalen van de laatste controlepuntbewerking parseren. Deze gegevens initialiseert de transactietabel, tabel vervuild pagina&quot;s en bestandstabel geopende zodat ze kunnen worden gebruikt in het herstelproces."
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de meest recent geschreven opnieuw opstarten gebied."
  overload: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De eigenschap is geopend nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Opgehaald of ingesteld met een waarde die aangeeft of voegt automatisch opnieuw uitgevoerd als het logboek vol is."
  remarks: "Als de waarde van deze eigenschap is `true`, en een <xref:System.IO.Log.IRecordSequence.Append%2A>-aanroep is mislukt omdat er niet voldoende ruimte in de reeks, probeert de recordreeks vrije ruimte en probeer opnieuw de toevoegen.</xref:System.IO.Log.IRecordSequence.Append%2A>"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als voegt automatisch opnieuw uitgevoerd als het logboek vol is anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. De standaardwaarde is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De eigenschap is geopend nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Treedt op wanneer de record van de takenreeks bepaalt dat de staart doorsturen moet worden verplaatst."
  remarks: "Deze gebeurtenis geactiveerd wanneer de recordreeks is geen ruimte meer is uitgevoerd, kan worden gestart. Wanneer deze gebeurtenis wordt gestart, wordt het laatste gedeelte van de reeks (dat wil zeggen, het basispartikel sequence number) doorsturen verplaatst naar ruimte vrij te maken."
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, schrijft u een gebied voor opnieuw starten op de <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Een gebied opnieuw opstarten wordt gebruikt voor het tijdelijk opslaan van gegevens met het laatste controlepuntbewerking van de client. De algemene Log File System (CLFS) onderhoudt dat twee gebieden om ervoor te zorgen dat ten minste één geldig gebied altijd beschikbaar is opnieuw opstarten. Wanneer een herstel nodig is, leest de CLFS gebied voor het opnieuw starten en alle gegevens van de laatste controlepuntbewerking. Deze gegevens initialiseert de transactietabel, tabel vervuild pagina&quot;s en bestandstabel geopende zodat ze kunnen worden gebruikt in het herstelproces.       Een gebied opnieuw kan worden gelezen met de <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>methode.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       De gegevens in de segmenten byte-matrix wordt worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Er is geen mogelijkheid is voorzien van de gegevens terug in de matrix segmenten worden gesplitst wanneer het gebied van opnieuw opstarten wordt gelezen."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de schriftelijke opnieuw opstarten gebied."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het schrijven van het gebied van opnieuw opstarten."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte voor het nieuwe herstart gebied bevatten maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, schrijft u een gebied voor opnieuw starten op de <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Een gebied opnieuw opstarten wordt gebruikt voor het tijdelijk opslaan van gegevens met het laatste controlepuntbewerking van de client. Wanneer een herstel nodig is, kunt u het gebied voor opnieuw starten om alle gegevens ophalen van de laatste controlepuntbewerking parseren. Deze gegevens initialiseert de transactietabel, tabel vervuild pagina&quot;s en bestandstabel geopende zodat ze kunnen worden gebruikt in het herstelproces. Een gebied opnieuw kan worden gelezen met de <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>methode.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       De gegevens in de segmenten byte-matrix wordt worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Er is geen mogelijkheid is voorzien van de gegevens terug in de matrix segmenten worden gesplitst wanneer het gebied van opnieuw opstarten wordt gelezen."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de schriftelijke opnieuw opstarten gebied."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het schrijven van het gebied van opnieuw opstarten."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte voor het nieuwe herstart gebied bevatten maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, schrijft u een gebied voor opnieuw starten op de <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> en updates van het basispartikel sequence-nummer"
  remarks: "Een gebied opnieuw opstarten wordt gebruikt voor het tijdelijk opslaan van gegevens met het laatste controlepuntbewerking van de client. Wanneer een herstel nodig is, kunt u het gebied voor opnieuw starten om alle gegevens ophalen van de laatste controlepuntbewerking parseren. Deze gegevens initialiseert de transactietabel, tabel vervuild pagina&quot;s en bestandstabel geopende zodat ze kunnen worden gebruikt in het herstelproces. Een gebied opnieuw kan worden gelezen met de <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>methode.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Wanneer een gebied voor opnieuw starten wordt geschreven, worden de gegevens in de matrix byte segmenten worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Er is geen mogelijkheid is voorzien van de gegevens terug in de matrix segmenten worden gesplitst wanneer het gebied van opnieuw opstarten wordt gelezen.       Wanneer deze methode is voltooid, is het nummer van het basispartikel sequence bijgewerkt. Alle Meld records met volgnummers kleiner is dan het nieuwe base volgnummer niet toegankelijk zijn."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Het nieuwe base volgnummer. Het opgegeven volgnummer moet groter dan of gelijk aan het huidige base volgnummer."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de schriftelijke opnieuw opstarten gebied."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het schrijven van het gebied van opnieuw opstarten."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte voor het nieuwe herstart gebied bevatten maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, schrijft u een gebied voor opnieuw starten op de <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> en updates van het basispartikel sequence-nummer."
  remarks: "Een gebied opnieuw opstarten wordt gebruikt voor het tijdelijk opslaan van gegevens met het laatste controlepuntbewerking van de client. Wanneer een herstel nodig is, kunt u het gebied voor opnieuw starten om alle gegevens ophalen van de laatste controlepuntbewerking parseren. Deze gegevens initialiseert de transactietabel, tabel vervuild pagina&quot;s en bestandstabel geopende zodat ze kunnen worden gebruikt in het herstelproces. Een gebied opnieuw kan worden gelezen met de <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>methode.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Wanneer een gebied voor opnieuw starten wordt geschreven, worden de gegevens in de matrix byte segmenten worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Er is geen mogelijkheid is voorzien van de gegevens terug in de matrix segmenten worden gesplitst wanneer het gebied van opnieuw opstarten wordt gelezen.       Wanneer deze methode is voltooid, is het nummer van het basispartikel sequence bijgewerkt. Alle Meld records met volgnummers kleiner is dan het nieuwe base volgnummer niet toegankelijk zijn."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Het nieuwe base volgnummer. Het opgegeven volgnummer moet groter dan of gelijk aan het huidige base volgnummer."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de schriftelijke opnieuw opstarten gebied."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het schrijven van het gebied van opnieuw opstarten."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte voor het nieuwe herstart gebied bevatten maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, schrijft u een gebied voor opnieuw starten op de <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> met behulp van een reservering en updates van het basispartikel sequence-nummer"
  remarks: "Een gebied opnieuw opstarten wordt gebruikt voor het tijdelijk opslaan van gegevens met het laatste controlepuntbewerking van de client. Wanneer een herstel nodig is, kunt u het gebied voor opnieuw starten om alle gegevens ophalen van de laatste controlepuntbewerking parseren. Deze gegevens initialiseert de transactietabel, tabel vervuild pagina&quot;s en bestandstabel geopende zodat ze kunnen worden gebruikt in het herstelproces. Een gebied opnieuw kan worden gelezen met de <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>methode.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Wanneer een gebied voor opnieuw starten wordt geschreven, worden de gegevens in de matrix byte segmenten worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Er is geen mogelijkheid is voorzien van de gegevens terug in de matrix segmenten worden gesplitst wanneer het gebied van opnieuw opstarten wordt gelezen.       Als een reservering is opgegeven, wordt het gebied geschreven opnieuw opstarten ruimte die is eerder gereserveerd, met behulp van een reservering opgenomen in de verzameling verbruiken. Als de methode is gelukt, verbruikt dit de kleinste reservering die de gegevens kan bevatten en reservering wordt verwijderd uit de verzameling.       Wanneer deze methode is voltooid, is het nummer van het basispartikel sequence bijgewerkt. Alle Meld records met volgnummers kleiner is dan het nieuwe base volgnummer niet toegankelijk zijn.       Als een record reeks afgestoten of als u een ongeldig argument doorgeven, worden uitzonderingen veroorzaakt onmiddellijk binnen deze bewerking. Fouten die zijn opgetreden tijdens een asynchrone append-aanvraag, bijvoorbeeld een schijffout tijdens de i/o-aanvraag resulteert in het uitzonderingen optreden wanneer de <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>methode wordt aangeroepen.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Het nieuwe base volgnummer. Het opgegeven volgnummer moet groter dan of gelijk aan het huidige base volgnummer."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Een <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> waarin de reservering die moet worden gebruikt voor dit gebied opnieuw opstarten."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de schriftelijke opnieuw opstarten gebied."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het schrijven van het gebied van opnieuw opstarten."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte voor het nieuwe herstart gebied bevatten maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Wanneer in een afgeleide klasse genegeerd, schrijft u een gebied voor opnieuw starten op de <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> met behulp van een reservering en updates van het basispartikel sequence-nummer."
  remarks: "Een gebied opnieuw opstarten wordt gebruikt voor het tijdelijk opslaan van gegevens met het laatste controlepuntbewerking van de client. Wanneer een herstel nodig is, kunt u het gebied voor opnieuw starten om alle gegevens ophalen van de laatste controlepuntbewerking parseren. Deze gegevens initialiseert de transactietabel, tabel vervuild pagina&quot;s en bestandstabel geopende zodat ze kunnen worden gebruikt in het herstelproces. Een gebied opnieuw kan worden gelezen met de <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>methode.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Wanneer een gebied voor opnieuw starten wordt geschreven, worden de gegevens in de matrix byte segmenten worden samengevoegd tot één byte-matrix voor het toevoegen als de record. Er is geen mogelijkheid is voorzien van de gegevens terug in de matrix segmenten worden gesplitst wanneer het gebied van opnieuw opstarten wordt gelezen.       Als een reservering is opgegeven, wordt het gebied geschreven opnieuw opstarten ruimte die is eerder gereserveerd, met behulp van een reservering opgenomen in de verzameling verbruiken. Als de methode is gelukt, verbruikt dit de kleinste reservering die de gegevens kan bevatten en reservering wordt verwijderd uit de verzameling.       Wanneer deze methode is voltooid, is het nummer van het basispartikel sequence bijgewerkt. Alle Meld records met volgnummers kleiner is dan het nieuwe base volgnummer niet toegankelijk zijn.       Als een record reeks afgestoten of als u een ongeldig argument doorgeven, worden uitzonderingen veroorzaakt onmiddellijk binnen deze bewerking. Fouten die zijn opgetreden tijdens een asynchrone append-aanvraag, bijvoorbeeld een schijffout tijdens de i/o-aanvraag resulteert in het uitzonderingen optreden wanneer de <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>methode wordt aangeroepen.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Een lijst met byte-matrix segmenten die worden samengevoegd en toegevoegd als de record."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Het nieuwe base volgnummer. Het opgegeven volgnummer moet groter dan of gelijk aan het huidige base volgnummer."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Een <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> waarin de reservering die moet worden gebruikt voor dit gebied opnieuw opstarten."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Het volgnummer van de schriftelijke opnieuw opstarten gebied."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Een of meer van de argumenten is ongeldig."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een i/o-fout opgetreden tijdens het schrijven van het gebied van opnieuw opstarten."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "De recordreeks kan niet voldoende vrije ruimte voor het nieuwe herstart gebied bevatten maken."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De methode is aangeroepen nadat de volgorde van is verwijderd."
  platform:
  - net462
references:
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.Flush
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.IRecordSequence.TailPinned
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.Append*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append
  nameWithType: IRecordSequence.Append
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: IRecordSequence.BeginAppend
- uid: System.IO.Log.IRecordSequence.BeginFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: IRecordSequence.BeginFlush
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: IRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: IRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: IRecordSequence.CreateReservationCollection
- uid: System.IO.Log.IRecordSequence.EndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: IRecordSequence.EndAppend
- uid: System.IO.Log.IRecordSequence.EndFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: IRecordSequence.EndFlush
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: IRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: IRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.IRecordSequence.Flush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush
  nameWithType: IRecordSequence.Flush
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
- uid: System.IO.Log.IRecordSequence.ReadLogRecords*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: IRecordSequence.ReadLogRecords
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: IRecordSequence.ReadRestartAreas
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: IRecordSequence.ReserveAndAppend
- uid: System.IO.Log.IRecordSequence.ReservedBytes*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
- uid: System.IO.Log.IRecordSequence.WriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: IRecordSequence.WriteRestartArea
