### YamlMime:ManagedReference
items:
- uid: System.Threading.Thread
  id: Thread
  children:
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  - System.Threading.Thread.Abort
  - System.Threading.Thread.Abort(System.Object)
  - System.Threading.Thread.AllocateDataSlot
  - System.Threading.Thread.AllocateNamedDataSlot(System.String)
  - System.Threading.Thread.ApartmentState
  - System.Threading.Thread.BeginCriticalRegion
  - System.Threading.Thread.BeginThreadAffinity
  - System.Threading.Thread.CurrentContext
  - System.Threading.Thread.CurrentCulture
  - System.Threading.Thread.CurrentPrincipal
  - System.Threading.Thread.CurrentThread
  - System.Threading.Thread.CurrentUICulture
  - System.Threading.Thread.DisableComObjectEagerCleanup
  - System.Threading.Thread.EndCriticalRegion
  - System.Threading.Thread.EndThreadAffinity
  - System.Threading.Thread.ExecutionContext
  - System.Threading.Thread.Finalize
  - System.Threading.Thread.FreeNamedDataSlot(System.String)
  - System.Threading.Thread.GetApartmentState
  - System.Threading.Thread.GetCompressedStack
  - System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  - System.Threading.Thread.GetDomain
  - System.Threading.Thread.GetDomainID
  - System.Threading.Thread.GetHashCode
  - System.Threading.Thread.GetNamedDataSlot(System.String)
  - System.Threading.Thread.Interrupt
  - System.Threading.Thread.IsAlive
  - System.Threading.Thread.IsBackground
  - System.Threading.Thread.IsThreadPoolThread
  - System.Threading.Thread.Join
  - System.Threading.Thread.Join(System.Int32)
  - System.Threading.Thread.Join(System.TimeSpan)
  - System.Threading.Thread.ManagedThreadId
  - System.Threading.Thread.MemoryBarrier
  - System.Threading.Thread.Name
  - System.Threading.Thread.Priority
  - System.Threading.Thread.ResetAbort
  - System.Threading.Thread.Resume
  - System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  - System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  - System.Threading.Thread.Sleep(System.Int32)
  - System.Threading.Thread.Sleep(System.TimeSpan)
  - System.Threading.Thread.SpinWait(System.Int32)
  - System.Threading.Thread.Start
  - System.Threading.Thread.Start(System.Object)
  - System.Threading.Thread.Suspend
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Threading.Thread.ThreadState
  - System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.VolatileRead(System.Byte@)
  - System.Threading.Thread.VolatileRead(System.Double@)
  - System.Threading.Thread.VolatileRead(System.Int16@)
  - System.Threading.Thread.VolatileRead(System.Int32@)
  - System.Threading.Thread.VolatileRead(System.Int64@)
  - System.Threading.Thread.VolatileRead(System.IntPtr@)
  - System.Threading.Thread.VolatileRead(System.Object@)
  - System.Threading.Thread.VolatileRead(System.SByte@)
  - System.Threading.Thread.VolatileRead(System.Single@)
  - System.Threading.Thread.VolatileRead(System.UInt16@)
  - System.Threading.Thread.VolatileRead(System.UInt32@)
  - System.Threading.Thread.VolatileRead(System.UInt64@)
  - System.Threading.Thread.VolatileRead(System.UIntPtr@)
  - System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  - System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  - System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  - System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  - System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  - System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  - System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  - System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  - System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  - System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  - System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  - System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  - System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  - System.Threading.Thread.Yield
  langs:
  - csharp
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
  type: Class
  summary: "Maakt en beheert een thread, stelt de prioriteit en opgehaald van de status ervan."
  remarks: "Wanneer een proces wordt gestart, maakt de common language runtime automatisch een één achtergrond-thread voor het uitvoeren van toepassingscode. Samen met deze thread belangrijkste voorgrond kunt een proces maken van een of meer threads voor het uitvoeren van een deel van de programmacode dat is gekoppeld aan het proces. Deze threads kunnen worden uitgevoerd op de voorgrond of op de achtergrond. Bovendien kunt u de <xref:System.Threading.ThreadPool>klasse code uitvoeren op de worker-threads die worden beheerd door de common language runtime.</xref:System.Threading.ThreadPool>       In deze sectie [vanaf een thread](#Starting)[bij het ophalen van Thread-objecten](#Retrieving)[voor- en achtergrond threads](#Foreground)[cultuur en threads](#Culture)[ophalen van informatie over en controle over threads](#Properties)[toegang tot de broncode voor de Thread-klasse](#Source) <a name=&quot;Starting&quot;> </a> ## vanaf een thread u geen thread starten door het opgeven van een gemachtigde met de methode die de thread zich in de klassenconstructor worden uitgevoerd.                                Vervolgens aanroepen de <xref:System.Threading.Thread.Start%2A>methode om te beginnen met de uitvoering.</xref:System.Threading.Thread.Start%2A>       De Thread-constructors kunnen duren voordat een van twee gemachtigde typen, afhankelijk van of u een argument doorgeven aan de methode die kunt moet worden uitgevoerd:-als de methode geen argumenten heeft, geeft u een <xref:System.Threading.ThreadStart>delegeren aan de constructor.</xref:System.Threading.ThreadStart> De handtekening heeft: ```c#       public delegate void ThreadStart()       ``` ```vb       Public Delegate Sub ThreadStart()       ``` in het volgende voorbeeld maakt en begint met een thread die wordt uitgevoerd de `ExecuteInForeground` methode.           De methode geeft informatie weer over een enkele thread-eigenschappen en vervolgens voert een lus waarin een halve seconde wordt onderbroken, en wordt het verstreken aantal seconden weergegeven. Wanneer de thread is uitgevoerd voor ten minste vijf seconden, beëindigt de lus wordt beëindigd en de thread worden uitgevoerd.           [!code-cs[System.Threading.Thread#1](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)][!code-vb[System.Threading.Thread#1](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb) ] -als de methode een argument heeft, geeft u een <xref:System.Threading.ParameterizedThreadStart>delegeren aan de constructor.</xref:System.Threading.ParameterizedThreadStart>       De handtekening heeft: ```c#       public delegate void ParameterizedThreadStart(object obj)       ``` ```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ``` de methode die wordt uitgevoerd door de gemachtigde kunt cast-conversie (in C#) of converteren (in Visual Basic) met de parameter naar het juiste type.                     Het volgende voorbeeld is identiek aan de vorige sectie, behalve dat roept de <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>constructor.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Deze versie van de `ExecuteInForeground` methode heeft één parameter waarmee het geschatte aantal milliseconden dat de lus moet worden uitgevoerd.           [!code-cs[System.Threading.Thread#2](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)][!code-vb[System.Threading.Thread#2](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb) ] is het niet nodig voor het bewaren van een verwijzing naar een threadobject zodra u de thread hebt gestart.       De thread blijft uitvoeren totdat de thread-procedure voltooid is.      <a name=&quot;Retrieving&quot;></a>## U kunt de statische bij het ophalen van Thread-objecten (`Shared` in Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A>eigenschap voor het ophalen van een verwijzing naar de momenteel uitgevoerde thread van de code die de thread wordt uitgevoerd.</xref:System.Threading.Thread.CurrentThread%2A> Het volgende voorbeeld wordt de <xref:System.Threading.Thread.CurrentThread%2A>eigenschap informatie weergegeven over de hoofdtoepassingsthread, een andere thread van de voorgrond, een achtergrond-thread en een thread-pool-thread.</xref:System.Threading.Thread.CurrentThread%2A>       [!code-cs[System.Threading.Thread#4](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)][!code-vb[System.Threading.Thread#4](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb) ] <a name=&quot;Foreground&quot;> </a> ## voor- en achtergrond threads instanties van de klasse Thread vertegenwoordigen voorgrond threads of threads op de achtergrond.         Threads op de achtergrond zijn identiek aan de voorgrond threads met één uitzondering: een achtergrond-thread houdt geen een proces dat wordt uitgevoerd als alle voorgrond threads zijn beëindigd. Zodra alle voorgrond threads zijn gestopt, wordt de runtime stopt alle threads op de achtergrond en wordt afgesloten.       Standaard worden de volgende threads uitvoeren op de voorgrond:-de hoofdtoepassing-thread.      -Alle threads gemaakt door het aanroepen van een Thread klassen-constructor.       De volgende threads standaard uitgevoerd op de achtergrond:-Thread-pool-threads die een groep beheerd door de runtime werkthreads zijn.  U kunt het thread-pool en planning werk op thread groepsthreads configureren met behulp van de <xref:System.Threading.ThreadPool>klasse.</xref:System.Threading.ThreadPool>          > [!NOTE] > Taakgebaseerde asynchrone bewerkingen automatisch worden uitgevoerd op thread groepsthreads. Taakgebaseerde asynchrone bewerkingen gebruik van de <xref:System.Threading.Tasks.Task>en <xref:System.Threading.Tasks.Task%601>klassen voor het implementeren van de [taakgebaseerde asynchrone patroon](~/add/includes/ajax-current-ext-md.md).</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -Alle threads de beheerde uitvoeringsomgeving van die niet-beheerde code.       Kunt u een thread moet worden uitgevoerd op de achtergrond door in te stellen de <xref:System.Threading.Thread.IsBackground%2A>eigenschap op elk gewenst moment.</xref:System.Threading.Thread.IsBackground%2A>  Threads op de achtergrond zijn handig voor een bewerking die moet worden voortgezet als een toepassing wordt uitgevoerd, maar niet voorkomen de toepassing wordt beëindigd dat mag, zoals controle van wijzigingen in het bestandssysteem of binnenkomende socketverbindingen.       Het volgende voorbeeld ziet u het verschil tussen de voor- en achtergrond threads. Dit lijkt op het eerste voorbeeld in de [vanaf een thread](#Starting) sectie, behalve dat de thread worden uitgevoerd op de achtergrond voordat het opnieuw wordt ingesteld. Zoals u in de uitvoer ziet, wordt de lus onderbroken voordat deze wordt uitgevoerd gedurende vijf seconden.       [!code-cs[System.Threading.Thread#3](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)][!code-vb[System.Threading.Thread#3](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb) ] <a name=&quot;Culture&quot;> </a> ## cultuur en threads elke thread heeft een cultuur, vertegenwoordigd door de <xref:System.Threading.Thread.CurrentCulture%2A>eigenschap en een gebruikersinterfacecultuur dat wordt vertegenwoordigd door de <xref:System.Threading.Thread.CurrentUICulture%2A>eigenschap.</xref:System.Threading.Thread.CurrentUICulture%2A> </xref:System.Threading.Thread.CurrentCulture%2A>          De huidige cultuur ondersteunt deze cultuur-gevoelige bewerkingen parseren en opmaak, tekenreeksvergelijking en sorteren en bepaalt ook het schrijven systeem en de kalender die wordt gebruikt door een thread. De huidige gebruikersinterfacecultuur biedt voor cultuur gevoelig voor het ophalen van resources in de bronbestanden.       Wanneer een nieuwe thread is gestart, wordt de cultuur en gebruikersinterfacecultuur gedefinieerd door de huidige systeemcultuur en gebruikersinterfacecultuur, en niet door de cultuur en gebruikersinterfacecultuur van de thread waarin het nieuwe thread is gemaakt. Dit betekent bijvoorbeeld dat als de huidige systeemcultuur Engels (Verenigde Staten) en de huidige cultuur van de primaire toepassingsthread Frans (Frankrijk), de cultuur van een nieuwe thread gemaakt door het aanroepen van de <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>constructor vanuit de primaire thread is Engels (Verenigde Staten) en niet Frans (Frankrijk).</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Zie voor meer informatie de sectie &quot;Cultuur en threads&quot; van de <xref:System.Globalization.CultureInfo>klasse onderwerp.</xref:System.Globalization.CultureInfo>      > [!IMPORTANT] > Dit geldt niet threads die asynchrone bewerkingen voor apps die zijn gericht uitvoeren de [!INCLUDE[net_v46](~/add/includes/net-v46-md.md)] en latere versies, In dit geval de cultuur en gebruikersinterfacecultuur maakt deel uit van een asynchrone bewerkingen context; de thread waarop een asynchrone bewerking wordt uitgevoerd standaard neemt de cultuur en gebruikersinterfacecultuur van de thread van waaruit de asynchrone bewerking is gestart. Voor meer informatie, Zie de sectie &quot;Cultuur en taakgebaseerde asynchrone bewerkingen&quot; van de <xref:System.Globalization.CultureInfo>klasse onderwerp.</xref:System.Globalization.CultureInfo>       U kunt doen van de volgende ervoor te zorgen dat alle threads wordt uitgevoerd in een toepassing delen de dezelfde cultuur en gebruikersinterfacecultuur:-u kunt doorgeven een <xref:System.Globalization.CultureInfo>-object dat dat de cultuur aangeeft de <xref:System.Threading.ParameterizedThreadStart>delegeren of de <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName>methode.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName> </xref:System.Threading.ParameterizedThreadStart> </xref:System.Globalization.CultureInfo>      -Voor apps die worden uitgevoerd op de [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] en latere versies kunt u de cultuur en gebruikersinterfacecultuur die moet worden toegewezen aan alle threads in een toepassingsdomein is gemaakt door de waarde van de <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName>en <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName>Eigenschappen.</xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName> </xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName> Houd er rekening mee dat dit de domeininstelling van een per toepassing is.       Voor meer informatie over en voorbeelden, Zie de sectie &quot;Cultuur en threads&quot; van de <xref:System.Globalization.CultureInfo>klasse onderwerp.</xref:System.Globalization.CultureInfo>      <a name=&quot;Properties&quot;></a>## U kunt een aantal eigenschapswaarden die informatie over een thread bevatten ophalen ophalen van informatie over en beheren van threads. In sommige gevallen kunt u ook de waarden van deze eigenschappen bepalen de werking van de thread instellen. Deze thread-eigenschappen zijn:-een naam. <xref:System.Threading.Thread.Name%2A>is een schrijfbewerking-eenmaal eigenschap die u gebruiken kunt om te identificeren, een thread.</xref:System.Threading.Thread.Name%2A>  De standaardwaarde is `null`.      -Een hashcode die u ophalen door het aanroepen van kunt de <xref:System.Threading.Thread.GetHashCode%2A>methode.</xref:System.Threading.Thread.GetHashCode%2A> De hash-code kan worden gebruikt als unieke identificatie van een thread. de hash-code wordt voor de levensduur van de thread niet conflicteren met de waarde van een andere thread, ongeacht het toepassingsdomein van waaruit u de waarde niet ophalen.      -Een thread-ID. De waarde van de alleen-lezen <xref:System.Threading.Thread.ManagedThreadId%2A>eigenschap wordt toegewezen door de runtime en een thread in het proces wordt aangeduid.</xref:System.Threading.Thread.ManagedThreadId%2A>          > [!NOTE] > Een besturingssysteem [thread-id](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) heeft geen vaste betrekking op een beheerde thread, omdat een niet-beheerde host de relatie tussen beheerde en onbeheerde threads kunt bepalen. In het bijzonder een geavanceerde host kunt gebruiken de [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) veel beheerde threads met dezelfde thread als besturingssysteem of een beheerde thread verplaatsen tussen verschillende besturingssysteem threads.      -De huidige status van de thread. Voor de duur van het bestaan van een thread is altijd in een of meer van de statussen die zijn gedefinieerd door de <xref:System.Threading.ThreadState>eigenschap.</xref:System.Threading.ThreadState>      -Een planning prioriteitsniveau wordt gedefinieerd door de <xref:System.Threading.ThreadPriority>eigenschap.</xref:System.Threading.ThreadPriority> U kunt deze waarde om aan te vragen van de thread prioriteit instellen, is er geen garantie om te worden uitgevoerd door het besturingssysteem.      -De alleen-lezen <xref:System.Threading.Thread.IsThreadPoolThread%2A>eigenschap waarmee wordt aangegeven of een thread een thread-pool-thread is.</xref:System.Threading.Thread.IsThreadPoolThread%2A>      -De <xref:System.Threading.Thread.IsBackground%2A>eigenschap.</xref:System.Threading.Thread.IsBackground%2A> Zie voor meer informatie de [voor- en achtergrond threads](#Foreground) sectie.      <a name=&quot;Source&quot;></a>## Toegang tot de broncode voor de klasse Thread om weer te geven van de .NET Framework-broncode voor de Thread-klasse, Zie de [Verwijzingsbron](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96). Blader door de broncode online, downloaden de verwijzing voor offline te bekijken en doorloop de bronnen (met inbegrip van patches en updates) tijdens de foutopsporing; Zie [instructies](http://referencesource.microsoft.com/)."
  example:
  - "The following example demonstrates simple threading functionality.  \n  \n [!code-cpp[Classic Thread Example#1](~/add/codesnippet/cpp/t-system.threading.thread_5.cpp)]\n [!code-vb[Classic Thread Example#1](~/add/codesnippet/visualbasic/t-system.threading.thread_5.vb)]\n [!code-cs[Classic Thread Example#1](~/add/codesnippet/csharp/t-system.threading.thread_5.cs)]  \n  \n This code produces output similar to the following:  \n  \n```  \n[VB, C++, C#]  \nMain thread: Start a second thread.  \nMain thread: Do some work.  \nThreadProc: 0  \nMain thread: Do some work.  \nThreadProc: 1  \nMain thread: Do some work.  \nThreadProc: 2  \nMain thread: Do some work.  \nThreadProc: 3  \nMain thread: Call Join(), to wait until ThreadProc ends.  \nThreadProc: 4  \nThreadProc: 5  \nThreadProc: 6  \nThreadProc: 7  \nThreadProc: 8  \nThreadProc: 9  \nMain thread: ThreadProc.Join has returned.  Press Enter to end program.  \n```"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements:
  - System.Runtime.InteropServices._Thread
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  id: '#ctor(System.Threading.ParameterizedThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Threading.Thread&quot;> </xref> klasse, geven een gemachtigde waarmee een object dat moet worden doorgegeven aan de thread wanneer de thread is gestart."
  remarks: "Een thread begint niet uitvoeren wanneer deze wordt gemaakt. Als u de thread voor uitvoering plannen, roepen de <xref:System.Threading.Thread.Start%2A>methode.</xref:System.Threading.Thread.Start%2A> Een gegevensobject doorgeven aan de thread, gebruiken de <xref:System.Threading.Thread.Start%28System.Object%29>methode-overload.</xref:System.Threading.Thread.Start%28System.Object%29>      > [!NOTE] > Visual Basic-gebruikers kunnen weglaten de <xref:System.Threading.ThreadStart>constructor bij het maken van een thread.</xref:System.Threading.ThreadStart> Gebruik de `AddressOf` operator als bijvoorbeeld uw methode doorgegeven `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic aanroepen automatisch de <xref:System.Threading.ThreadStart>constructor.</xref:System.Threading.ThreadStart>"
  example:
  - "The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_19_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_19_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_19_1.cs)]"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "Een gemachtigde met de methoden kan worden aangeroepen wanneer het uitvoeren van deze thread wordt gestart."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  id: '#ctor(System.Threading.ThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Threading.Thread&quot;> </xref> klasse."
  remarks: "Een thread begint niet uitvoeren wanneer deze wordt gemaakt. Als u de thread voor uitvoering plannen, roepen de <xref:System.Threading.Thread.Start%2A>methode.</xref:System.Threading.Thread.Start%2A>      > [!NOTE] > Visual Basic-gebruikers kunnen weglaten de <xref:System.Threading.ThreadStart>constructor bij het maken van een thread.</xref:System.Threading.ThreadStart> Gebruik de `AddressOf` operator als bijvoorbeeld uw methode doorgegeven `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic aanroepen automatisch de <xref:System.Threading.ThreadStart>constructor.</xref:System.Threading.ThreadStart>"
  example:
  - "The following code example shows how to create a thread that executes a static method.  \n  \n [!code-cpp[System.Threading.Thread.ctor#1](~/add/codesnippet/cpp/m-system.threading.threa_18_1.cpp)]\n [!code-vb[System.Threading.Thread.ctor#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_1.vb)]\n [!code-cs[System.Threading.Thread.ctor#1](~/add/codesnippet/csharp/m-system.threading.threa_18_1.cs)]  \n  \n The following code example shows how to create a thread that executes an instance method.  \n  \n [!code-cs[System.Threading.Thread.ctor2#1](~/add/codesnippet/csharp/m-system.threading.threa_18_2.cs)]\n [!code-vb[System.Threading.Thread.ctor2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_2.vb)]\n [!code-cpp[System.Threading.Thread.ctor2#1](~/add/codesnippet/cpp/m-system.threading.threa_18_2.cpp)]"
  syntax:
    content: public Thread (System.Threading.ThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "Een <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> gemachtigde die staat voor de methoden kan worden aangeroepen wanneer het uitvoeren van deze thread wordt gestart."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>start</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  id: '#ctor(System.Threading.ParameterizedThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Threading.Thread&quot;> </xref> klasse, geven een gemachtigde waarmee een object dat moet worden doorgegeven aan de thread wanneer de thread is gestart en de grootte van de maximale aanroepstack voor de thread op te geven."
  remarks: "Vermijd het gebruik van deze constructor overbelasting. De standaardgrootte van de stack gebruikt door de <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>overbelasting van de constructor is de aanbevolen stackgrootte voor threads.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Als een thread geheugenproblemen heeft, kan de meest waarschijnlijke oorzaak is opgetreden, zoals een oneindige recursie programmeren.      > [!IMPORTANT] > Vanaf de [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], alleen volledig vertrouwde code kunt instellen `maxStackSize` op een waarde die groter is dan de standaardgrootte van stack (1 MB). Als een hogere waarde is opgegeven voor `maxStackSize` als code wordt uitgevoerd met gedeeltelijk vertrouwen `maxStackSize` wordt genegeerd en de standaardgrootte stack wordt gebruikt. Er is geen uitzondering is opgetreden. De code op een vertrouwensniveau kunt instellen `maxStackSize` op een waarde die kleiner is dan de standaardgrootte van de stack.      > [!NOTE] > Als ontwikkelt u een volledig vertrouwd bibliotheek die wordt gebruikt door gedeeltelijk vertrouwde code en moet u een thread die een grote stack moet starten, u volledig vertrouwen assert moet voordat u de thread maakt of de standaardgrootte stack wordt gebruikt. Doe dit niet, tenzij u de code die wordt uitgevoerd op de thread volledig beheren.       Als `maxStackSize` is kleiner dan de minimale stackgrootte, de grootte van de minimale aanroepstack wordt gebruikt. Als `maxStackSize` is geen meervoud van de paginagrootte wordt afgerond op het volgende groter veelvoud van de paginagrootte. Als u .NET Framework versie 2.0 op Windows Vista gebruikt, 256KB (262.144 bytes) is de minimale stackgrootte en het paginaformaat is 64KB (65.536 bytes).      > [!NOTE] > Op versies van Microsoft Windows voorafgaand aan Windows XP en Windows Server 2003, `maxStackSize` wordt genegeerd en de grootte van aanroepstack opgegeven in de header uitvoerbare wordt gebruikt.       Als u een zeer kleine stackgrootte opgeeft, moet u mogelijk stack-overloop scannen uitschakelen. Wanneer de stack ernstige problemen wordt beperkt, het zoeken kan zichzelf leiden tot een stack-overloop. Als wilt uitschakelen stack-overloop scannen, moet u de volgende toevoegen aan uw configuratiebestand van de toepassing.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "Een <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> gemachtigde die staat voor de methoden kan worden aangeroepen wanneer het uitvoeren van deze thread wordt gestart."
    - id: maxStackSize
      type: System.Int32
      description: "De maximale grootte van aanroepstack, in bytes moet worden gebruikt door de thread of 0 stack maximale grootte van de opgegeven in de header voor het uitvoerbare bestand te gebruiken.       Belangrijk voor gedeeltelijk vertrouwde code, `maxStackSize` wordt genegeerd als die groter dan de standaardgrootte van de stack is. Er is geen uitzondering is opgetreden."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>is kleiner dan nul."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  id: '#ctor(System.Threading.ThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Threading.Thread&quot;> </xref> klasse, geven de van maximale stackgrootte voor de thread."
  remarks: "Vermijd het gebruik van deze constructor overbelasting. De standaardgrootte van de stack gebruikt door de <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>overbelasting van de constructor is de aanbevolen stackgrootte voor threads.</xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> Als een thread geheugenproblemen heeft, kan de meest waarschijnlijke oorzaak is opgetreden, zoals een oneindige recursie programmeren.      > [!IMPORTANT] > Vanaf de [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], alleen volledig vertrouwde code kunt instellen `maxStackSize` op een waarde die groter is dan de standaardgrootte van stack (1 MB). Als een hogere waarde is opgegeven voor `maxStackSize` als code wordt uitgevoerd met gedeeltelijk vertrouwen `maxStackSize` wordt genegeerd en de standaardgrootte stack wordt gebruikt. Er is geen uitzondering is opgetreden. De code op een vertrouwensniveau kunt instellen `maxStackSize` op een waarde die kleiner is dan de standaardgrootte van de stack.      > [!NOTE] > Als ontwikkelt u een volledig vertrouwd bibliotheek die wordt gebruikt door gedeeltelijk vertrouwde code en moet u een thread die een grote stack moet starten, u volledig vertrouwen assert moet voordat u de thread maakt of de standaardgrootte stack wordt gebruikt. Doe dit niet, tenzij u de code die wordt uitgevoerd op de thread volledig beheren.       Als `maxStackSize` is kleiner dan de minimale stackgrootte, de grootte van de minimale aanroepstack wordt gebruikt. Als `maxStackSize` is geen meervoud van de paginagrootte wordt afgerond op het volgende groter veelvoud van de paginagrootte. Als u .NET Framework versie 2.0 op Windows Vista gebruikt, 256KB (262.144 bytes) is de minimale stackgrootte en het paginaformaat is 64KB (65.536 bytes).      > [!NOTE] > Op versies van Microsoft Windows voorafgaand aan Windows XP en Windows Server 2003, `maxStackSize` wordt genegeerd en de grootte van aanroepstack opgegeven in de header uitvoerbare wordt gebruikt.       Als u een zeer kleine stackgrootte opgeeft, moet u mogelijk stack-overloop scannen uitschakelen. Wanneer de stack ernstige problemen wordt beperkt, het zoeken kan zichzelf leiden tot een stack-overloop. Als wilt uitschakelen stack-overloop scannen, moet u de volgende toevoegen aan uw configuratiebestand van de toepassing.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "Een <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> gemachtigde die staat voor de methoden kan worden aangeroepen wanneer het uitvoeren van deze thread wordt gestart."
    - id: maxStackSize
      type: System.Int32
      description: "De maximale grootte van aanroepstack, in bytes moet worden gebruikt door de thread of 0 stack maximale grootte van de opgegeven in de header voor het uitvoerbare bestand te gebruiken.       Belangrijk voor gedeeltelijk vertrouwde code, `maxStackSize` wordt genegeerd als die groter dan de standaardgrootte van de stack is. Er is geen uitzondering is opgetreden."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>is kleiner dan nul."
  platform:
  - net462
- uid: System.Threading.Thread.Abort
  id: Abort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Genereert een <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> in de thread waarop deze wordt aangeroepen, om te beginnen met het proces van de thread wordt beëindigd. Deze methode aanroept, doorgaans beëindigt de thread."
  remarks: "Wanneer deze methode wordt aangeroepen op een thread, het systeem een <xref:System.Threading.ThreadAbortException>in de thread om af te breken deze</xref:System.Threading.ThreadAbortException> genereert `ThreadAbortException`is een speciale uitzondering die kan worden opgepikt door de toepassingscode, maar is opnieuw thrown aan het einde van de `catch` tenzij <xref:System.Threading.Thread.ResetAbort%2A>wordt aangeroepen.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`Hiermee annuleert u de aanvraag om af te breken, en voorkomt u dat de `ThreadAbortException` van de thread wordt beëindigd. Gemaakt `finally` blokken worden uitgevoerd voordat de thread is afgebroken.      > [!NOTE] > Wanneer wordt aangeroepen door een thread `Abort` op zichzelf, het effect is vergelijkbaar met een uitzondering opgetreden; de <xref:System.Threading.ThreadAbortException>gebeurt onmiddellijk en het resultaat is voorspelbaar.</xref:System.Threading.ThreadAbortException> Echter, als één thread aanroept `Abort` op een andere thread de afbreken interrupts ongeacht code wordt uitgevoerd. Er is een kans dat een statische constructor kan worden afgebroken. In zeldzame gevallen kan dit voorkomen dat instanties van die klasse in dat toepassingsdomein wordt gemaakt. In de .NET Framework-versies 1.0 en 1.1, er is een kans die de thread kan afbreken terwijl een `finally` blok wordt uitgevoerd, in welk geval de `finally` blok is afgebroken.       De thread om af te breken onmiddellijk of helemaal niet worden gegarandeerd. Deze situatie kan zich voordoen als een thread heeft een niet-gebonden bedrag van de berekening in de `finally` blokken die worden genoemd als onderdeel van de procedure afbreken, waardoor voor onbepaalde tijd vertragen de afbreken. Als u wilt wachten totdat een thread is afgebroken, roept u de <xref:System.Threading.Thread.Join%2A>methode in de thread na het aanroepen van de methode afbreken, maar er is geen garantie dat de wachttijd wordt beëindigd.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > De thread die afbreken aanroept kan tot gevolg hebben als de thread die is afgebroken in een beveiligde gebied van code, zoals een `catch` blok `finally` blokkeren of beperkte uitvoeringsregio wordt opgegeven. Als de thread die afbreken aanroept een vergrendeling waarvoor de afgebroken thread bevat, kan een impasse optreden.       Als `Abort` wordt aangeroepen voor een thread die niet is gestart, de thread wordt afgebroken wanneer <xref:System.Threading.Thread.Start%2A>wordt aangeroepen.</xref:System.Threading.Thread.Start%2A> Als `Abort` wordt aangeroepen op een thread die is geblokkeerd of in de slaapstand, de thread is onderbroken en vervolgens afgebroken.       Als `Abort` wordt aangeroepen voor een thread die is onderbroken, een <xref:System.Threading.ThreadStateException>gegenereerd in de thread die aangeroepen <xref:System.Threading.Thread.Abort%2A>, en <xref:System.Threading.ThreadState>wordt toegevoegd aan de <xref:System.Threading.Thread.ThreadState%2A>eigenschap van de thread is afgebroken.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> Een <xref:System.Threading.ThreadAbortException>niet gegenereerd in de onderbroken thread tot <xref:System.Threading.Thread.Resume%2A>wordt aangeroepen.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Als `Abort` is aangeroepen voor een beheerde thread, terwijl deze niet-beheerde code wordt uitgevoerd een `ThreadAbortException` totdat de thread weer in beheerde code niet gegenereerd.       Als twee naar aanroepen `Abort` afkomstig zijn op hetzelfde moment is het mogelijk dat één aanroep van de informatie over de status ingesteld en de andere aanroep voor het uitvoeren van de `Abort`. Een toepassing kan echter deze situatie niet detecteren.       Na `Abort` wordt aangeroepen op een thread bevat de status van de thread <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Nadat de thread is beëindigd als gevolg van een geslaagde aanroepen naar `Abort`, de status van de thread is gewijzigd in <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Met de juiste machtigingen, een thread die is het doel van een `Abort` kunt annuleren de afbreken met behulp van de `ResetAbort` methode. Voor een voorbeeld aanroepen de `ResetAbort` methode, Zie de `ThreadAbortException` klasse."
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De thread die is afgebroken is momenteel onderbroken."
  platform:
  - net462
- uid: System.Threading.Thread.Abort(System.Object)
  id: Abort(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Genereert een <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> in de thread waarop deze wordt aangeroepen, om te beginnen met het proces van de thread wordt afgesloten terwijl er ook uitzonderingsinformatie over de thread is beëindigd. Deze methode aanroept, doorgaans beëindigt de thread."
  remarks: "Wanneer deze methode wordt aangeroepen op een thread, het systeem een <xref:System.Threading.ThreadAbortException>in de thread om af te breken deze</xref:System.Threading.ThreadAbortException> genereert `ThreadAbortException`is een speciale uitzondering die kan worden opgepikt door de toepassingscode, maar is opnieuw thrown aan het einde van de `catch` tenzij <xref:System.Threading.Thread.ResetAbort%2A>wordt aangeroepen.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`Hiermee annuleert u de aanvraag om af te breken, en voorkomt u dat de `ThreadAbortException` van de thread wordt beëindigd. Gemaakt `finally` blokken worden uitgevoerd voordat de thread is afgebroken.      > [!NOTE] > Wanneer wordt aangeroepen door een thread `Abort` op zichzelf, het effect is vergelijkbaar met een uitzondering opgetreden; de <xref:System.Threading.ThreadAbortException>gebeurt onmiddellijk en het resultaat is voorspelbaar.</xref:System.Threading.ThreadAbortException> Echter, als één thread aanroept `Abort` op een andere thread de afbreken interrupts ongeacht code wordt uitgevoerd. Er is een kans dat een statische constructor kan worden afgebroken. In zeldzame gevallen kan dit voorkomen dat instanties van die klasse in dat toepassingsdomein wordt gemaakt. In de .NET Framework-versies 1.0 en 1.1, er is een kans die de thread kan afbreken terwijl een `finally` blok wordt uitgevoerd, in welk geval de `finally` blok is afgebroken.       De thread om af te breken onmiddellijk of helemaal niet worden gegarandeerd. Deze situatie kan zich voordoen als een thread heeft een niet-gebonden bedrag van de berekening in de `finally` blokken die worden genoemd als onderdeel van de procedure afbreken, waardoor voor onbepaalde tijd vertragen de afbreken. Als u wilt wachten totdat een thread is afgebroken, roept u de <xref:System.Threading.Thread.Join%2A>methode in de thread na het aanroepen van de methode afbreken, maar er is geen garantie dat de wachttijd wordt beëindigd.</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > De thread die aanroept <xref:System.Threading.Thread.Abort%2A>kan tot gevolg hebben als de thread die is afgebroken in een beveiligde gebied van code, zoals een `catch` blok `finally` blokkeren of beperkte uitvoeringsregio.</xref:System.Threading.Thread.Abort%2A> Als de thread die roept <xref:System.Threading.Thread.Abort%2A>vergrendeld die nodig zijn de afgebroken thread, kan zich voordoen een impasse.</xref:System.Threading.Thread.Abort%2A>       Als `Abort` wordt aangeroepen voor een thread die niet is gestart, de thread wordt afgebroken wanneer <xref:System.Threading.Thread.Start%2A>wordt aangeroepen.</xref:System.Threading.Thread.Start%2A> Als `Abort` wordt aangeroepen op een thread die is geblokkeerd of in de slaapstand, de thread is onderbroken en vervolgens afgebroken.       Als `Abort` wordt aangeroepen voor een thread die is onderbroken, een <xref:System.Threading.ThreadStateException>gegenereerd in de thread die aangeroepen <xref:System.Threading.Thread.Abort%2A>, en <xref:System.Threading.ThreadState>wordt toegevoegd aan de <xref:System.Threading.Thread.ThreadState%2A>eigenschap van de thread is afgebroken.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> Een <xref:System.Threading.ThreadAbortException>niet gegenereerd in de onderbroken thread tot <xref:System.Threading.Thread.Resume%2A>wordt aangeroepen.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Als `Abort` is aangeroepen voor een beheerde thread, terwijl deze niet-beheerde code wordt uitgevoerd een `ThreadAbortException` totdat de thread weer in beheerde code niet gegenereerd.       Als twee naar aanroepen `Abort` afkomstig zijn op hetzelfde moment is het mogelijk dat één aanroep van de informatie over de status ingesteld en de andere aanroep voor het uitvoeren van de `Abort`. Een toepassing kan echter deze situatie niet detecteren.       Na `Abort` wordt aangeroepen op een thread bevat de status van de thread <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Nadat de thread is beëindigd als gevolg van een geslaagde aanroepen naar `Abort`, de status van de thread is gewijzigd in <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Met de juiste machtigingen, een thread die is het doel van een `Abort` kunt annuleren de afbreken met behulp van de `ResetAbort` methode. Voor een voorbeeld aanroepen de `ResetAbort` methode, Zie de `ThreadAbortException` klasse."
  example:
  - "The following code example shows how to pass information to a thread that is being aborted.  \n  \n [!code-cs[System.Threading.Thread.Abort2#1](~/add/codesnippet/csharp/m-system.threading.threa_12_1.cs)]\n [!code-cpp[System.Threading.Thread.Abort2#1](~/add/codesnippet/cpp/m-system.threading.threa_12_1.cpp)]\n [!code-vb[System.Threading.Thread.Abort2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_12_1.vb)]"
  syntax:
    content: public void Abort (object stateInfo);
    parameters:
    - id: stateInfo
      type: System.Object
      description: "Een object met toepassingsspecifieke gegevens, zoals staat, die kan worden gebruikt door de thread is afgebroken."
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De thread die is afgebroken is momenteel onderbroken."
  platform:
  - net462
- uid: System.Threading.Thread.AllocateDataSlot
  id: AllocateDataSlot
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Er wordt een sleuf naamloze gegevens op alle threads. Gebruik voor betere prestaties velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>in plaats daarvan het kenmerk.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework biedt twee methoden voor het gebruik van lokale opslag van thread (TLS): thread-relatief statische velden (dat wil zeggen, de velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>kenmerk) en gegevens sleuven.</xref:System.ThreadStaticAttribute> Thread-relatief statische velden bieden veel betere prestaties dan gegevens sleuven en controle van het type van de compilatie inschakelen. Zie voor meer informatie over het gebruik van TLS [lokale opslag Thread: Thread-relatief statische velden en gegevens sleuven](~/add/includes/ajax-current-ext-md.md).       De sleuf is toegewezen aan alle threads.       Een mechanisme voor het geheugen van lokale archief threads gebruiken voor het opslaan van de thread-specifieke gegevens. De common language runtime wijst een matrix met meerdere sleuven data store aan elk proces, wanneer deze wordt gemaakt. De thread een gegevensgebied in het gegevensarchief kunt toewijzen, opslaan en ophalen van een waarde in de sleuf en vrije sleuf opnieuw kunnen worden gebruikt na het verstrijken van de thread. Er zijn gegevens sleuven uniek per thread. Er zijn geen andere thread (ook niet onderliggende thread), krijgt die gegevens."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_16_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_16_1.cpp)]  \n  \n **Second Example**  \n  \n The following code example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_16_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_16_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateDataSlot ();
    parameters: []
    return:
      type: System.LocalDataStoreSlot
      description: "Het toegewezen naam gegevens sleuf op alle threads."
  overload: System.Threading.Thread.AllocateDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  id: AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Er wordt een sleuf benoemde gegevens op alle threads. Gebruik voor betere prestaties velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>in plaats daarvan het kenmerk.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework biedt twee methoden voor het gebruik van lokale opslag van thread (TLS): thread-relatief statische velden (dat wil zeggen, de velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>kenmerk) en gegevens sleuven.</xref:System.ThreadStaticAttribute> Thread-relatief statische velden bieden veel betere prestaties dan gegevens sleuven en controle van het type van de compilatie inschakelen. Zie voor meer informatie over het gebruik van TLS [lokale opslag Thread: Thread-relatief statische velden en gegevens sleuven](~/add/includes/ajax-current-ext-md.md).       Een mechanisme voor het geheugen van lokale archief threads gebruiken voor het opslaan van de thread-specifieke gegevens. De common language runtime wijst een matrix met meerdere sleuven data store aan elk proces, wanneer deze wordt gemaakt. De thread een gegevensgebied in het gegevensarchief kunt toewijzen, opslaan en ophalen van een waarde in de sleuf en vrije sleuf opnieuw kunnen worden gebruikt na het verstrijken van de thread. Er zijn gegevens sleuven uniek per thread. Er zijn geen andere thread (ook niet onderliggende thread), krijgt die gegevens.       Het is niet nodig voor het gebruik van de methode AllocateNamedDataSlot zijn toegewezen voor het toewijzen van een site met de naam gegevens omdat de <xref:System.Threading.Thread.GetNamedDataSlot%2A>methode sleuf toewijst als al niet is toegewezen.</xref:System.Threading.Thread.GetNamedDataSlot%2A>      > [!NOTE] > Als de methode AllocateNamedDataSlot zijn toegewezen, wordt gebruikt, deze moet worden aangeroepen in de hoofdthread tijdens het opstarten, omdat er een uitzondering wordt als een site met de opgegeven naam is al toegewezen. Er is geen manier om te controleren of een site is al toegewezen.       Sleuven toegewezen met deze methode moeten worden vrijgegeven met <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</xref:System.Threading.Thread.FreeNamedDataSlot%2A>"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_7_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_7_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n> [!NOTE]\n>  The example code does not use the AllocateNamedDataSlot method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated. If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_7_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_7_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "De naam van het gegevensgebied worden toegewezen."
    return:
      type: System.LocalDataStoreSlot
      description: "Het toegewezen naam gegevens sleuf op alle threads."
  overload: System.Threading.Thread.AllocateNamedDataSlot*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Er bestaat al een sleuf benoemde gegevens met de opgegeven naam."
  platform:
  - net462
- uid: System.Threading.Thread.ApartmentState
  id: ApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Opgehaald of ingesteld van de apartmentstatus van deze thread."
  remarks: "**De eigenschap deze is verouderd.**  De niet-verouderde alternatieven zijn de <xref:System.Threading.Thread.GetApartmentState%2A>methode voor het ophalen van de apartmentstatus en de <xref:System.Threading.Thread.SetApartmentState%2A>methode om de apartmentstatus.</xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>       In de .NET Framework-versies 1.0 en 1.1, de `ApartmentState` een thread om aan te geven dat deze wordt uitgevoerd in een apartment met één thread of meerdere threads worden gemarkeerd. Deze eigenschap kan worden ingesteld als de thread zich in de `Unstarted` of `Running` thread staat, maar deze kan slechts eenmaal worden ingesteld voor een thread. Als de eigenschap niet is ingesteld, retourneert `Unknown`.       Een poging tot het gebruik van de eigenschap deze om de apartmentstatus van een thread waarvan apartmentstatus is al ingesteld. wordt genegeerd. Echter, de <xref:System.Threading.Thread.SetApartmentState%2A>methode er wordt een <xref:System.InvalidOperationException>in dit geval.</xref:System.InvalidOperationException> </xref:System.Threading.Thread.SetApartmentState%2A>      > [!IMPORTANT] > In de .NET Framework versie 2.0, nieuwe threads zijn geïnitialiseerd als <xref:System.Threading.ApartmentState?displayProperty=fullName>als hun apartmentstatus is niet ingesteld voordat ze worden gestart.</xref:System.Threading.ApartmentState?displayProperty=fullName> De thread hoofdtoepassing is geïnitialiseerd op <xref:System.Threading.ApartmentState?displayProperty=fullName>standaard.</xref:System.Threading.ApartmentState?displayProperty=fullName> U kunt de hoofdtoepassing-thread niet meer instellen op <xref:System.Threading.ApartmentState?displayProperty=fullName>door in te stellen de <xref:System.Threading.ApartmentState?displayProperty=fullName>-eigenschap op de eerste coderegel.</xref:System.Threading.ApartmentState?displayProperty=fullName> </xref:System.Threading.ApartmentState?displayProperty=fullName> Gebruik de <xref:System.STAThreadAttribute>in plaats daarvan.</xref:System.STAThreadAttribute>       In het .NET Framework versie 2.0, kunt u de COM-threadmodel voor een C++-toepassing met de [/CLRTHREADATTRIBUTE (ingesteld CLR Thread kenmerk)](~/add/includes/ajax-current-ext-md.md) linker-optie."
  example:
  - "The following code example demonstrates how to set the apartment state of a thread.  \n  \n [!code-cs[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/csharp/p-system.threading.threa_8_1.cs)]\n [!code-cpp[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/cpp/p-system.threading.threa_8_1.cpp)]\n [!code-vb[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_8_1.vb)]"
  syntax:
    content: public System.Threading.ApartmentState ApartmentState { get; set; }
    return:
      type: System.Threading.ApartmentState
      description: "Een van de <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> waarden. De beginwaarde is <xref uid=&quot;langword_csharp_Unknown&quot; name=&quot;Unknown&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Wordt geprobeerd deze eigenschap instellen op een status die niet een geldig apartmentstatus (een status moet hebben dan single thread apartment (<xref uid=&quot;langword_csharp_STA&quot; name=&quot;STA&quot; href=&quot;&quot;></xref>) of meerdere threads apartment (<xref uid=&quot;langword_csharp_MTA&quot; name=&quot;MTA&quot; href=&quot;&quot;></xref>))."
  platform:
  - net462
- uid: System.Threading.Thread.BeginCriticalRegion
  id: BeginCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Een host waarschuwt dat uitvoering wordt een gebied van code waarin de gevolgen van een thread afbreken of niet-verwerkte uitzondering in gevaar andere taken in het toepassingsdomein brengen kunnen invoeren."
  remarks: "Hosts van de common language runtime (CLR), zoals Microsoft SQL Server 2005 kunnen maken van verschillende beleidsregels voor storingen in kritieke en niet-kritieke gebieden van code. Een kritieke regio is een waarin de gevolgen van het afbreken van een thread of een niet-verwerkte uitzondering mogelijk niet beperkt tot de huidige taak. Daarentegen een afbreken of een storing in een niet-kritieke gebied van code is van invloed op alleen de taak waarin de fout zich voordoet.       Neem bijvoorbeeld een taak waarmee wordt geprobeerd geheugen toewijzen terwijl vergrendeld. Als de geheugentoewijzing is mislukt, wordt afgebroken, wordt de huidige taak is niet voldoende om te controleren of de stabiliteit van de <xref:System.AppDomain>, omdat er andere taken in het domein die wachten op de dezelfde vergrendeling.</xref:System.AppDomain> Als de huidige taak is beëindigd, kunnen een impasse andere taken.       Wanneer een fout in een kritieke regio optreedt, wordt de host besluiten verwijderen (Unload) van de gehele <xref:System.AppDomain>plaats van het risico van de uitvoering wordt voortgezet mogelijk instabiel.</xref:System.AppDomain> Om te informeren over de host uw code invoeren van een kritieke regio, BeginCriticalRegion-aanroep. Roep <xref:System.Threading.Thread.EndCriticalRegion%2A>wanneer uitvoering in een niet-kritieke regio code retourneert.</xref:System.Threading.Thread.EndCriticalRegion%2A>       Met deze methode in de code die compatibel is met SQL Server 2005, moet de code moet worden uitgevoerd op het hoogste niveau van de host-bescherming."
  example:
  - "The following example demonstrates the use of the BeginCriticalRegion and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_5_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_5_1.vb)]"
  syntax:
    content: public static void BeginCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.BeginCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.BeginThreadAffinity
  id: BeginThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Het bericht een host die code beheerde wilt instructies die afhankelijk van de identiteit van de huidige thread van de fysieke besturingssysteem zijn uitvoert."
  remarks: "Sommige hosts van de common language runtime, zoals Microsoft SQL Server 2005, bieden hun eigen management thread. Een host die voorziet in een eigen threadbeheer kunt verplaatsen uitvoeren van de taak van de ene fysieke besturingssysteemthread naar een andere op elk gewenst moment. De meeste taken worden niet beïnvloed door deze overschakelen. Evenwel sommige taken hebben thread-affiniteit - dat wil zeggen, ze afhankelijk van de identiteit van een fysieke besturingssysteem-thread. Deze taken moeten de host informeren wanneer ze code uitvoeren die niet moet worden ingeschakeld.       Bijvoorbeeld, als uw toepassing een API te vergrendelen voor een besturingssysteem met thread-affiniteit, zoals een CRITICAL_SECTION Win32-systeem moet worden aangeroepen BeginThreadAffinity voordat de vergrendeling verkrijgen en <xref:System.Threading.Thread.EndThreadAffinity%2A>nadat de vergrendeling.</xref:System.Threading.Thread.EndThreadAffinity%2A>       Met deze methode in de code die compatibel is met SQL Server 2005, moet de code moet worden uitgevoerd op het hoogste niveau van de host-bescherming."
  example:
  - "The following example demonstrates the use of the BeginThreadAffinity and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_0_1.vb)]"
  syntax:
    content: public static void BeginThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.BeginThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentContext
  id: CurrentContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee haalt u de huidige context waarin de thread wordt uitgevoerd."
  syntax:
    content: public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }
    return:
      type: System.Runtime.Remoting.Contexts.Context
      description: "Een <xref href=&quot;System.Runtime.Remoting.Contexts.Context&quot;> </xref> voor de huidige thread-context."
  overload: System.Threading.Thread.CurrentContext*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentCulture
  id: CurrentCulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Opgehaald of ingesteld van de cultuur voor de huidige thread."
  remarks: "De <xref:System.Globalization.CultureInfo>-object dat wordt geretourneerd door deze eigenschap, samen met de bijbehorende objecten bepalen de standaardnotatie voor datums, tijden, getallen, valuta&quot;s, de sorteervolgorde van tekst, hoofdlettergebruik van overeenkomsten en tekenreeksvergelijkingen.</xref:System.Globalization.CultureInfo> Zie de <xref:System.Globalization.CultureInfo>klasse voor meer informatie over de cultuurnamen van de en id&quot;s, de verschillen tussen invariante neutrale en specifieke culturen en de manier waarop gegevens voor cultuur is van invloed op threads en toepassingsdomeinen.</xref:System.Globalization.CultureInfo> Zie de <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>eigenschap om te leren hoe de standaardcultuur op een thread is bepaald en hoe de gegevens van de cultuur voor hun computers voor het instellen van gebruikers.</xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>       Vanaf de [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], u kunt de eigenschap CurrentCulture instellen op een neutrale cultuur. Dit komt doordat het gedrag van de <xref:System.Globalization.CultureInfo>klasse is gewijzigd: wanneer deze een neutrale cultuur, de eigenschapswaarden vertegenwoordigt (met name de <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, en <xref:System.Globalization.CultureInfo.TextInfo%2A>Eigenschappen) nu weerspiegelen de specifieke cultuur die is gekoppeld aan de neutrale cultuur.</xref:System.Globalization.CultureInfo.TextInfo%2A> </xref:System.Globalization.CultureInfo.NumberFormat%2A> </xref:System.Globalization.CultureInfo.DateTimeFormat%2A> </xref:System.Globalization.CultureInfo.CompareInfo%2A> </xref:System.Globalization.CultureInfo.Calendar%2A> </xref:System.Globalization.CultureInfo> In eerdere versies van .NET Framework, de eigenschap CurrentCulture heeft een <xref:System.NotSupportedException>uitzondering wanneer een neutrale cultuur is toegewezen.</xref:System.NotSupportedException>"
  example:
  - "The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_3_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentCulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Een object dat staat voor de cultuur voor de huidige thread."
  overload: System.Threading.Thread.CurrentCulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "De eigenschap is ingesteld op <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentPrincipal
  id: CurrentPrincipal
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Opgehaald of ingesteld van de thread huidige principal (voor op rollen gebaseerde beveiliging)."
  remarks: ''
  example:
  - "The following code example shows how to set and retrieve the principal of a thread.  \n  \n [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/cpp/p-system.threading.threa_11_1.cpp)]\n [!code-cs[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/csharp/p-system.threading.threa_11_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/visualbasic/p-system.threading.threa_11_1.vb)]"
  syntax:
    content: public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }
    return:
      type: System.Security.Principal.IPrincipal
      description: "Een <xref:System.Security.Principal.IPrincipal>-waarde voor de beveiligingscontext.</xref:System.Security.Principal.IPrincipal>"
  overload: System.Threading.Thread.CurrentPrincipal*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper is niet gemachtigd de vereist voor het instellen van de principal."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentThread
  id: CurrentThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee haalt u de thread die momenteel worden uitgevoerd."
  remarks: ''
  example:
  - "The following example creates a task that in turn creates 20 child tasks. The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the CurrentThread property  to display information about the thread on which it is running.  \n  \n [!code-vb[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_1_1.vb)]\n [!code-cs[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/csharp/p-system.threading.threa_1_1.cs)]  \n  \n Each child task generates 1 million random numbers between 1 and 1 million and returns their mean. The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.  \n  \n Note that while the application runs on a foreground thread, each task runs on a thread pool thread."
  syntax:
    content: public static System.Threading.Thread CurrentThread { get; }
    return:
      type: System.Threading.Thread
      description: "Een <xref href=&quot;System.Threading.Thread&quot;> </xref> dat de weergave van de thread die momenteel worden uitgevoerd."
  overload: System.Threading.Thread.CurrentThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.CurrentUICulture
  id: CurrentUICulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Opgehaald of ingesteld van de huidige cultuur door Resource Manager gebruikt om te zoeken cultuur-specifieke bronnen tijdens runtime."
  remarks: "The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture. See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains. See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property to learn how a thread's default UI culture is determined.  \n  \n The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture. Neutral cultures should not be used with formatting methods such as [String.Format(IFormatProvider, String, Object\\[\\])](assetId:///M:System.String.Format(System.IFormatProvider,System.String,System.Object[])?qualifyHint=True&autoUpgrade=False), <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=fullName>. Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.  \n  \n> [!NOTE]\n>  The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method throws <xref:System.ArgumentException> for the neutral cultures \"zh-Hant\" (\"zh-CHT\") and \"zh-Hans\" (\"zh-CHS\")."
  example:
  - "The following example determines whether the language of the current thread's UI culture is French. If it is not, it sets the UI culture of the current thread to English (United States).  \n  \n [!code-cs[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_1.vb)]  \n  \n The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_2_2.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_2.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_2.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentUICulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Een object dat de huidige cultuur vertegenwoordigt."
  overload: System.Threading.Thread.CurrentUICulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "De eigenschap is ingesteld op <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De eigenschap is ingesteld op een cultuurnaam die niet kan worden gebruikt om een resource-bestand te zoeken. Bronbestandsnamen moet alleen letters, cijfers, streepjes of onderstrepingstekens bevatten."
  platform:
  - net462
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  id: DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  langs:
  - csharp
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schakelt automatisch opschonen van de runtime callable-wrappers (RCW) voor de huidige thread."
  remarks: "Standaard ruimt de common language runtime (CLR) runtime callable-wrappers automatisch. De CLR pompen berichten tijdens het opruimen, wat kan leiden tot problemen voor enkele toepassingen die voldoen aan de volgende ongebruikelijke herintreding:-de toepassing heeft een eigen bericht pompen.      -De toepassing moet bepaalt nauwkeurig wanneer bericht pompen optreedt.       Dergelijke toepassingen kunnen gebruikmaken van de methode DisableComObjectEagerCleanup om te voorkomen dat de CLR automatische vrijmaken van runtime callable-wrappers doen.       Wanneer deze methode is aangeroepen voor een thread, is automatische opschoning kan niet opnieuw worden ingeschakeld voor die thread. Gebruiken wanneer uw toepassing is gereed om op te schonen runtime callable-wrappers de <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName>methode instrueren de runtime om op te schonen alle runtime aanroepbare wrappers in de huidige context.</xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName> Bericht pompen treedt op wanneer de methode wordt uitgevoerd."
  syntax:
    content: public void DisableComObjectEagerCleanup ();
    parameters: []
  overload: System.Threading.Thread.DisableComObjectEagerCleanup*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndCriticalRegion
  id: EndCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Het bericht een host dat kan worden uitgevoerd over naar een gebied van code waarin de gevolgen van een thread afbreken of niet-verwerkte uitzondering beperkt tot de huidige taak zijn invoeren."
  remarks: "Hosts van de common language runtime (CLR), zoals Microsoft SQL Server 2005 kunnen maken van verschillende beleidsregels voor storingen in kritieke en niet-kritieke gebieden van code. Een kritieke regio is een waarin de gevolgen van het afbreken van een thread of een niet-verwerkte uitzondering mogelijk niet beperkt tot de huidige taak. Daarentegen een afbreken of een storing in een niet-kritieke gebied van code is van invloed op alleen de taak waarin de fout zich voordoet.       Neem bijvoorbeeld een taak waarmee wordt geprobeerd geheugen toewijzen terwijl vergrendeld. Als de geheugentoewijzing is mislukt, wordt afgebroken, wordt de huidige taak is niet voldoende om te controleren of de stabiliteit van de <xref:System.AppDomain>, omdat er andere taken in het domein die wachten op de dezelfde vergrendeling.</xref:System.AppDomain> Als de huidige taak is beëindigd, kunnen een impasse andere taken.       Wanneer een fout in een kritieke regio optreedt, wordt de host besluiten verwijderen (Unload) van de gehele <xref:System.AppDomain>plaats van het risico van de uitvoering wordt voortgezet mogelijk instabiel.</xref:System.AppDomain> Om te informeren over de host uw code invoeren van een kritieke regio, roepen <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</xref:System.Threading.Thread.BeginCriticalRegion%2A> EndCriticalRegion aanroepen wanneer een niet-kritieke gebied van code kan worden uitgevoerd weer.       Met deze methode in de code die compatibel is met SQL Server 2005, moet de code moet worden uitgevoerd op het hoogste niveau van de host-bescherming."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and EndCriticalRegion methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_1_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_1_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_1_1.vb)]"
  syntax:
    content: public static void EndCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.EndCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndThreadAffinity
  id: EndThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Waarschuwt de instructies die afhankelijk van de identiteit van de huidige thread van de fysieke besturingssysteem zijn uitvoering van een host die code beheerde is voltooid."
  remarks: "Sommige hosts van de common language runtime, zoals Microsoft SQL Server 2005, bieden hun eigen management thread. Een host die voorziet in een eigen threadbeheer kunt verplaatsen uitvoeren van de taak van de ene fysieke besturingssysteemthread naar een andere op elk gewenst moment. De meeste taken worden niet beïnvloed door deze overschakelen. Evenwel sommige taken hebben thread-affiniteit - dat wil zeggen, ze afhankelijk van de identiteit van een fysieke besturingssysteem-thread. Deze taken moeten de host informeren wanneer ze code uitvoeren die niet moet worden ingeschakeld.       Bijvoorbeeld, als uw toepassing met aanroepen van een systeem-API te verkrijgen van een besturingssysteem vergrendelen met thread-affiniteit, zoals een CRITICAL_SECTION Win32 moet worden aangeroepen <xref:System.Threading.Thread.BeginThreadAffinity%2A>voordat het ophalen van de vergrendeling en EndThreadAffinity nadat de vergrendeling.</xref:System.Threading.Thread.BeginThreadAffinity%2A>       Met deze methode in de code die compatibel is met SQL Server 2005, moet de code moet worden uitgevoerd op het hoogste niveau van de host-bescherming."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and EndThreadAffinity methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_3_1.vb)]"
  syntax:
    content: public static void EndThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.EndThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste machtiging."
  platform:
  - net462
- uid: System.Threading.Thread.ExecutionContext
  id: ExecutionContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Haalt een <xref:System.Threading.ExecutionContext>-object dat informatie over de verschillende contexten van de huidige thread bevat.</xref:System.Threading.ExecutionContext>"
  remarks: "De <xref:System.Threading.ExecutionContext>klasse biedt een enkele container voor alle relevante informatie voor een logische thread van de uitvoering van.</xref:System.Threading.ExecutionContext> Dit omvat beveiligingscontext, context van de oproep synchronisatiecontext, lokalisatie context en transactiecontext."
  syntax:
    content: public System.Threading.ExecutionContext ExecutionContext { get; }
    return:
      type: System.Threading.ExecutionContext
      description: "Een <xref:System.Threading.ExecutionContext>-object dat contextinformatie voor de huidige thread consolideert.</xref:System.Threading.ExecutionContext>"
  overload: System.Threading.Thread.ExecutionContext*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Finalize
  id: Finalize
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Zorgt ervoor dat resources zijn vrijgegeven en andere opschonen-bewerkingen worden uitgevoerd wanneer de garbage collector indexrijen de <xref href=&quot;System.Threading.Thread&quot;> </xref> object."
  remarks: "De garbage collector roept Finalize als het huidige object is gereed om te worden voltooid."
  syntax:
    content: ~Thread ();
    parameters: []
  overload: System.Threading.Thread.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  id: FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Voorkomen dat u de koppeling tussen een naam en een site, voor alle threads in het proces. Gebruik voor betere prestaties velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>in plaats daarvan het kenmerk.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework biedt twee methoden voor het gebruik van lokale opslag van thread (TLS): thread-relatief statische velden (dat wil zeggen, de velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>kenmerk) en gegevens sleuven.</xref:System.ThreadStaticAttribute> Thread-relatief statische velden bieden veel betere prestaties dan gegevens sleuven en controle van het type van de compilatie inschakelen. Zie voor meer informatie over het gebruik van TLS [lokale opslag Thread: Thread-relatief statische velden en gegevens sleuven](~/add/includes/ajax-current-ext-md.md).       Nadat een thread-aanroepen `FreeNamedDataSlot`, andere thread die aanroept <xref:System.Threading.Thread.GetNamedDataSlot%2A>met dezelfde naam wordt een nieuwe sleuf die zijn gekoppeld aan de naam toewijzen.</xref:System.Threading.Thread.GetNamedDataSlot%2A> Volgende aanroepen naar `GetNamedDataSlot` door elke thread de nieuwe site wordt geretourneerd. Een willekeurige thread die nog steeds heeft echter een <xref:System.LocalDataStoreSlot?displayProperty=fullName>geretourneerd door een eerdere aanroep `GetNamedDataSlot` kunt blijven gebruiken van de oude sleuf.</xref:System.LocalDataStoreSlot?displayProperty=fullName>       Een site die gekoppeld aan een naam is die is uitgebracht alleen wanneer elke `LocalDataStoreSlot` die is verkregen voordat de aanroep van `FreeNamedDataSlot` zijn vrijgegeven en die door de garbage collector zijn verzameld.       Een mechanisme voor het geheugen van lokale archief threads gebruiken voor het opslaan van de thread-specifieke gegevens. De common language runtime wijst een matrix met meerdere sleuven data store aan elk proces, wanneer deze wordt gemaakt. De thread een gegevensgebied in het gegevensarchief kunt toewijzen, opslaan en ophalen van een waarde in de sleuf en vrije sleuf opnieuw kunnen worden gebruikt na het verstrijken van de thread. Er zijn gegevens sleuven uniek per thread. Er zijn geen andere thread (ook niet onderliggende thread), krijgt die gegevens."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_9_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_9_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_9_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_9_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_2.vb)]"
  syntax:
    content: public static void FreeNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de sleuf gegevens om te worden vrijgemaakt."
  overload: System.Threading.Thread.FreeNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetApartmentState
  id: GetApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retourneert een <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> waarde die aangeeft van de apartmentstatus."
  remarks: "Deze methode, samen met de <xref:System.Threading.Thread.SetApartmentState%2A>methode en de <xref:System.Threading.Thread.TrySetApartmentState%2A>methode, vervangt de <xref:System.Threading.Thread.ApartmentState%2A>eigenschap.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A>"
  example:
  - "The following code example demonstrates the GetApartmentState, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, GetApartmentState displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_11_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_11_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_11_1.cs)]"
  syntax:
    content: public System.Threading.ApartmentState GetApartmentState ();
    parameters: []
    return:
      type: System.Threading.ApartmentState
      description: "Een van de <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> waarden de apartment-status van de beheerde thread. De standaardwaarde is <xref href=&quot;System.Threading.ApartmentState&quot;> </xref>."
  overload: System.Threading.Thread.GetApartmentState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetCompressedStack
  id: GetCompressedStack
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retourneert een <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> -object dat kan worden gebruikt om vast te leggen van de stack voor de huidige thread."
  remarks: "Deze methode wordt niet langer ondersteund."
  syntax:
    content: public System.Threading.CompressedStack GetCompressedStack ();
    parameters: []
    return:
      type: System.Threading.CompressedStack
      description: "Geen."
  overload: System.Threading.Thread.GetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "In alle gevallen."
  platform:
  - net462
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  id: GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Haalt de waarde van de opgegeven sleuf in de huidige thread, binnen het huidige domein van de huidige thread. Gebruik voor betere prestaties velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>in plaats daarvan het kenmerk.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework biedt twee methoden voor het gebruik van lokale opslag van thread (TLS): thread-relatief statische velden (dat wil zeggen, de velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>kenmerk) en gegevens sleuven.</xref:System.ThreadStaticAttribute> Thread-relatief statische velden bieden veel betere prestaties dan gegevens sleuven en controle van het type van de compilatie inschakelen. Zie voor meer informatie over het gebruik van TLS [lokale opslag Thread: Thread-relatief statische velden en gegevens sleuven](~/add/includes/ajax-current-ext-md.md).       Een mechanisme voor het geheugen van lokale archief threads gebruiken voor het opslaan van de thread-specifieke gegevens. De common language runtime wijst een matrix met meerdere sleuven data store aan elk proces, wanneer deze wordt gemaakt. De thread een gegevensgebied in het gegevensarchief kunt toewijzen, opslaan en ophalen van een waarde in de sleuf en vrije sleuf opnieuw kunnen worden gebruikt na het verstrijken van de thread. Er zijn gegevens sleuven uniek per thread. Er zijn geen andere thread (ook niet onderliggende thread), krijgt die gegevens.      > [!NOTE] > GetData is een `Shared` methode die altijd van toepassing op de momenteel uitgevoerde thread, zelfs als u deze met een variabele die naar een andere thread verwijst aanroepen. Om verwarring te voorkomen, gebruikt u de naam van de klasse bij het aanroepen van `Shared` methoden: `Dim test As Object = Thread.GetData(testSlot)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_27_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_27_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_27_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_27_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_2.vb)]"
  syntax:
    content: public static object GetData (LocalDataStoreSlot slot);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "De <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> waaruit de waarde niet verkrijgen."
    return:
      type: System.Object
      description: "De opgehaalde waarde."
  overload: System.Threading.Thread.GetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomain
  id: GetDomain
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retourneert het huidige domein waarin de huidige thread wordt uitgevoerd."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_29_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_29_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_29_1.cpp)]"
  syntax:
    content: public static AppDomain GetDomain ();
    parameters: []
    return:
      type: System.AppDomain
      description: "Een <xref href=&quot;System.AppDomain&quot;> </xref> voor het huidige toepassingsdomein van de actieve thread."
  overload: System.Threading.Thread.GetDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomainID
  id: GetDomainID
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retourneert de domein-id van een unieke toepassingsnaam in."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_17_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_17_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_17_1.cpp)]"
  syntax:
    content: public static int GetDomainID ();
    parameters: []
    return:
      type: System.Int32
      description: "Een 32-bits geheel getal met teken een unieke id van het toepassingsdomein."
  overload: System.Threading.Thread.GetDomainID*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetHashCode
  id: GetHashCode
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Retourneert een hashcode voor de huidige thread."
  remarks: "De hash-code kan niet worden gegarandeerd uniek zijn. Gebruik de <xref:System.Threading.Thread.ManagedThreadId%2A>eigenschap als u een unieke id voor een beheerde thread moet.</xref:System.Threading.Thread.ManagedThreadId%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Een integer-waarde voor hash-code."
  overload: System.Threading.Thread.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  id: GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee zoekt u een benoemde gegevensgebied. Gebruik voor betere prestaties velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>in plaats daarvan het kenmerk.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework biedt twee methoden voor het gebruik van lokale opslag van thread (TLS): thread-relatief statische velden (dat wil zeggen, de velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>kenmerk) en gegevens sleuven.</xref:System.ThreadStaticAttribute> Thread-relatief statische velden bieden veel betere prestaties dan gegevens sleuven en controle van het type van de compilatie inschakelen. Zie voor meer informatie over het gebruik van TLS [lokale opslag Thread: Thread-relatief statische velden en gegevens sleuven](~/add/includes/ajax-current-ext-md.md).       Een mechanisme voor het geheugen van lokale archief threads gebruiken voor het opslaan van de thread-specifieke gegevens. De common language runtime wijst een matrix met meerdere sleuven data store aan elk proces, wanneer deze wordt gemaakt. De thread een gegevensgebied in het gegevensarchief kunt toewijzen, opslaan en ophalen van een waarde in de sleuf en vrije sleuf opnieuw kunnen worden gebruikt na het verstrijken van de thread. Er zijn gegevens sleuven uniek per thread. Er zijn geen andere thread (ook niet onderliggende thread), krijgt die gegevens.       Als de benoemde sleuf niet bestaat, wordt een nieuwe sleuf is toegewezen. Benoemde gegevens sleuven zijn openbaar en door iedereen kunnen worden bewerkt."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_13_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_13_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_13_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_13_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot GetNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de lokale gegevens sleuf."
    return:
      type: System.LocalDataStoreSlot
      description: "Een <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> toegewezen voor deze thread."
  overload: System.Threading.Thread.GetNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Interrupt
  id: Interrupt
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Onderbroken door een thread die zich in de <xref uid=&quot;langword_csharp_WaitSleepJoin&quot; name=&quot;WaitSleepJoin&quot; href=&quot;&quot;> </xref> thread staat."
  remarks: "Als deze thread is niet in een wacht, de slaapstand of de koppelingsstatus geblokkeerd, wordt onderbroken wanneer deze vervolgens begint te blokkeren.       <xref:System.Threading.ThreadInterruptedException>wordt gegenereerd in de onderbroken thread, maar niet tot de thread-blokken.</xref:System.Threading.ThreadInterruptedException> Als de thread nooit blokkeert, nooit door de uitzondering is opgetreden en dus de thread mogelijk voltooid zonder ooit onderbroken."
  example:
  - "The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.  \n  \n [!code-cpp[System.Threading.Thread.Interrupt#1](~/add/codesnippet/cpp/m-system.threading.threa_21_1.cpp)]\n [!code-vb[System.Threading.Thread.Interrupt#1](~/add/codesnippet/visualbasic/m-system.threading.threa_21_1.vb)]\n [!code-cs[System.Threading.Thread.Interrupt#1](~/add/codesnippet/csharp/m-system.threading.threa_21_1.cs)]"
  syntax:
    content: public void Interrupt ();
    parameters: []
  overload: System.Threading.Thread.Interrupt*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper beschikt niet over de juiste <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.IsAlive
  id: IsAlive
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee wordt een waarde die de uitvoeringsstatus van de huidige thread."
  syntax:
    content: public bool IsAlive { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als deze thread is gestart en niet is normaal beëindigd of afgebroken; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsAlive*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.IsBackground
  id: IsBackground
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Opgehaald of ingesteld van een waarde die aangeeft of een thread een achtergrond-thread is."
  remarks: "Een thread is een achtergrond-thread of een achtergrond-thread. Threads op de achtergrond zijn identiek aan de voorgrond threads, behalve dat threads op de achtergrond niet voorkomen een proces wordt beëindigd dat kunnen. Zodra alle voorgrond threads die horen bij een proces beëindigd, wordt in de common language runtime het proces beëindigd. Alle resterende threads op de achtergrond worden gestopt en niet worden voltooid.       Standaard worden de volgende threads uitvoeren op de voorgrond (dat wil zeggen, de eigenschap IsBackground `false`):-de primaire thread (of de hoofdtoepassingsthread).      -Alle threads gemaakt door het aanroepen van een <xref:System.Threading.Thread>klassen-constructor.</xref:System.Threading.Thread>       Standaard worden de volgende threads uitvoeren op de achtergrond (dat wil zeggen, de eigenschap IsBackground `true`):-Thread-pool-threads die een groep beheerd door de runtime werkthreads zijn. U kunt het thread-pool en planning werk op thread groepsthreads configureren met behulp van de <xref:System.Threading.ThreadPool>klasse.</xref:System.Threading.ThreadPool>          > [!NOTE] > Taakgebaseerde asynchrone bewerkingen automatisch worden uitgevoerd op thread groepsthreads.      -Alle threads de beheerde uitvoeringsomgeving van die niet-beheerde code."
  example:
  - "The following example contrasts the behavior of foreground and background threads. It creates a foreground thread and a background thread. The foreground thread keeps the process running until completes its `for` loop and terminates. However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.  \n  \n [!code-cs[System.Threading.Thread.IsBackground#1](~/add/codesnippet/csharp/p-system.threading.threa_7_1.cs)]\n [!code-cpp[System.Threading.Thread.IsBackground#1](~/add/codesnippet/cpp/p-system.threading.threa_7_1.cpp)]\n [!code-vb[System.Threading.Thread.IsBackground#1](~/add/codesnippet/visualbasic/p-system.threading.threa_7_1.vb)]"
  syntax:
    content: public bool IsBackground { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als deze thread of om te worden van een achtergrondthread. anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsBackground*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De thread is inactief."
  platform:
  - net462
- uid: System.Threading.Thread.IsThreadPoolThread
  id: IsThreadPoolThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Haalt een waarde die aangeeft of er een thread tot de beheerde thread-groep behoort."
  remarks: "Zie voor meer informatie [de beheerde Thread-groep](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to determine whether a thread is from the thread pool.  \n  \n [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/cpp/p-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/csharp/p-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_0_1.vb)]"
  syntax:
    content: public bool IsThreadPoolThread { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als deze thread tot de beheerde thread-groep behoort; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsThreadPoolThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Join
  id: Join
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "De aanroepende thread blokkeert totdat de thread die wordt vertegenwoordigd door dit exemplaar wordt beëindigd, maar blijft standaard COM uitvoeren en <xref uid=&quot;langword_csharp_SendMessage&quot; name=&quot;SendMessage&quot; href=&quot;&quot;> </xref> pompen."
  remarks: "Join is een synchronisatiemethode waarmee de aanroepende thread (de thread die de methode aanroept) wordt geblokkeerd tot de thread waarvan Join methode wordt aangeroepen is voltooid. Gebruik deze methode om ervoor te zorgen dat een thread is beëindigd. De aanroeper wordt voor onbepaalde tijd geblokkeerd als de thread niet beëindigd. In het volgende voorbeeld wordt de `Thread1` thread roept de Join-methode van `Thread2`, waardoor `Thread1` te blokkeren totdat `Thread2` is voltooid.       [!code-cs[System.Threading.Thread.Join#1](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)][!code-vb[System.Threading.Thread.Join#1](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb) ] als de thread is al beëindigd wanneer <xref:System.Threading.Thread.Join%2A>wordt aangeroepen, wordt de methode retourneert onmiddellijk.</xref:System.Threading.Thread.Join%2A>        > [!WARNING] > Moet u de Join-methode van nooit aanroepen de <xref:System.Threading.Thread>-object met de huidige thread van de huidige thread.</xref:System.Threading.Thread> Dit zorgt ervoor dat uw app vastlopen omdat de huidige thread zichzelf voor onbepaalde tijd, deze methode wijzigt wacht de status van de aanroepende thread <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> opnemen Kan niet worden aangeroepen `Join` voor een thread die zich in de <xref:System.Threading.ThreadState?displayProperty=fullName>staat.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public void Join ();
    parameters: []
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De aanroeper heeft geprobeerd om toe te voegen, een thread die zich in de <xref href=&quot;System.Threading.ThreadState&quot;> </xref> status."
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "De thread is onderbroken tijdens het wachten."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.Int32)
  id: Join(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Blokkeert de aanroepende thread totdat de thread die wordt vertegenwoordigd door dit exemplaar wordt beëindigd of de opgegeven tijd is verstreken, maar blijft standaard COM en SendMessage pompen uit te voeren."
  remarks: "Join is een synchronisatiemethode waarmee de aanroepende thread (de thread die de methode aanroept) tot en met ofwel de thread wordt geblokkeerd waarvan <xref:System.Threading.Thread.Join%2A>methode wordt aangeroepen is voltooid of het time-outinterval is verstreken.</xref:System.Threading.Thread.Join%2A> In het volgende voorbeeld wordt de `Thread1` aanroepen thread de <xref:System.Threading.Thread.Join>methode van `Thread2`, waardoor `Thread1` blokkeren ofwel tot `Thread2` is voltooid of 2 seconden zijn verstreken.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#2](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)][!code-vb[System.Threading.Thread.Join#2](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb) ] als <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>is opgegeven voor de `millisecondsTimeout` parameter, deze methode werkt identiek aan de <xref:System.Threading.Thread.Join>overbelasting voor methode, behalve de retourwaarde.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Als de thread is al beëindigd wanneer <xref:System.Threading.Thread.Join%2A>wordt aangeroepen, wordt de methode retourneert onmiddellijk.</xref:System.Threading.Thread.Join%2A>       Deze methode wijzigt de status van de aanroepende thread <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> opnemen Kan niet worden aangeroepen `Join` voor een thread die zich in de <xref:System.Threading.ThreadState?displayProperty=fullName>staat.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public bool Join (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Het aantal milliseconden wachttijd voor de thread is beëindigd."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de thread is beëindigd. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> als de thread niet is beëindigd na de hoeveelheid tijd die is opgegeven door de <code> millisecondsTimeout </code> parameter is verstreken."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De waarde van <code> millisecondsTimeout </code> negatief is en is niet gelijk aan &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; in milliseconden."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De thread is niet gestart."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.TimeSpan)
  id: Join(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Blokkeert de aanroepende thread totdat de thread die wordt vertegenwoordigd door dit exemplaar wordt beëindigd of de opgegeven tijd is verstreken, maar blijft standaard COM en SendMessage pompen uit te voeren."
  remarks: "Join is een synchronisatiemethode waarmee de aanroepende thread (de thread die de methode aanroept) tot en met ofwel de thread wordt geblokkeerd waarvan <xref:System.Threading.Thread.Join%2A>methode wordt aangeroepen is voltooid of het time-outinterval is verstreken.</xref:System.Threading.Thread.Join%2A> In het volgende voorbeeld wordt de `Thread1` aanroepen thread de <xref:System.Threading.Thread.Join>methode van `Thread2`, waardoor `Thread1` blokkeren ofwel tot `Thread2` is voltooid of 2 seconden zijn verstreken.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#3](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)][!code-vb[System.Threading.Thread.Join#3](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb) ] als <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>is opgegeven voor `timeout`, deze methode werkt identiek aan de <xref:System.Threading.Thread.Join>overbelasting voor methode, behalve de retourwaarde.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Als de thread is al beëindigd wanneer <xref:System.Threading.Thread.Join%2A>wordt aangeroepen, wordt de methode retourneert onmiddellijk.</xref:System.Threading.Thread.Join%2A>       Deze methode wijzigt de status van de huidige thread <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> opnemen Kan niet worden aangeroepen `Join` voor een thread die zich in de <xref:System.Threading.ThreadState?displayProperty=fullName>staat.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.  \n  \n [!code-cpp[System.Threading.Thread.Timespan#1](~/add/codesnippet/cpp/m-system.threading.threa_28_2.cpp)]\n [!code-cs[System.Threading.Thread.Timespan#1](~/add/codesnippet/csharp/m-system.threading.threa_28_2.cs)]\n [!code-vb[System.Threading.Thread.Timespan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_28_2.vb)]"
  syntax:
    content: public bool Join (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Een <xref:System.TimeSpan>ingesteld op de hoeveelheid tijd om te wachten op de thread is beëindigd.</xref:System.TimeSpan>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de thread is beëindigd. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> als de thread niet is beëindigd na de hoeveelheid tijd die is opgegeven door de <code> timeout </code> parameter is verstreken."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De waarde van <code> timeout </code> negatief is en is niet gelijk aan &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; in milliseconden, of is groter dan &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; milliseconden."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De aanroeper heeft geprobeerd om toe te voegen, een thread die zich in de <xref href=&quot;System.Threading.ThreadState&quot;> </xref> status."
  platform:
  - net462
- uid: System.Threading.Thread.ManagedThreadId
  id: ManagedThreadId
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee wordt een unieke id voor de huidige beheerde thread."
  remarks: "Een thread ManagedThreadId eigenschapswaarde fungeert als unieke identificatie die thread binnen het proces.       De waarde van de eigenschap ManagedThreadId komt niet variëren gedurende een periode, zelfs als niet-beheerde code die als host fungeert voor de common language runtime de thread als een fiber implementeert."
  syntax:
    content: public int ManagedThreadId { get; }
    return:
      type: System.Int32
      description: "Een geheel getal dat staat voor een unieke id voor deze beheerde thread."
  overload: System.Threading.Thread.ManagedThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.MemoryBarrier
  id: MemoryBarrier
  parent: System.Threading.Thread
  langs:
  - csharp
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: 'Synchroniseert geheugentoegang als volgt: de processor voor uitvoeren van de huidige thread kan niet de instructies in deze volgorde een manier die geheugen toegang heeft tot vóór de aanroep van MemoryBarrier uitvoeren nadat de toegang tot een geheugen die de aanroep van MemoryBarrier volgen.'
  remarks: "MemoryBarrier is alleen vereist op systemen met meerdere processors met zwakke geheugen ordenen (bijvoorbeeld een systeem die gebruikmaakt van meerdere Intel Itanium-processors).       Voor de meeste doeleinden C# `lock` het in Visual Basic-instructie `SyncLock` -instructie of de <xref:System.Threading.Monitor>klasse bieden eenvoudiger manieren om gegevens te synchroniseren.</xref:System.Threading.Monitor>"
  syntax:
    content: public static void MemoryBarrier ();
    parameters: []
  overload: System.Threading.Thread.MemoryBarrier*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Name
  id: Name
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Opgehaald of ingesteld van de naam van de thread."
  remarks: "Deze eigenschap is schrijven-zodra. Omdat de standaardwaarde van de eigenschap Name van een thread is `null`, kunt u bepalen of een naam al expliciet aan de thread toegewezen is door te vergelijken met `null`.       De tekenreeks die is toegewezen aan de eigenschap Name kan alle Unicode-tekens bevatten."
  example:
  - "The following example shows how to name a thread.  \n  \n [!code-cs[System.Threading.Thread.Name#1](~/add/codesnippet/csharp/p-system.threading.threa_4_1.cs)]\n [!code-cpp[System.Threading.Thread.Name#1](~/add/codesnippet/cpp/p-system.threading.threa_4_1.cpp)]\n [!code-vb[System.Threading.Thread.Name#1](~/add/codesnippet/visualbasic/p-system.threading.threa_4_1.vb)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "Een tekenreeks met de naam van de thread of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er geen naam is ingesteld."
  overload: System.Threading.Thread.Name*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er is een set-bewerking aangevraagd, maar de <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> eigenschap is al ingesteld."
  platform:
  - net462
- uid: System.Threading.Thread.Priority
  id: Priority
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Opgehaald of ingesteld van een waarde die aangeeft van de prioriteit voor de planning van een thread."
  remarks: "Een thread kan worden toegewezen aan een van de volgende prioriteit <xref:System.Threading.ThreadPriority>waarden:- `Highest`       -    `AboveNormal`       -    `Normal`       -    `BelowNormal`       -    `Lowest` besturingssystemen hoeven niet te voldoen aan de prioriteit van een thread.</xref:System.Threading.ThreadPriority>"
  example:
  - "The following example shows the result of changing the priority of a thread. Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>, and the priority of a second is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>. Each thread increments a variable in a `while` loop and runs for a set time.  \n  \n [!code-cs[System.Threading.ThreadPriority#1](~/add/codesnippet/csharp/p-system.threading.threa_6_1.cs)]\n [!code-vb[System.Threading.ThreadPriority#1](~/add/codesnippet/visualbasic/p-system.threading.threa_6_1.vb)]"
  syntax:
    content: public System.Threading.ThreadPriority Priority { get; set; }
    return:
      type: System.Threading.ThreadPriority
      description: "Een van de <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> waarden. De standaardwaarde is <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref>."
  overload: System.Threading.Thread.Priority*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De thread, zoals een eindstatus heeft bereikt <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De opgegeven waarde voor een set-bewerking geen geldige is <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> waarde."
  platform:
  - net462
- uid: System.Threading.Thread.ResetAbort
  id: ResetAbort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee annuleert u een <xref:System.Threading.Thread.Abort*>aangevraagd voor de huidige thread.</xref:System.Threading.Thread.Abort*>"
  remarks: "Deze methode kan alleen worden aangeroepen door code met de juiste machtigingen.       Wanneer wordt een aanroep naar `Abort` afgebroken een thread, genereert het systeem een <xref:System.Threading.ThreadAbortException>.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`is een speciale uitzondering die kan worden onderschept door de toepassingscode, maar is opnieuw aan het einde van het catch-blok tenzij `ResetAbort` wordt aangeroepen. `ResetAbort`Hiermee annuleert u de aanvraag om af te breken, en voorkomt u dat de `ThreadAbortException` van de thread wordt beëindigd.       Zie <xref:System.Threading.ThreadAbortException>voor een voorbeeld aanroepen de `ResetAbort` methode.</xref:System.Threading.ThreadAbortException>"
  syntax:
    content: public static void ResetAbort ();
    parameters: []
  overload: System.Threading.Thread.ResetAbort*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "<xref uid=&quot;langword_csharp_Abort&quot; name=&quot;Abort&quot; href=&quot;&quot;></xref>is niet aangeroepen in de huidige thread."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper heeft niet de vereiste rechten voor de huidige thread."
  platform:
  - net462
- uid: System.Threading.Thread.Resume
  id: Resume
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hervat een thread die is onderbroken."
  remarks: >-
    > [!CAUTION]

    >  Do not use the <xref:System.Threading.Thread.Suspend%2A> and Resume methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked. Deadlocks can occur very easily.
  syntax:
    content: public void Resume ();
    parameters: []
  overload: System.Threading.Thread.Resume*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De thread is niet gestart, is inactief of bevindt zich niet in de onderbroken status."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper beschikt niet over de juiste <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  id: SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee stelt u de apartmentstatus van een thread voordat deze wordt gestart."
  remarks: "Nieuwe threads zijn geïnitialiseerd als <xref:System.Threading.ApartmentState?displayProperty=fullName>als hun apartmentstatus is niet ingesteld voordat ze worden gestart.</xref:System.Threading.ApartmentState?displayProperty=fullName> Apartmentstatus moet worden ingesteld voordat er een thread is gestart.      > [!NOTE] > De hoofdtoepassingsthread is geïnitialiseerd op <xref:System.Threading.ApartmentState?displayProperty=fullName>standaard.</xref:System.Threading.ApartmentState?displayProperty=fullName> De enige manier om de apartmentstatus van de hoofdtoepassingsthread ingesteld <xref:System.Threading.ApartmentState?displayProperty=fullName>van toepassing is de <xref:System.STAThreadAttribute>kenmerk voor de methode post-punt.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       De methode SetApartmentState samen met de <xref:System.Threading.Thread.GetApartmentState%2A>methode en de <xref:System.Threading.Thread.TrySetApartmentState%2A>methode, vervangt de <xref:System.Threading.Thread.ApartmentState%2A>eigenschap.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, SetApartmentState, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and SetApartmentState changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with SetApartmentState, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_6_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_6_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_6_1.cs)]"
  syntax:
    content: public void SetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "De nieuwe apartmentstatus."
  overload: System.Threading.Thread.SetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>is niet een geldig apartmentstatus."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De thread is al gestart."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De apartmentstatus is al geïnitialiseerd."
  platform:
  - net462
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  id: SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Van toepassing is een vastgelegde <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> naar de huidige thread."
  remarks: "Deze methode wordt niet langer ondersteund."
  syntax:
    content: public void SetCompressedStack (System.Threading.CompressedStack stack);
    parameters:
    - id: stack
      type: System.Threading.CompressedStack
      description: "De <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> object dat moet worden toegepast op de huidige thread."
  overload: System.Threading.Thread.SetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "In alle gevallen."
  platform:
  - net462
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  id: SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee stelt u de gegevens in de opgegeven sleuf in de actieve thread, voor het huidige domein die thread. Gebruik voor betere prestaties velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>in plaats daarvan het kenmerk.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework biedt twee methoden voor het gebruik van lokale opslag van thread (TLS): thread-relatief statische velden (dat wil zeggen, de velden die zijn gemarkeerd met de <xref:System.ThreadStaticAttribute>kenmerk) en gegevens sleuven.</xref:System.ThreadStaticAttribute> Thread-relatief statische velden bieden veel betere prestaties dan gegevens sleuven en controle van het type van de compilatie inschakelen. Zie voor meer informatie over het gebruik van TLS [lokale opslag Thread: Thread-relatief statische velden en gegevens sleuven](~/add/includes/ajax-current-ext-md.md).       Een mechanisme voor het geheugen van lokale archief threads gebruiken voor het opslaan van de thread-specifieke gegevens. De common language runtime wijst een matrix met meerdere sleuven data store aan elk proces, wanneer deze wordt gemaakt. De thread een gegevensgebied in het gegevensarchief kunt toewijzen, opslaan en ophalen van een waarde in de sleuf en vrije sleuf opnieuw kunnen worden gebruikt na het einde van de thread procedure en de <xref:System.Threading.Thread>object is door de garbage collector is vrijgemaakt.</xref:System.Threading.Thread> Er zijn gegevens sleuven uniek per thread. Er zijn geen andere thread (ook niet onderliggende thread), krijgt die gegevens.      > [!NOTE] > SetData is een `Shared` methode die altijd van toepassing op de momenteel uitgevoerde thread, zelfs als u deze met een variabele die naar een andere thread verwijst aanroepen. Om verwarring te voorkomen, gebruikt u de naam van de klasse bij het aanroepen van `Shared` methoden: `Thread.SetData(testSlot, &quot;test data&quot;)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_4_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_4_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_4_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_4_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_2.vb)]"
  syntax:
    content: public static void SetData (LocalDataStoreSlot slot, object data);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "De <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> waarin de waarde niet instellen."
    - id: data
      type: System.Object
      description: "De waarde moet worden ingesteld."
  overload: System.Threading.Thread.SetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.Int32)
  id: Sleep(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Onderbreekt de huidige thread voor het opgegeven aantal milliseconden."
  remarks: "De thread wordt niet worden gepland voor uitvoering door het besturingssysteem voor de hoeveelheid tijd die is opgegeven. Deze methode wijzigt de status van de thread <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> opnemen       U kunt opgeven <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>voor de `millisecondsTimeout` parameter voor het onderbreken van de thread voor onbepaalde tijd.</xref:System.Threading.Timeout.Infinite?displayProperty=fullName> We raden u echter aan dat u andere <xref:System.Threading?displayProperty=fullName>zoals klassen <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, of <xref:System.Threading.Semaphore>in plaats daarvan sychronize threads of het beheren van resources.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       Het systeemklok ticks met een bepaalde snelheid aangeroepen de resolutie van de klok. De werkelijke time-out mogelijk niet precies de opgegeven time-out, omdat de opgegeven time-out worden aangepast, zodat deze samenvalt met ticks klok. Zie voor meer informatie over de omzetting van de klok en de wachttijd de [functie Slaapstand](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) onderwerp. Deze methode roept de [functie Slaapstand](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx) uit het Windows-systeem API&quot;s.       Deze methode voert standaard COM- en SendMessage pompen.      > [!NOTE] > Als moet u voor een thread die heeft slaapstand <xref:System.STAThreadAttribute>, maar u wilt uitvoeren van de standaard COM- en SendMessage pompen, kunt u een van de overloads van de <xref:System.Threading.Thread.Join%2A>methode waarmee een time-outperiode.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method to block the application's main thread.  \n  \n [!code-cs[Thread.Sleep#1](~/add/codesnippet/csharp/m-system.threading.threa_2_1.cs)]\n [!code-vb[Thread.Sleep#1](~/add/codesnippet/visualbasic/m-system.threading.threa_2_1.vb)]\n [!code-cpp[Thread.Sleep#1](~/add/codesnippet/cpp/m-system.threading.threa_2_1.cpp)]"
  syntax:
    content: public static void Sleep (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Het aantal milliseconden waarvoor de thread is uitgesteld. Als de waarde van de `millisecondsTimeout` argument gelijk is aan nul, de thread vervangen door de rest van de tijdsperiode op een thread van dezelfde prioriteit die kan worden uitgevoerd. Als er geen andere threads met dezelfde prioriteit die gereed zijn om uit te voeren, wordt de uitvoering van de huidige thread niet onderbroken."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De time-outwaarde negatief is en is niet gelijk aan <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  id: Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Onderbreekt de huidige thread voor de opgegeven tijdsduur."
  remarks: "De thread wordt niet worden gepland voor uitvoering door het besturingssysteem voor de hoeveelheid tijd die is opgegeven. Deze methode wijzigt de status van de thread <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> opnemen       U kunt opgeven <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName>voor de `timeout` parameter voor het onderbreken van de thread voor onbepaalde tijd.</xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName> We raden u echter aan dat u andere <xref:System.Threading?displayProperty=fullName>zoals klassen <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, of <xref:System.Threading.Semaphore>in plaats daarvan sychronize threads of het beheren van resources.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       Deze overbelasting van de <xref:System.Threading.Thread.Sleep%2A>maakt gebruik van het totale aantal hele milliseconden in `timeout`.</xref:System.Threading.Thread.Sleep%2A> Breukdeel milliseconden worden genegeerd.       Deze methode voert standaard COM- en SendMessage pompen.      > [!NOTE] > Als moet u voor een thread die heeft slaapstand <xref:System.STAThreadAttribute>, maar u wilt uitvoeren van de standaard COM- en SendMessage pompen, kunt u een van de overloads van de <xref:System.Threading.Thread.Join%2A>methode waarmee een time-outperiode.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method overload to block the application's main thread five times, for two seconds each time.  \n  \n [!code-cpp[Thread.Sleep_TimeSpan#1](~/add/codesnippet/cpp/m-system.threading.threa_31_1.cpp)]\n [!code-cs[Thread.Sleep_TimeSpan#1](~/add/codesnippet/csharp/m-system.threading.threa_31_1.cs)]\n [!code-vb[Thread.Sleep_TimeSpan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_31_1.vb)]"
  syntax:
    content: public static void Sleep (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "De hoeveelheid tijd op waarvoor de thread is uitgesteld. Als de waarde van de `millisecondsTimeout` -argument is &lt;xref:System.TimeSpan?displayProperty=fullName&gt;, de thread vervangen door de rest van de tijdsperiode op een thread van dezelfde prioriteit die kan worden uitgevoerd. Als er geen andere threads met dezelfde prioriteit die gereed zijn om uit te voeren, wordt de uitvoering van de huidige thread niet onderbroken."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De waarde van <code> timeout </code> negatief is en is niet gelijk aan &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; in milliseconden, of is groter dan &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; milliseconden."
  platform:
  - net462
- uid: System.Threading.Thread.SpinWait(System.Int32)
  id: SpinWait(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Zorgt ervoor dat een thread moet worden gewacht van het aantal keren gedefinieerd door de <code> iterations </code> parameter."
  remarks: "De SpinWait-methode is handig voor het implementeren van vergrendelingen. Klassen in het .NET Framework, zoals <xref:System.Threading.Monitor>en <xref:System.Threading.ReaderWriterLock>, intern gebruik van deze methode.</xref:System.Threading.ReaderWriterLock> </xref:System.Threading.Monitor> SpinWait in wezen plaatst de processor in een zeer nauwe lus met het aantal lussen is opgegeven door de `iterations` parameter. De duur van de wachttijd is daarom afhankelijk van de snelheid van de processor.       Contrast dit met de <xref:System.Threading.Thread.Sleep%2A>methode.</xref:System.Threading.Thread.Sleep%2A> Een thread die aanroept <xref:System.Threading.Thread.Sleep%2A>resulteert in de rest van het huidige segment van de processortijd, zelfs als het opgegeven interval nul is.</xref:System.Threading.Thread.Sleep%2A> Het opgeven van een niet-nul-interval voor <xref:System.Threading.Thread.Sleep%2A>Hiermee verwijdert u de thread van overweging door de planner thread totdat het tijdsinterval is verstreken.</xref:System.Threading.Thread.Sleep%2A>       SpinWait is niet in het algemeen nuttig voor gewone toepassingen. In de meeste gevallen moet u de synchronisatie-klassen die door de .NET Framework; bijvoorbeeld: call <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>of een instructie die terugloopt <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>(`lock` in C# of `SyncLock` in Visual Basic).</xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> </xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>      > [!CAUTION] > Maken in het zeldzame geval waar wordt u aangeraden om te voorkomen dat een context-switch, zoals wanneer u weet dat er een statuswijziging dadelijk, wordt een aanroep van de methode SpinWait in uw lus. De code die spinwait wordt uitgevoerd is ontworpen om te voorkomen dat problemen die op computers met meerdere processors optreden kunnen. Op computers met meerdere Intel-processors die gebruikmaakt van Hyper-Threading-technologie, kunnen SpinWait bijvoorbeeld processor beroving in bepaalde situaties."
  syntax:
    content: public static void SpinWait (int iterations);
    parameters:
    - id: iterations
      type: System.Int32
      description: "Een 32-bits geheel getal met teken dat hoe lang een thread is bepaalt te wachten."
  overload: System.Threading.Thread.SpinWait*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Start
  id: Start
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Zorgt ervoor dat het besturingssysteem voor een statuswijziging van het huidige exemplaar <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  remarks: "Nadat een thread is het <xref:System.Threading.ThreadState?displayProperty=fullName>status, het besturingssysteem kan worden gepland voor uitvoering.</xref:System.Threading.ThreadState?displayProperty=fullName> De thread begint met het uitvoeren van de eerste regel van de methode die wordt vertegenwoordigd door de <xref:System.Threading.ThreadStart>of <xref:System.Threading.ParameterizedThreadStart>gemachtigde opgegeven voor de thread-constructor.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Houd er rekening mee dat de aanroep Begin de aanroepende thread worden niet geblokkeerd.      > [!NOTE] > Als deze overbelasting wordt gebruikt met een thread gemaakt met behulp van een <xref:System.Threading.ParameterizedThreadStart>delegeren, `null` wordt doorgegeven aan de methode die door de thread wordt uitgevoerd.</xref:System.Threading.ParameterizedThreadStart>       Nadat de thread wordt beëindigd, deze kan niet opnieuw worden gestart met een andere aanroep van `Start`."
  example:
  - "The following example creates and starts a thread.  \n  \n [!code-cpp[ThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_25_1.cpp)]\n [!code-cs[ThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_25_1.cs)]\n [!code-vb[ThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_25_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De thread is al gestart."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Er is onvoldoende geheugen beschikbaar om deze thread starten."
  platform:
  - net462
- uid: System.Threading.Thread.Start(System.Object)
  id: Start(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Zorgt ervoor dat het besturingssysteem voor een statuswijziging van het huidige exemplaar <xref href=&quot;System.Threading.ThreadState&quot;> </xref>, en desgewenst voorziet in een object met gegevens die moeten worden gebruikt door de methode die de thread wordt uitgevoerd."
  remarks: "Nadat een thread is het <xref:System.Threading.ThreadState?displayProperty=fullName>status, het besturingssysteem kan worden gepland voor uitvoering.</xref:System.Threading.ThreadState?displayProperty=fullName> De thread begint met het uitvoeren van de eerste regel van de methode die wordt vertegenwoordigd door de <xref:System.Threading.ThreadStart>of <xref:System.Threading.ParameterizedThreadStart>gemachtigde opgegeven voor de thread-constructor.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Houd er rekening mee dat de aanroep Begin de aanroepende thread worden niet geblokkeerd.       Nadat de thread wordt beëindigd, deze kan niet opnieuw worden gestart met een andere aanroep van `Start`.       Deze overbelasting en de <xref:System.Threading.ParameterizedThreadStart>gemachtigde kunt u eenvoudig gegevens moeten worden doorgegeven aan een thread-procedure, maar de techniek kan niet veilig omdat een object kan worden doorgegeven aan deze overbelasting.</xref:System.Threading.ParameterizedThreadStart> Een krachtigere manier gegevens moeten worden doorgegeven aan een thread-procedure is zowel de thread-procedure en de gegevensvelden in een object worker plaatsen. Zie voor meer informatie [Threads maken en het doorgeven van gegevens op tijd starten](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_15_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_15_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_15_1.cs)]"
  syntax:
    content: public void Start (object parameter);
    parameters:
    - id: parameter
      type: System.Object
      description: "Een object dat gegevens kunnen worden gebruikt door de methode bevat de thread wordt uitgevoerd."
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De thread is al gestart."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Er is onvoldoende geheugen beschikbaar om deze thread starten."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Deze thread is gemaakt met een <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> delegeren in plaats van een <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> delegeren."
  platform:
  - net462
- uid: System.Threading.Thread.Suspend
  id: Suspend
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "U kunt de thread wordt onderbroken of als de thread al gestopt is is, heeft geen effect."
  remarks: "Als de thread al onderbroken is, is deze methode heeft geen effect.      > [!CAUTION] > Gebruik niet de stand-bymodus en <xref:System.Threading.Thread.Resume%2A>methoden voor het synchroniseren van de activiteiten van threads.</xref:System.Threading.Thread.Resume%2A> U hebt geen enkele manier van weten welke code een thread wordt uitgevoerd wanneer u het onderbreken. Als u een thread onderbreekt terwijl deze vergrendelingen tijdens een evaluatieversie van de machtiging beveiliging bevat, andere threads in de <xref:System.AppDomain>mogelijk geblokkeerd.</xref:System.AppDomain> Als u een thread onderbreekt terwijl deze wordt uitgevoerd een klassen-constructor, andere threads in de <xref:System.AppDomain>die probeert te gebruiken dat de klasse worden geblokkeerd.</xref:System.AppDomain> Impassen kunnen heel eenvoudig optreden."
  syntax:
    content: public void Suspend ();
    parameters: []
  overload: System.Threading.Thread.Suspend*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De thread is niet gestart of is inactief."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "De aanroeper beschikt niet over de juiste <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Een set namen toegewezen aan een overeenkomende set van dispatch-id."
  remarks: "Deze methode is voor toegang tot beheerde klassen vanuit niet-beheerde code en moet niet worden aangeroepen vanuit beheerde code. Voor meer informatie over `IDispatch::GetIDsOfNames`, Zie de MSDN-bibliotheek."
  syntax:
    content: void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Gereserveerd voor toekomstig gebruik. Moet IID_NULL."
    - id: rgszNames
      type: System.IntPtr
      description: "Doorgegeven in de matrix van namen worden toegewezen."
    - id: cNames
      type: System.UInt32
      description: "Telling van de namen worden toegewezen."
    - id: lcid
      type: System.UInt32
      description: "De landinstelling context waarin u de namen te interpreteren."
    - id: rgDispId
      type: System.IntPtr
      description: "Aanroeper toegewezen matrix die de id&quot;s die overeenkomen met de namen ontvangt."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Laatgebonden toegang met behulp van de COM `IDispatch` interface wordt niet ondersteund."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Haalt de type-informatie voor een object, die vervolgens kan worden gebruikt voor het type-informatie voor een interface."
  remarks: "Deze methode is voor toegang tot beheerde klassen vanuit niet-beheerde code en moet niet worden aangeroepen vanuit beheerde code. Voor meer informatie over `IDispatch::GetTypeInfo`, Zie de MSDN-bibliotheek."
  syntax:
    content: void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "De type-informatie te retourneren."
    - id: lcid
      type: System.UInt32
      description: "De landinstellingen-id voor de type-informatie."
    - id: ppTInfo
      type: System.IntPtr
      description: "Hiermee krijgt een verwijzing naar het gevraagde type-informatie-object."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Laatgebonden toegang met behulp van de COM `IDispatch` interface wordt niet ondersteund."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Het nummer van het type informatie interfaces dat een object (0 of 1) biedt opgehaald."
  remarks: "Deze methode is voor toegang tot beheerde klassen vanuit niet-beheerde code en moet niet worden aangeroepen vanuit beheerde code. Voor meer informatie over `IDispatch::GetTypeInfoCount`, Zie de MSDN-bibliotheek."
  syntax:
    content: void _Thread.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Verwijst naar een locatie die het nummer van het type informatie interfaces van het object ontvangt."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Laatgebonden toegang met behulp van de COM `IDispatch` interface wordt niet ondersteund."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Biedt toegang tot eigenschappen en methoden die worden weergegeven door een object."
  remarks: "Deze methode is voor toegang tot beheerde klassen vanuit niet-beheerde code en moet niet worden aangeroepen vanuit beheerde code. Voor meer informatie over `IDispatch::Invoke`, Zie de MSDN-bibliotheek."
  syntax:
    content: void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "Identificeert het lid."
    - id: riid
      type: System.Guid
      description: "Gereserveerd voor toekomstig gebruik. Moet IID_NULL."
    - id: lcid
      type: System.UInt32
      description: "De landinstelling context waarin u argumenten interpreteren."
    - id: wFlags
      type: System.Int16
      description: "De vlaggen met een beschrijving van de context van de aanroep."
    - id: pDispParams
      type: System.IntPtr
      description: "Verwijzing naar een structuur met een matrix van argumenten, een matrix van dit argument DISPID&quot;s voor benoemde argumenten en tellingen voor het aantal elementen in de arrays."
    - id: pVarResult
      type: System.IntPtr
      description: "Verwijzing naar de locatie van het resultaat moet worden opgeslagen."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Verwijzing naar een structuur die informatie over de uitzondering bevat."
    - id: puArgErr
      type: System.IntPtr
      description: "De index van het eerste argument waarvoor een fout."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Laatgebonden toegang met behulp van de COM `IDispatch` interface wordt niet ondersteund."
  platform:
  - net462
- uid: System.Threading.Thread.ThreadState
  id: ThreadState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Haalt een waarde met de status van de huidige thread."
  remarks: "De eigenschap ThreadState biedt meer specifieke informatie dan de <xref:System.Threading.Thread.IsAlive%2A>eigenschap.</xref:System.Threading.Thread.IsAlive%2A>      > [!IMPORTANT] > Status van de thread is alleen van belang in scenario&quot;s voor foutopsporing. Uw code moet nooit thread staat gebruiken om te synchroniseren van de activiteiten van threads."
  example:
  - "The following code example demonstrates accessing the `ThreadState` of a thread.  \n  \n [!code-cs[System.Threading.Thread.ThreadState#1](~/add/codesnippet/csharp/p-system.threading.threa_5_1.cs)]\n [!code-vb[System.Threading.Thread.ThreadState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_5_1.vb)]\n [!code-cpp[System.Threading.Thread.ThreadState#1](~/add/codesnippet/cpp/p-system.threading.threa_5_1.cpp)]"
  syntax:
    content: public System.Threading.ThreadState ThreadState { get; }
    return:
      type: System.Threading.ThreadState
      description: "Een van de <xref href=&quot;System.Threading.ThreadState&quot;> </xref> waarden die de status van de huidige thread. De beginwaarde is <xref uid=&quot;langword_csharp_Unstarted&quot; name=&quot;Unstarted&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ThreadState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  id: TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee stelt u de apartmentstatus van een thread voordat deze wordt gestart."
  remarks: "Nieuwe threads zijn geïnitialiseerd als <xref:System.Threading.ApartmentState?displayProperty=fullName>als hun apartmentstatus is niet ingesteld voordat ze worden gestart.</xref:System.Threading.ApartmentState?displayProperty=fullName> Apartmentstatus moet worden ingesteld voordat er een thread is gestart.      > [!NOTE] > De hoofdtoepassingsthread is geïnitialiseerd op <xref:System.Threading.ApartmentState?displayProperty=fullName>standaard.</xref:System.Threading.ApartmentState?displayProperty=fullName> De enige manier om de apartmentstatus van de hoofdtoepassingsthread ingesteld <xref:System.Threading.ApartmentState?displayProperty=fullName>van toepassing is de <xref:System.STAThreadAttribute>kenmerk voor de methode post-punt.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       De methode TrySetApartmentState samen met de <xref:System.Threading.Thread.GetApartmentState%2A>methode en de <xref:System.Threading.Thread.SetApartmentState%2A>methode, vervangt de <xref:System.Threading.Thread.ApartmentState%2A>eigenschap.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and TrySetApartmentState methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The TrySetApartmentState method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the TrySetApartmentState method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_26_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_26_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_26_1.cs)]"
  syntax:
    content: public bool TrySetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "De nieuwe apartmentstatus."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de apartmentstatus is ingesteld; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.TrySetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>is niet een geldig apartmentstatus."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "De thread is al gestart."
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  id: VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "VolatileRead en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors verkrijgt VolatileRead de nieuwste waarde geschreven naar een geheugenlocatie door elke processor. U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem VolatileRead en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld VolatileRead of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld VolatileRead of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt"
  syntax:
    content: public static byte VolatileRead (ref byte address);
    parameters:
    - id: address
      type: System.Byte
      description: "Het veld om te lezen."
    return:
      type: System.Byte
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  id: VolatileRead(System.Double@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static double VolatileRead (ref double address);
    parameters:
    - id: address
      type: System.Double
      description: "Het veld om te lezen."
    return:
      type: System.Double
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  id: VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static short VolatileRead (ref short address);
    parameters:
    - id: address
      type: System.Int16
      description: "Het veld om te lezen."
    return:
      type: System.Int16
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  id: VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static int VolatileRead (ref int address);
    parameters:
    - id: address
      type: System.Int32
      description: "Het veld om te lezen."
    return:
      type: System.Int32
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  id: VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static long VolatileRead (ref long address);
    parameters:
    - id: address
      type: System.Int64
      description: "Het veld om te lezen."
    return:
      type: System.Int64
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  id: VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static IntPtr VolatileRead (ref IntPtr address);
    parameters:
    - id: address
      type: System.IntPtr
      description: "Het veld om te lezen."
    return:
      type: System.IntPtr
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  id: VolatileRead(System.Object@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static object VolatileRead (ref object address);
    parameters:
    - id: address
      type: System.Object
      description: "Het veld om te lezen."
    return:
      type: System.Object
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  id: VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static sbyte VolatileRead (ref sbyte address);
    parameters:
    - id: address
      type: System.SByte
      description: "Het veld om te lezen."
    return:
      type: System.SByte
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  id: VolatileRead(System.Single@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static float VolatileRead (ref float address);
    parameters:
    - id: address
      type: System.Single
      description: "Het veld om te lezen."
    return:
      type: System.Single
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  id: VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ushort VolatileRead (ref ushort address);
    parameters:
    - id: address
      type: System.UInt16
      description: "Het veld om te lezen."
    return:
      type: System.UInt16
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  id: VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static uint VolatileRead (ref uint address);
    parameters:
    - id: address
      type: System.UInt32
      description: "Het veld om te lezen."
    return:
      type: System.UInt32
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  id: VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ulong VolatileRead (ref ulong address);
    parameters:
    - id: address
      type: System.UInt64
      description: "Het veld om te lezen."
    return:
      type: System.UInt64
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  id: VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Leest de waarde van een veld. De waarde is de meest recente is geschreven door een processor in een computer, ongeacht het aantal processors of de status van de processorcache."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileRead%2A>verkrijgt u de nieuwste waarde geschreven naar een geheugenlocatie door elke processor.</xref:System.Threading.Thread.VolatileRead%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static UIntPtr VolatileRead (ref UIntPtr address);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "Het veld om te lezen."
    return:
      type: System.UIntPtr
      description: "De laatste waarde die is geschreven naar het veld met een processor."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  id: VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en VolatileWrite zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors VolatileWrite zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors. U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en VolatileWrite ervoor te zorgen dat een waarde is gelezen of geschreven naar het geheugen en niet in cache opgeslagen (bijvoorbeeld in een register processor).</xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, alle toegang tot het veld moet gebruiken <xref:System.Threading.Thread.VolatileRead%2A>of VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld gebruikt <xref:System.Threading.Thread.VolatileRead%2A>of VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref byte address, byte value);
    parameters:
    - id: address
      type: System.Byte
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.Byte
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  id: VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref double address, double value);
    parameters:
    - id: address
      type: System.Double
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.Double
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  id: VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref short address, short value);
    parameters:
    - id: address
      type: System.Int16
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.Int16
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  id: VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref int address, int value);
    parameters:
    - id: address
      type: System.Int32
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.Int32
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  id: VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref long address, long value);
    parameters:
    - id: address
      type: System.Int64
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.Int64
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  id: VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref IntPtr address, IntPtr value);
    parameters:
    - id: address
      type: System.IntPtr
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.IntPtr
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  id: VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref object address, object value);
    parameters:
    - id: address
      type: System.Object
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.Object
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  id: VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref sbyte address, sbyte value);
    parameters:
    - id: address
      type: System.SByte
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.SByte
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  id: VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref float address, float value);
    parameters:
    - id: address
      type: System.Single
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.Single
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  id: VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ushort address, ushort value);
    parameters:
    - id: address
      type: System.UInt16
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.UInt16
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  id: VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref uint address, uint value);
    parameters:
    - id: address
      type: System.UInt32
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.UInt32
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  id: VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ulong address, ulong value);
    parameters:
    - id: address
      type: System.UInt64
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.UInt64
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  id: VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Schrijft een waarde aan een veld onmiddellijk, zodat de waarde zichtbaar voor alle processors in de computer is."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>zijn voor bijzondere gevallen van synchronisatie.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> Onder normale omstandigheden, de C# `lock` het in Visual Basic-instructie `SyncLock` -instructie en de <xref:System.Threading.Monitor>klasse bieden eenvoudiger alternatieven.</xref:System.Threading.Monitor>       Op een systeem met meerdere processors <xref:System.Threading.Thread.VolatileWrite%2A>zorgt ervoor dat een waarde die is geschreven naar een geheugenlocatie onmiddellijk zichtbaar voor alle processors.</xref:System.Threading.Thread.VolatileWrite%2A> U moet hiervoor mogelijk processor caches leegmaken.       Zelfs op een uniprocessorsysteem <xref:System.Threading.Thread.VolatileRead%2A>en <xref:System.Threading.Thread.VolatileWrite%2A>Zorg ervoor dat een waarde is gelezen of naar het geheugen geschreven en niet in cache (bijvoorbeeld in een register processor opgeslagen).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Zo kunt u toegang tot een veld dat kan worden bijgewerkt door een andere thread of door hardware synchroniseren.       Is van invloed op een enkele geheugentoegang u deze methode aanroept. Als u effectieve synchronisatie voor een veld, moet alle toegang tot het veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> gebruiken      > [!NOTE] > In C#, met behulp van de `volatile` wijzigingsfunctie voor een veld wordt gegarandeerd dat alle toegang tot dat veld <xref:System.Threading.Thread.VolatileRead%2A>of <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> gebruikt</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref UIntPtr address, UIntPtr value);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "Het veld waaraan de waarde kan worden geschreven."
    - id: value
      type: System.UIntPtr
      description: "De waarde moet worden geschreven."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Yield
  id: Yield
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Zorgt ervoor dat de aanroepende thread voor het uitvoeren van een andere thread die kan worden uitgevoerd op de huidige processor resulteert. De thread over te dragen aan selecteren het besturingssysteem"
  remarks: "Als deze methode is gelukt, wordt de rest van de huidige tijdsperiode van de thread heeft opgeleverd. Het besturingssysteem plant de aanroepende thread voor een andere tijdsegment, volgens de prioriteit en de status van andere threads die worden uitgevoerd.       Prestaties op te leveren is beperkt tot de processor op dat de aanroepende thread wordt uitgevoerd. Het besturingssysteem wordt uitvoering niet overschakelen naar een andere processor, zelfs als die processor niet actief is of is een thread met een lagere prioriteit is uitgevoerd. Als er geen andere threads die kunnen worden uitgevoerd op de huidige processor, uitvoering niet wordt resulteert in het besturingssysteem, en deze methode retourneert `false`.       Deze methode is gelijk aan met platform aanroepen voor het aanroepen van de systeemeigen Win32 `SwitchToThread` functie. U moet aanroepen het rendement in plaats van platform aanroepmethode, omdat het platform aanroepen omleidingen eventuele aangepaste threading gedrag van die de host heeft aangevraagd."
  syntax:
    content: public static bool Yield ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het besturingssysteem worden uitgevoerd is overgeschakeld naar een andere thread. anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Threading.ThreadStateException
  parent: System.Threading
  isExternal: false
  name: ThreadStateException
  nameWithType: ThreadStateException
  fullName: System.Threading.ThreadStateException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Threading.ThreadInterruptedException
  parent: System.Threading
  isExternal: false
  name: ThreadInterruptedException
  nameWithType: ThreadInterruptedException
  fullName: System.Threading.ThreadInterruptedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
- uid: System.Threading.ParameterizedThreadStart
  parent: System.Threading
  isExternal: false
  name: ParameterizedThreadStart
  nameWithType: ParameterizedThreadStart
  fullName: System.Threading.ParameterizedThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
- uid: System.Threading.ThreadStart
  parent: System.Threading
  isExternal: false
  name: ThreadStart
  nameWithType: ThreadStart
  fullName: System.Threading.ThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
- uid: System.Threading.Thread.Abort
  parent: System.Threading.Thread
  isExternal: false
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
- uid: System.Threading.Thread.Abort(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Threading.Thread.AllocateDataSlot
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
- uid: System.LocalDataStoreSlot
  parent: System
  isExternal: false
  name: LocalDataStoreSlot
  nameWithType: LocalDataStoreSlot
  fullName: System.LocalDataStoreSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Threading.Thread.ApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
- uid: System.Threading.ApartmentState
  parent: System.Threading
  isExternal: false
  name: ApartmentState
  nameWithType: ApartmentState
  fullName: System.Threading.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
- uid: System.Threading.Thread.BeginThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
- uid: System.Threading.Thread.CurrentContext
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
- uid: System.Runtime.Remoting.Contexts.Context
  parent: System.Runtime.Remoting.Contexts
  isExternal: false
  name: Context
  nameWithType: Context
  fullName: System.Runtime.Remoting.Contexts.Context
- uid: System.Threading.Thread.CurrentCulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Threading.Thread.CurrentPrincipal
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.Threading.Thread.CurrentThread
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Threading.Thread.CurrentUICulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
- uid: System.Threading.Thread.EndCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
- uid: System.Threading.Thread.EndThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
- uid: System.Threading.Thread.ExecutionContext
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
- uid: System.Threading.ExecutionContext
  parent: System.Threading
  isExternal: true
  name: ExecutionContext
  nameWithType: ExecutionContext
  fullName: System.Threading.ExecutionContext
- uid: System.Threading.Thread.Finalize
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
- uid: System.Threading.Thread.GetApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
- uid: System.Threading.Thread.GetCompressedStack
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
- uid: System.Threading.CompressedStack
  parent: System.Threading
  isExternal: false
  name: CompressedStack
  nameWithType: CompressedStack
  fullName: System.Threading.CompressedStack
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  isExternal: false
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
- uid: System.Threading.Thread.GetDomain
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.Threading.Thread.GetDomainID
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
- uid: System.Threading.Thread.GetHashCode
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
- uid: System.Threading.Thread.Interrupt
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
- uid: System.Threading.Thread.IsAlive
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.Thread.IsBackground
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join
  parent: System.Threading.Thread
  isExternal: false
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
- uid: System.Threading.Thread.Join(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
- uid: System.Threading.Thread.Join(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.Thread.ManagedThreadId
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
- uid: System.Threading.Thread.Name
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
- uid: System.Threading.Thread.Priority
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
- uid: System.Threading.ThreadPriority
  parent: System.Threading
  isExternal: false
  name: ThreadPriority
  nameWithType: ThreadPriority
  fullName: System.Threading.ThreadPriority
- uid: System.Threading.Thread.ResetAbort
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
- uid: System.Threading.Thread.Resume
  parent: System.Threading.Thread
  isExternal: false
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
- uid: System.Threading.Thread.Sleep(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
- uid: System.Threading.Thread.SpinWait(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
- uid: System.Threading.Thread.Start
  parent: System.Threading.Thread
  isExternal: false
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
- uid: System.Threading.Thread.Start(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
- uid: System.Threading.Thread.Suspend
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Threading.Thread.ThreadState
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
- uid: System.Threading.ThreadState
  parent: System.Threading
  isExternal: false
  name: ThreadState
  nameWithType: ThreadState
  fullName: System.Threading.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
- uid: System.SByte
  parent: System
  isExternal: true
  name: SByte
  nameWithType: SByte
  fullName: System.SByte
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
- uid: System.UInt16
  parent: System
  isExternal: true
  name: UInt16
  nameWithType: UInt16
  fullName: System.UInt16
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
- uid: System.UInt64
  parent: System
  isExternal: true
  name: UInt64
  nameWithType: UInt64
  fullName: System.UInt64
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
- uid: System.UIntPtr
  parent: System
  isExternal: true
  name: UIntPtr
  nameWithType: UIntPtr
  fullName: System.UIntPtr
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
- uid: System.Threading.Thread.Yield
  parent: System.Threading.Thread
  isExternal: false
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
- uid: System.Threading.Thread.#ctor*
  parent: System.Threading.Thread
  isExternal: false
  name: Thread
  nameWithType: Thread.Thread
- uid: System.Threading.Thread.Abort*
  parent: System.Threading.Thread
  isExternal: false
  name: Abort
  nameWithType: Thread.Abort
- uid: System.Threading.Thread.AllocateDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot
  nameWithType: Thread.AllocateDataSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot
  nameWithType: Thread.AllocateNamedDataSlot
- uid: System.Threading.Thread.ApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion
  nameWithType: Thread.BeginCriticalRegion
- uid: System.Threading.Thread.BeginThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity
  nameWithType: Thread.BeginThreadAffinity
- uid: System.Threading.Thread.CurrentContext*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
- uid: System.Threading.Thread.CurrentCulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
- uid: System.Threading.Thread.CurrentPrincipal*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
- uid: System.Threading.Thread.CurrentThread*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
- uid: System.Threading.Thread.CurrentUICulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup*
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup
  nameWithType: Thread.DisableComObjectEagerCleanup
- uid: System.Threading.Thread.EndCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion
  nameWithType: Thread.EndCriticalRegion
- uid: System.Threading.Thread.EndThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity
  nameWithType: Thread.EndThreadAffinity
- uid: System.Threading.Thread.ExecutionContext*
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
- uid: System.Threading.Thread.Finalize*
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize
  nameWithType: Thread.Finalize
- uid: System.Threading.Thread.FreeNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot
  nameWithType: Thread.FreeNamedDataSlot
- uid: System.Threading.Thread.GetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState
  nameWithType: Thread.GetApartmentState
- uid: System.Threading.Thread.GetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack
  nameWithType: Thread.GetCompressedStack
- uid: System.Threading.Thread.GetData*
  parent: System.Threading.Thread
  isExternal: false
  name: GetData
  nameWithType: Thread.GetData
- uid: System.Threading.Thread.GetDomain*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain
  nameWithType: Thread.GetDomain
- uid: System.Threading.Thread.GetDomainID*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID
  nameWithType: Thread.GetDomainID
- uid: System.Threading.Thread.GetHashCode*
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode
  nameWithType: Thread.GetHashCode
- uid: System.Threading.Thread.GetNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot
  nameWithType: Thread.GetNamedDataSlot
- uid: System.Threading.Thread.Interrupt*
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt
  nameWithType: Thread.Interrupt
- uid: System.Threading.Thread.IsAlive*
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
- uid: System.Threading.Thread.IsBackground*
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread*
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join*
  parent: System.Threading.Thread
  isExternal: false
  name: Join
  nameWithType: Thread.Join
- uid: System.Threading.Thread.ManagedThreadId*
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier*
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier
  nameWithType: Thread.MemoryBarrier
- uid: System.Threading.Thread.Name*
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
- uid: System.Threading.Thread.Priority*
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
- uid: System.Threading.Thread.ResetAbort*
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort
  nameWithType: Thread.ResetAbort
- uid: System.Threading.Thread.Resume*
  parent: System.Threading.Thread
  isExternal: false
  name: Resume
  nameWithType: Thread.Resume
- uid: System.Threading.Thread.SetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState
  nameWithType: Thread.SetApartmentState
- uid: System.Threading.Thread.SetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack
  nameWithType: Thread.SetCompressedStack
- uid: System.Threading.Thread.SetData*
  parent: System.Threading.Thread
  isExternal: false
  name: SetData
  nameWithType: Thread.SetData
- uid: System.Threading.Thread.Sleep*
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep
  nameWithType: Thread.Sleep
- uid: System.Threading.Thread.SpinWait*
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait
  nameWithType: Thread.SpinWait
- uid: System.Threading.Thread.Start*
  parent: System.Threading.Thread
  isExternal: false
  name: Start
  nameWithType: Thread.Start
- uid: System.Threading.Thread.Suspend*
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend
  nameWithType: Thread.Suspend
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke
- uid: System.Threading.Thread.ThreadState*
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState
  nameWithType: Thread.TrySetApartmentState
- uid: System.Threading.Thread.VolatileRead*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead
  nameWithType: Thread.VolatileRead
- uid: System.Threading.Thread.VolatileWrite*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite
  nameWithType: Thread.VolatileWrite
- uid: System.Threading.Thread.Yield*
  parent: System.Threading.Thread
  isExternal: false
  name: Yield
  nameWithType: Thread.Yield
