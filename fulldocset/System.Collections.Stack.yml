### YamlMime:ManagedReference
items:
- uid: System.Collections.Stack
  id: Stack
  children:
  - System.Collections.Stack.#ctor
  - System.Collections.Stack.#ctor(System.Collections.ICollection)
  - System.Collections.Stack.#ctor(System.Int32)
  - System.Collections.Stack.Clear
  - System.Collections.Stack.Clone
  - System.Collections.Stack.Contains(System.Object)
  - System.Collections.Stack.CopyTo(System.Array,System.Int32)
  - System.Collections.Stack.Count
  - System.Collections.Stack.GetEnumerator
  - System.Collections.Stack.IsSynchronized
  - System.Collections.Stack.Peek
  - System.Collections.Stack.Pop
  - System.Collections.Stack.Push(System.Object)
  - System.Collections.Stack.Synchronized(System.Collections.Stack)
  - System.Collections.Stack.SyncRoot
  - System.Collections.Stack.ToArray
  langs:
  - csharp
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
  type: Class
  summary: "Vertegenwoordigt een eenvoudige laatste in first out (LIFO) niet-algemene verzameling van objecten."
  remarks: "Zie voor de algemene versie van deze verzameling <xref:System.Collections.Generic.Stack%601?displayProperty=fullName>.</xref:System.Collections.Generic.Stack%601?displayProperty=fullName>       De capaciteit van een Stack is het aantal elementen die de Stack kan bevatten. Als elementen worden toegevoegd aan een verzameling, de capaciteit automatisch wordt verhoogd door Hertoewijzing zoals wordt vereist.       Als <xref:System.Collections.Stack.Count%2A>kleiner is dan de capaciteit van de stack <xref:System.Collections.Stack.Push%2A>is een bewerking O(1).</xref:System.Collections.Stack.Push%2A> </xref:System.Collections.Stack.Count%2A> Als de capaciteit worden verhoogd moet om ruimte is voor het nieuwe element <xref:System.Collections.Stack.Push%2A>wordt een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A> </xref:System.Collections.Stack.Push%2A> <xref:System.Collections.Stack.Pop%2A>is een bewerking O(1).</xref:System.Collections.Stack.Pop%2A>       Stack accepteert `null` als een geldige waarde en dubbele elementen zijn toegestaan."
  example:
  - "The following example shows how to create and add values to a Stack and how to display its values.  \n  \n [!code-cs[Classic Stack Example#1](~/add/codesnippet/csharp/t-system.collections.stack_1.cs)]\n [!code-vb[Classic Stack Example#1](~/add/codesnippet/visualbasic/t-system.collections.stack_1.vb)]\n [!code-cpp[Classic Stack Example#1](~/add/codesnippet/cpp/t-system.collections.stack_1.cpp)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Stack/StackDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Stack : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor
  id: '#ctor'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Collections.Stack&quot;> </xref> klasse die leeg is en is de initiële standaardcapaciteit."
  remarks: "De capaciteit van een <xref:System.Collections.Stack>is het aantal elementen die de <xref:System.Collections.Stack>kan bevatten.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Wanneer elementen worden toegevoegd aan een <xref:System.Collections.Stack>, de capaciteit automatisch verhoogd zoals wordt vereist door het opnieuw toewijzen van de interne matrix.</xref:System.Collections.Stack>       Als de grootte van de verzameling kan worden geschat, voorkomen geven de begincapaciteit moet een aantal formaatwijzigingen bij het toevoegen van elementen in de <xref:System.Collections.Stack>.</xref:System.Collections.Stack> uitvoeren       Deze constructor is een bewerking O(1)."
  syntax:
    content: public Stack ();
    parameters: []
  overload: System.Collections.Stack.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Collections.Stack&quot;> </xref> klasse die bevat elementen die zijn gekopieerd uit de opgegeven verzameling en heeft de dezelfde begincapaciteit als het aantal elementen die zijn gekopieerd."
  remarks: "De capaciteit van een <xref:System.Collections.Stack>is het aantal elementen die de <xref:System.Collections.Stack>kan bevatten.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Wanneer elementen worden toegevoegd aan een <xref:System.Collections.Stack>, de capaciteit automatisch verhoogd zoals wordt vereist door het opnieuw toewijzen van de interne matrix.</xref:System.Collections.Stack>       Als de grootte van de verzameling kan worden geschat, voorkomen geven de begincapaciteit moet een aantal formaatwijzigingen bij het toevoegen van elementen in de <xref:System.Collections.Stack>.</xref:System.Collections.Stack> uitvoeren       De elementen zijn gekopieerd naar de <xref:System.Collections.Stack>in dezelfde volgorde als die ze worden gelezen door de <xref:System.Collections.IEnumerator>van de <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> </xref:System.Collections.Stack>       Deze constructor is een O (`n`)-bewerking, waarbij `n` is het aantal elementen in `col`."
  syntax:
    content: public Stack (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "De <xref:System.Collections.ICollection>kopiëren van elementen uit.</xref:System.Collections.ICollection>"
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Collections.Stack&quot;> </xref> klasse zijn die leeg en heeft de opgegeven begincapaciteit of de eerste standaardcapaciteit, indien dit eerder valt."
  remarks: "De capaciteit van een <xref:System.Collections.Stack>is het aantal elementen die de <xref:System.Collections.Stack>kan bevatten.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Wanneer elementen worden toegevoegd aan een <xref:System.Collections.Stack>, de capaciteit automatisch verhoogd zoals wordt vereist door het opnieuw toewijzen van de interne matrix.</xref:System.Collections.Stack>       Als de grootte van de verzameling kan worden geschat, voorkomen geven de begincapaciteit moet een aantal formaatwijzigingen bij het toevoegen van elementen in de <xref:System.Collections.Stack>.</xref:System.Collections.Stack> uitvoeren       Deze constructor is een O (`n`)-bewerking, waarbij `n` is `initialCapacity`."
  syntax:
    content: public Stack (int initialCapacity);
    parameters:
    - id: initialCapacity
      type: System.Int32
      description: "Het eerste aantal elementen die de <xref href=&quot;System.Collections.Stack&quot;> </xref> kan bevatten."
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>initialCapacity</code>is kleiner dan nul."
  platform:
  - net462
- uid: System.Collections.Stack.Clear
  id: Clear
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hiermee verwijdert u alle objecten van de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "<xref:System.Collections.Stack.Count%2A>is ingesteld op nul en verwijzingen naar andere objecten in de elementen van de verzameling ook worden vrijgegeven.</xref:System.Collections.Stack.Count%2A>       Deze methode is een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Stack>.  \n  \n [!code-cpp[Classic Stack.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.sta_5_1.cpp)]\n [!code-vb[Classic Stack.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_5_1.vb)]\n [!code-cs[Classic Stack.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.sta_5_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Stack.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Clone
  id: Clone
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Maakt een recente kopie van de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Een recente kopie van een verzameling kopieert alleen de elementen van de verzameling of ze verwijzingstypen of typen zijn, maar deze worden niet gekopieerd door de objecten die de verwijzingen naar verwijzen. De verwijzingen in de nieuwe verzameling verwijzen naar dezelfde objecten die de verwijzingen in de oorspronkelijke verzameling naar verwijzen.       Daarentegen een diepe kopie van een verzameling kopieert de elementen en alles direct of indirect waarnaar wordt verwezen door de elementen.       Deze methode is een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Een recente kopie van de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hiermee wordt bepaald of een element in de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Deze methode bepaalt gelijkheid door het aanroepen van de <xref:System.Object.Equals%2A?displayProperty=fullName>methode.</xref:System.Object.Equals%2A?displayProperty=fullName>       Deze methode voert een lineaire zoeken; Deze methode is daarom een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>       Beginnen met .NET Framework 2.0, deze methode wordt getest gelijkheid door de `obj` argument voor de <xref:System.Object.Equals%2A>methode van de afzonderlijke objecten in de verzameling.</xref:System.Object.Equals%2A> In eerdere versies van .NET Framework, deze beslissing is gemaakt met behulp van de afzonderlijke items wordt doorgegeven in de verzameling aan de <xref:System.Object.Equals%2A>methode van de `obj` argument.</xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Het object te vinden in de <xref href=&quot;System.Collections.Stack&quot;> </xref>. De waarde kan zijn <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, if <code>obj</code> is found in the <xref href=&quot;System.Collections.Stack&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Stack.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopieert de <xref href=&quot;System.Collections.Stack&quot;> </xref> aan een bestaande eendimensionale <xref:System.Array>, te beginnen bij de index van de opgegeven matrix.</xref:System.Array>"
  remarks: "De elementen zijn gekopieerd naar de matrix in laatste in first out (LIFO) volgorde, overeen met de elementen die zijn geretourneerd door een opeenvolging van aanroepen naar <xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>       Deze methode is een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_6_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_6_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_6_1.cs)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "De eendimensionale <xref:System.Array>die het doel van de elementen die zijn gekopieerd uit <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Array> De <xref:System.Array>moet hebben op nul gebaseerde indexering.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "De op nul gebaseerde index in `array` welke kopiëren begint."
  overload: System.Collections.Stack.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>is kleiner dan nul."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>is multidimensionaal.       - of - het aantal elementen in de bron <xref href=&quot;System.Collections.Stack&quot;> </xref> groter is dan de beschikbare ruimte vanaf <code>index</code> aan het einde van de bestemming <code>array</code>."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "Het type van de bron <xref href=&quot;System.Collections.Stack&quot;> </xref> kan niet automatisch worden geconverteerd naar het type van de bestemming <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Stack.Count
  id: Count
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hiermee wordt het aantal elementen in de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "De capaciteit is het aantal elementen die de <xref:System.Collections.Stack>kunt opslaan.</xref:System.Collections.Stack> Aantal is het aantal elementen die daadwerkelijk in de <xref:System.Collections.Stack>.</xref:System.Collections.Stack>       De capaciteit is altijd groter zijn dan of gelijk aan Count. Als het aantal hoger is dan de capaciteit tijdens het toevoegen van elementen, wordt de capaciteit automatisch verhoogd met het opnieuw toewijzen van de interne matrix voordat de oude elementen kopiëren en toevoegen van nieuwe elementen.       Ophalen van de waarde van deze eigenschap is een O(1)-bewerking."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "Het aantal elementen in de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Stack
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Retourneert een <xref:System.Collections.IEnumerator>voor de <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Collections.IEnumerator>"
  remarks: "[Visual Basic C#]       De `foreach` -instructie van de taal C# (`for each` in Visual Basic) de complexiteit van de opsommingen worden verborgen.  Daarom kan het gebruik `foreach` wordt aanbevolen, in plaats van rechtstreeks bewerken van de enumerator.       Enumerators kunnen worden gebruikt om de gegevens in de verzameling te lezen, maar ze kunnen niet worden gebruikt om de onderliggende verzameling niet wijzigen.       In eerste instantie bevindt de enumerator zich vóór het eerste element in de verzameling. <xref:System.Collections.IEnumerator.Reset%2A>brengt ook de enumerator terug naar deze positie.</xref:System.Collections.IEnumerator.Reset%2A>  Op deze positie <xref:System.Collections.IEnumerator.Current%2A>is niet gedefinieerd.</xref:System.Collections.IEnumerator.Current%2A> U moet daarom aanroepen <xref:System.Collections.IEnumerator.MoveNext%2A>om door te gaan van de enumerator voor het eerste element van de verzameling voordat het lezen van <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>retourneert de hetzelfde object totdat de <xref:System.Collections.IEnumerator.MoveNext%2A>of <xref:System.Collections.IEnumerator.Reset%2A>wordt aangeroepen.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Hiermee stelt u <xref:System.Collections.IEnumerator.Current%2A>naar het volgende element.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Als <xref:System.Collections.IEnumerator.MoveNext%2A>geeft het einde van de verzameling, de enumerator bevindt zich na het laatste element in de verzameling en <xref:System.Collections.IEnumerator.MoveNext%2A>retourneert `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Wanneer de enumerator is op deze positie, volgende aanroepen naar <xref:System.Collections.IEnumerator.MoveNext%2A>ook retourneren `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Als de laatste aanroep aan <xref:System.Collections.IEnumerator.MoveNext%2A>geretourneerd `false`, <xref:System.Collections.IEnumerator.Current%2A>is niet gedefinieerd.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>U kunt naar het eerste element van de verzameling opnieuw aanroepen <xref:System.Collections.IEnumerator.Reset%2A>gevolgd door <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A> instellen       Een enumerator blijft geldig zolang de verzameling ongewijzigd blijft. Als er wijzigingen zijn aangebracht aan de verzameling, zoals het toevoegen, wijzigen of verwijderen van elementen, de enumerator is permanent ongeldig en het gedrag is niet gedefinieerd.       De enumerator heeft geen exclusieve toegang tot de verzameling; inventariseren door middel van een verzameling is daarom intrinsiek geen procedure thread-safe.  Om te garanderen thread veiligheid tijdens de opsomming, vergrendelt u de verzameling gedurende de volledige inventarisatie.  Als u wilt toestaan dat de verzameling worden geopend door meerdere threads voor lezen en schrijven, moet u uw eigen synchronisatie implementeren.       Deze methode is een bewerking O(1)."
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Stack&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Stack.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Stack
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Haalt een waarde die aangeeft of de toegang tot de <xref href=&quot;System.Collections.Stack&quot;> </xref> is gesynchroniseerd (thread-veilig)."
  remarks: "Om te waarborgen van de veiligheid van de thread van de <xref:System.Collections.Stack>, alle bewerkingen moeten worden uitgevoerd via de wrapper die is geretourneerd door de <xref:System.Collections.Stack.Synchronized%2A>methode.</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack>       Inventariseren door middel van een verzameling is intrinsiek niet een thread-veilige procedure. Zelfs wanneer een verzameling wordt gesynchroniseerd, andere threads kunnen nog steeds de verzameling niet wijzigen, waardoor de enumerator is een uitzondering. Om te garanderen thread veiligheid tijdens de opsomming, moet u de verzameling tijdens de gehele opsomming vergrendelen of het gevolg van wijzigingen die door andere threads uitzonderingen wordt onderschept.       De volgende voorbeeldcode laat zien hoe vergrendelen op de verzameling met behulp van de <xref:System.Collections.Stack.SyncRoot%2A>tijdens de gehele opsomming.</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[Klassieke Stack.IsSynchronized voorbeeld&#2;](~/add/codesnippet/cpp/p-system.collections.sta_0_1.cpp)][!code-cs[klassieke Stack.IsSynchronized voorbeeld&#2;](~/add/codesnippet/csharp/p-system.collections.sta_0_1.cs)][!code-vb[klassieke Stack.IsSynchronized voorbeeld&#2;](~/add/codesnippet/visualbasic/p-system.collections.sta_0_1.vb) ] ophalen van de waarde van deze eigenschap is een bewerking O(1).    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.sta_0_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.sta_0_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.sta_0_2.cs)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, als de toegang tot de <xref href=&quot;System.Collections.Stack&quot;> </xref> is gesynchroniseerd (thread-safe); anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. De standaardwaarde is <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Stack.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Peek
  id: Peek
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Retourneert het object boven aan de <xref href=&quot;System.Collections.Stack&quot;> </xref> zonder het te verwijderen."
  remarks: "Deze methode is vergelijkbaar met de <xref:System.Collections.Stack.Pop%2A>methode, maar Peek de <xref:System.Collections.Stack>.</xref:System.Collections.Stack> niet wijzigen</xref:System.Collections.Stack.Pop%2A>       `null`kan worden geactiveerd op de <xref:System.Collections.Stack>als tijdelijke aanduiding, indien nodig.</xref:System.Collections.Stack> U onderscheid maken tussen een null-waarde en het einde van de stack, Controleer de <xref:System.Collections.Stack.Count%2A>eigenschap of catch de <xref:System.InvalidOperationException>, die wordt gegenereerd wanneer de <xref:System.Collections.Stack>is leeg.</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       Deze methode is een bewerking O(1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_4_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_4_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_4_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "De <xref:System.Object>boven aan de <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De <xref href=&quot;System.Collections.Stack&quot;> </xref> is leeg."
  platform:
  - net462
- uid: System.Collections.Stack.Pop
  id: Pop
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Verwijdert en retourneert het object boven aan de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Deze methode is vergelijkbaar met de <xref:System.Collections.Stack.Peek%2A>methode, maar <xref:System.Collections.Stack.Peek%2A>niet de <xref:System.Collections.Stack>.</xref:System.Collections.Stack> wijzigt</xref:System.Collections.Stack.Peek%2A> </xref:System.Collections.Stack.Peek%2A>       `null`kan worden geactiveerd op de <xref:System.Collections.Stack>als tijdelijke aanduiding, indien nodig.</xref:System.Collections.Stack> U onderscheid maken tussen een null-waarde en het einde van de stack, Controleer de <xref:System.Collections.Stack.Count%2A>eigenschap of catch de <xref:System.InvalidOperationException>, die wordt gegenereerd wanneer de <xref:System.Collections.Stack>is leeg.</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       Deze methode is een bewerking O(1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_2_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_2_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_2_1.cpp)]"
  syntax:
    content: public virtual object Pop ();
    parameters: []
    return:
      type: System.Object
      description: "De <xref:System.Object>verwijderd uit de bovenkant van de <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.Pop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De <xref href=&quot;System.Collections.Stack&quot;> </xref> is leeg."
  platform:
  - net462
- uid: System.Collections.Stack.Push(System.Object)
  id: Push(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hiermee voegt u een object aan de bovenkant van de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Als <xref:System.Collections.Stack.Count%2A>al gelijk is aan de capaciteit, de capaciteit van de <xref:System.Collections.Stack>wordt verhoogd met automatisch opnieuw toewijzen van de interne matrix en de bestaande elementen zijn gekopieerd naar de nieuwe matrix voordat het nieuwe element is toegevoegd.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Count%2A>       `null`kan worden geactiveerd op de <xref:System.Collections.Stack>als tijdelijke aanduiding, indien nodig.</xref:System.Collections.Stack> Het met betrekking tot een site in de stack en wordt behandeld als een object.       Als <xref:System.Collections.Stack.Count%2A>is kleiner dan de capaciteit van de stack Push is een bewerking O(1).</xref:System.Collections.Stack.Count%2A> Als de capaciteit worden verhoogd moet om ruimte is voor het nieuwe element, Push wordt een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_1_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_1_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_1_1.cpp)]"
  syntax:
    content: public virtual void Push (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "De <xref:System.Object>om te pushen naar de <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object> De waarde kan zijn <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Stack.Push*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  id: Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Retourneert een gesynchroniseerd (thread-safe)-wrapper voor de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Om te waarborgen van de veiligheid van de thread van de <xref:System.Collections.Stack>, moeten alle bewerkingen worden uitgevoerd via deze wrapper.</xref:System.Collections.Stack>       Inventariseren door middel van een verzameling is intrinsiek niet een thread-veilige procedure. Zelfs wanneer een verzameling wordt gesynchroniseerd, andere threads kunnen nog steeds de verzameling niet wijzigen, waardoor de enumerator is een uitzondering. Om te garanderen thread veiligheid tijdens de opsomming, moet u de verzameling tijdens de gehele opsomming vergrendelen of het gevolg van wijzigingen die door andere threads uitzonderingen wordt onderschept.       De volgende voorbeeldcode laat zien hoe vergrendelen op de verzameling met behulp van de <xref:System.Collections.Stack.SyncRoot%2A>tijdens de gehele opsomming.</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[Klassieke Stack.IsSynchronized voorbeeld&#2;](~/add/codesnippet/cpp/m-system.collections.sta_3_1.cpp)][!code-cs[klassieke Stack.IsSynchronized voorbeeld&#2;](~/add/codesnippet/csharp/m-system.collections.sta_3_1.cs)][!code-vb[klassieke Stack.IsSynchronized voorbeeld&#2;](~/add/codesnippet/visualbasic/m-system.collections.sta_3_1.vb) ] deze methode is een bewerking O(1).    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_3_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.sta_3_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.sta_3_2.cs)]"
  syntax:
    content: public static System.Collections.Stack Synchronized (System.Collections.Stack stack);
    parameters:
    - id: stack
      type: System.Collections.Stack
      description: "De <xref href=&quot;System.Collections.Stack&quot;> </xref> om te synchroniseren."
    return:
      type: System.Collections.Stack
      description: "Een gesynchroniseerde wrapper rond de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.SyncRoot
  id: SyncRoot
  parent: System.Collections.Stack
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Haalt een object dat kan worden gebruikt voor het synchroniseren van toegang tot de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  remarks: "Maken van een gesynchroniseerde versie van de <xref:System.Collections.Stack>, gebruiken de <xref:System.Collections.Stack.Synchronized%2A>methode.</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack> Afgeleide klassen kunnen evenwel de eigen gesynchroniseerde versie van de <xref:System.Collections.Stack>met behulp van de eigenschap SyncRoot.</xref:System.Collections.Stack> De code voor het synchroniseren moet bewerkingen uitvoeren op de SyncRoot van de <xref:System.Collections.Stack>, niet rechtstreeks op de <xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack> Dit zorgt ervoor dat de goede werking van de verzamelingen die zijn afgeleid van andere objecten. In het bijzonder houdt juiste synchronisatie met andere threads dat tegelijkertijd kan worden wijzigt de <xref:System.Collections.Stack>object.</xref:System.Collections.Stack>       Inventariseren door middel van een verzameling is intrinsiek niet een thread-veilige procedure. Zelfs wanneer een verzameling wordt gesynchroniseerd, andere threads kunnen nog steeds de verzameling niet wijzigen, waardoor de enumerator is een uitzondering. Om te garanderen thread veiligheid tijdens de opsomming, moet u de verzameling tijdens de gehele opsomming vergrendelen of het gevolg van wijzigingen die door andere threads uitzonderingen wordt onderschept.       De volgende voorbeeldcode laat zien hoe de verzameling met behulp van de SyncRoot tijdens de gehele opsomming vergrendelen.       [!code-cpp[Klassieke Stack.IsSynchronized voorbeeld&#2;](~/add/codesnippet/cpp/p-system.collections.sta_1_1.cpp)][!code-cs[klassieke Stack.IsSynchronized voorbeeld&#2;](~/add/codesnippet/csharp/p-system.collections.sta_1_1.cs)][!code-vb[klassieke Stack.IsSynchronized voorbeeld&#2;](~/add/codesnippet/visualbasic/p-system.collections.sta_1_1.vb) ] ophalen van de waarde van deze eigenschap is een bewerking O(1).    "
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Een <xref:System.Object>die kunnen worden gebruikt om te synchroniseren van toegang tot de <xref href=&quot;System.Collections.Stack&quot;> </xref>.</xref:System.Object>"
  overload: System.Collections.Stack.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.ToArray
  id: ToArray
  parent: System.Collections.Stack
  langs:
  - csharp
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopieert de <xref href=&quot;System.Collections.Stack&quot;> </xref> naar een nieuwe matrix."
  remarks: "De elementen zijn gekopieerd naar de matrix in laatste in first out (LIFO) volgorde, overeen met de elementen die zijn geretourneerd door een opeenvolging van aanroepen naar <xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>       Deze methode is een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Stack.Count%2A>.</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_0_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_0_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_0_1.cs)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "Een nieuwe matrix met kopieën van de elementen van de <xref href=&quot;System.Collections.Stack&quot;> </xref>."
  overload: System.Collections.Stack.ToArray*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Collections.Stack.#ctor
  parent: System.Collections.Stack
  isExternal: false
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Stack.#ctor(System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Stack.Clear
  parent: System.Collections.Stack
  isExternal: false
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
- uid: System.Collections.Stack.Clone
  parent: System.Collections.Stack
  isExternal: false
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
- uid: System.Collections.Stack.Contains(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Stack.Count
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
- uid: System.Collections.Stack.GetEnumerator
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Stack.IsSynchronized
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
- uid: System.Collections.Stack.Peek
  parent: System.Collections.Stack
  isExternal: false
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
- uid: System.Collections.Stack.Pop
  parent: System.Collections.Stack
  isExternal: false
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
- uid: System.Collections.Stack.Push(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
- uid: System.Collections.Stack
  parent: System.Collections
  isExternal: false
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
- uid: System.Collections.Stack.SyncRoot
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
- uid: System.Collections.Stack.ToArray
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Stack.#ctor*
  parent: System.Collections.Stack
  isExternal: false
  name: Stack
  nameWithType: Stack.Stack
- uid: System.Collections.Stack.Clear*
  parent: System.Collections.Stack
  isExternal: false
  name: Clear
  nameWithType: Stack.Clear
- uid: System.Collections.Stack.Clone*
  parent: System.Collections.Stack
  isExternal: false
  name: Clone
  nameWithType: Stack.Clone
- uid: System.Collections.Stack.Contains*
  parent: System.Collections.Stack
  isExternal: false
  name: Contains
  nameWithType: Stack.Contains
- uid: System.Collections.Stack.CopyTo*
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo
  nameWithType: Stack.CopyTo
- uid: System.Collections.Stack.Count*
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
- uid: System.Collections.Stack.GetEnumerator*
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator
  nameWithType: Stack.GetEnumerator
- uid: System.Collections.Stack.IsSynchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
- uid: System.Collections.Stack.Peek*
  parent: System.Collections.Stack
  isExternal: false
  name: Peek
  nameWithType: Stack.Peek
- uid: System.Collections.Stack.Pop*
  parent: System.Collections.Stack
  isExternal: false
  name: Pop
  nameWithType: Stack.Pop
- uid: System.Collections.Stack.Push*
  parent: System.Collections.Stack
  isExternal: false
  name: Push
  nameWithType: Stack.Push
- uid: System.Collections.Stack.Synchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized
  nameWithType: Stack.Synchronized
- uid: System.Collections.Stack.SyncRoot*
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
- uid: System.Collections.Stack.ToArray*
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray
  nameWithType: Stack.ToArray
