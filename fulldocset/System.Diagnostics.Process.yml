### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.Process
  id: Process
  children:
  - System.Diagnostics.Process.#ctor
  - System.Diagnostics.Process.BasePriority
  - System.Diagnostics.Process.BeginErrorReadLine
  - System.Diagnostics.Process.BeginOutputReadLine
  - System.Diagnostics.Process.CancelErrorRead
  - System.Diagnostics.Process.CancelOutputRead
  - System.Diagnostics.Process.Close
  - System.Diagnostics.Process.CloseMainWindow
  - System.Diagnostics.Process.Dispose(System.Boolean)
  - System.Diagnostics.Process.EnableRaisingEvents
  - System.Diagnostics.Process.EnterDebugMode
  - System.Diagnostics.Process.ErrorDataReceived
  - System.Diagnostics.Process.ExitCode
  - System.Diagnostics.Process.Exited
  - System.Diagnostics.Process.ExitTime
  - System.Diagnostics.Process.GetCurrentProcess
  - System.Diagnostics.Process.GetProcessById(System.Int32)
  - System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - System.Diagnostics.Process.GetProcesses
  - System.Diagnostics.Process.GetProcesses(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  - System.Diagnostics.Process.Handle
  - System.Diagnostics.Process.HandleCount
  - System.Diagnostics.Process.HasExited
  - System.Diagnostics.Process.Id
  - System.Diagnostics.Process.Kill
  - System.Diagnostics.Process.LeaveDebugMode
  - System.Diagnostics.Process.MachineName
  - System.Diagnostics.Process.MainModule
  - System.Diagnostics.Process.MainWindowHandle
  - System.Diagnostics.Process.MainWindowTitle
  - System.Diagnostics.Process.MaxWorkingSet
  - System.Diagnostics.Process.MinWorkingSet
  - System.Diagnostics.Process.Modules
  - System.Diagnostics.Process.NonpagedSystemMemorySize
  - System.Diagnostics.Process.NonpagedSystemMemorySize64
  - System.Diagnostics.Process.OnExited
  - System.Diagnostics.Process.OutputDataReceived
  - System.Diagnostics.Process.PagedMemorySize
  - System.Diagnostics.Process.PagedMemorySize64
  - System.Diagnostics.Process.PagedSystemMemorySize
  - System.Diagnostics.Process.PagedSystemMemorySize64
  - System.Diagnostics.Process.PeakPagedMemorySize
  - System.Diagnostics.Process.PeakPagedMemorySize64
  - System.Diagnostics.Process.PeakVirtualMemorySize
  - System.Diagnostics.Process.PeakVirtualMemorySize64
  - System.Diagnostics.Process.PeakWorkingSet
  - System.Diagnostics.Process.PeakWorkingSet64
  - System.Diagnostics.Process.PriorityBoostEnabled
  - System.Diagnostics.Process.PriorityClass
  - System.Diagnostics.Process.PrivateMemorySize
  - System.Diagnostics.Process.PrivateMemorySize64
  - System.Diagnostics.Process.PrivilegedProcessorTime
  - System.Diagnostics.Process.ProcessName
  - System.Diagnostics.Process.ProcessorAffinity
  - System.Diagnostics.Process.Refresh
  - System.Diagnostics.Process.Responding
  - System.Diagnostics.Process.SafeHandle
  - System.Diagnostics.Process.SessionId
  - System.Diagnostics.Process.StandardError
  - System.Diagnostics.Process.StandardInput
  - System.Diagnostics.Process.StandardOutput
  - System.Diagnostics.Process.Start
  - System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  - System.Diagnostics.Process.Start(System.String)
  - System.Diagnostics.Process.Start(System.String,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.StartInfo
  - System.Diagnostics.Process.StartTime
  - System.Diagnostics.Process.SynchronizingObject
  - System.Diagnostics.Process.Threads
  - System.Diagnostics.Process.ToString
  - System.Diagnostics.Process.TotalProcessorTime
  - System.Diagnostics.Process.UserProcessorTime
  - System.Diagnostics.Process.VirtualMemorySize
  - System.Diagnostics.Process.VirtualMemorySize64
  - System.Diagnostics.Process.WaitForExit
  - System.Diagnostics.Process.WaitForExit(System.Int32)
  - System.Diagnostics.Process.WaitForInputIdle
  - System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  - System.Diagnostics.Process.WorkingSet
  - System.Diagnostics.Process.WorkingSet64
  langs:
  - csharp
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
  type: Class
  summary: "Biedt toegang tot lokale en externe processen en kunt u starten en stoppen van lokaal systeemprocessen.       Om te bladeren naar de broncode van .NET Framework voor dit type, Zie de [Verwijzingsbron](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n A Process component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.  \n  \n The Process component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the Process component, to obtain a list of the processes that are running, or you can start a new process. A Process component is used to access system processes. After a Process component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.  \n  \n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n> [!NOTE]\n>  32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception. A 64-bit process, on the other hand, can access the modules of a 32-bit process.  \n  \n The process component obtains information about a group of properties all at once. After the Process component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method. The group breakdowns are operating-system dependent.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the Process component, even when the process has exited. Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.  \n  \n> [!NOTE]\n>  This class contains a link demand and an inheritance demand at the class level that applies to all members. A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see [Link Demands](~/add/includes/ajax-current-ext-md.md).  \n  \n<a name=\"Core\"></a>   \n## [!INCLUDE[net_core](~/add/includes/net-core-md.md)] Notes  \n In the .NET Framework on the desktop, the Process class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams. For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class. However, [!INCLUDE[net_core](~/add/includes/net-core-md.md)] may make only a limited subset of these encodings available. If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName> as the default encoding.  \n  \n If a Process object depends on specific code page encodings, you can still make them available by doing the following *before* you call any Process methods:  \n  \n1.  Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.  \n  \n2.  Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=fullName> property.  \n  \n3.  Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=fullName> method to make the additional encodings supported by the encoding provider available.  \n  \n The Process class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any Process methods."
  example:
  - "The following example uses an instance of the Process class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_1.cs)]  \n  \n The following example uses the Process class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_2.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_2.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_2.cpp)]  \n  \n The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.  The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.  \n  \n [!code-fs[System.Diagnostics.Process#1](~/add/codesnippet/fsharp/t-system.diagnostics.pro_1_3.fs)]  \n  \n The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](http://opensource.org/licenses/ms-pl)."
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Exited")]

      [System.ComponentModel.DefaultProperty("StartInfo")]

      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("ProcessDesc")]

      public class Process : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.Process.#ctor
  id: '#ctor'
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Diagnostics.Process&quot;> </xref> klasse."
  remarks: "Als u niet geeft de <xref:System.Diagnostics.Process.MachineName%2A>eigenschap, de standaardwaarde is de lokale computer (&quot;. &quot;).</xref:System.Diagnostics.Process.MachineName%2A>       Hebt u twee opties voor het koppelen van een nieuwe <xref:System.Diagnostics.Process>onderdeel met een proces op de computer.</xref:System.Diagnostics.Process> De eerste optie is om de constructor te maken de <xref:System.Diagnostics.Process>onderdeel, stel de juiste leden van de <xref:System.Diagnostics.Process.StartInfo%2A>eigenschap en aanroep <xref:System.Diagnostics.Process.Start%2A>koppelen de <xref:System.Diagnostics.Process>met een nieuwe systeemproces.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.Process> De tweede optie is het koppelen het <xref:System.Diagnostics.Process>met een actieve systeemproces via <xref:System.Diagnostics.Process.GetProcessById%2A>of een van de <xref:System.Diagnostics.Process.GetProcesses%2A>retourwaarden.</xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process>       Als u een `static` overbelasting van de <xref:System.Diagnostics.Process.Start%2A>methode om een nieuwe systeem in gang, de methode maakt u een nieuwe <xref:System.Diagnostics.Process>onderdeel en koppelt u deze met het proces.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>       Wanneer de <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>eigenschap is ingesteld op de standaardwaarde `true`, kunt u toepassingen en documenten starten op een manier die lijkt op de `Run` in het dialoogvenster van de Windows `Start` menu.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Wanneer <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>is `false`, kunt u beginnen met alleen uitvoerbare bestanden.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>       Uitvoerbare bestanden die u vanaf de opdrachtregel aanroepen kunt op twee manieren kan worden gestart: door de juiste leden van de <xref:System.Diagnostics.Process.StartInfo%2A>eigenschap en aanroepen de <xref:System.Diagnostics.Process.Start%2A>methode zonder parameters of door de juiste parameter voor de `static` <xref:System.Diagnostics.Process.Start%2A>lid.</xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A>       Kunt u een <xref:System.Diagnostics.Process>onderdeel met behulp van de constructor, een van de statische <xref:System.Diagnostics.Process.Start%2A>overloads of een van de <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, of <xref:System.Diagnostics.Process.GetProcessesByName%2A>methoden.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process> Als u dit hebt gedaan, hebt u een overzicht van het bijbehorende proces. Dit is niet een dynamische weergave die automatisch bijgewerkt wanneer de Proceseigenschappen van het in het geheugen zijn gewijzigd. In plaats daarvan moet u aanroepen <xref:System.Diagnostics.Process.Refresh%2A>voor het onderdeel om bij te werken de <xref:System.Diagnostics.Process>eigenschapsgegevens in uw toepassing.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  syntax:
    content: public Process ();
    parameters: []
  overload: System.Diagnostics.Process.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.BasePriority
  id: BasePriority
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de basisprioriteit van het bijbehorende proces."
  remarks: "De BasePriority van het proces is de eerste prioriteit voor de threads in het bijbehorende proces hebt gemaakt. U kunt informatie over de basisprioriteit via de Systeemmonitor prioriteit Basisteller weergeven.       Op basis van de tijd is verstreken of andere verhoogt, het besturingssysteem de basisprioriteit wijzigen kunnen als een proces moet worden geplaatst voor anderen.       De eigenschap BasePriority kunt u de eerste prioriteit toegewezen aan een proces weergeven. Omdat het kenmerk alleen-lezen, niet kunt u de BasePriority gebruiken om in te stellen de prioriteit van het proces. Als u wilt de prioriteit wilt wijzigen, gebruikt u de <xref:System.Diagnostics.Process.PriorityClass%2A>eigenschap.</xref:System.Diagnostics.Process.PriorityClass%2A> De BasePriority kunnen worden weergegeven met de Systeemmonitor, terwijl de <xref:System.Diagnostics.Process.PriorityClass%2A>niet.</xref:System.Diagnostics.Process.PriorityClass%2A> Zowel de BasePriority en de <xref:System.Diagnostics.Process.PriorityClass%2A>programmatisch kunnen worden bekeken.</xref:System.Diagnostics.Process.PriorityClass%2A> De volgende tabel ziet u de relatie tussen de waarden BasePriority en <xref:System.Diagnostics.Process.PriorityClass%2A>waarden.</xref:System.Diagnostics.Process.PriorityClass%2A>      | BasePriority | PriorityClass |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "De basisprioriteit wordt berekend op basis van de <xref:System.Diagnostics.Process.PriorityClass*>van het bijbehorende proces.</xref:System.Diagnostics.Process.PriorityClass*>"
  overload: System.Diagnostics.Process.BasePriority*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me); Stel de &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; eigenschap <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> voor toegang tot deze eigenschap in Windows 98 en Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces is afgesloten.       - of - het proces is niet gestart, dus er geen proces-ID is."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginErrorReadLine
  id: BeginErrorReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Asynchrone leesbewerkingen op de omgeleide begint <xref:System.Diagnostics.Process.StandardError*>stroom van de toepassing.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "De <xref:System.Diagnostics.Process.StandardError%2A>stroom kan worden gelezen synchroon of asynchroon.</xref:System.Diagnostics.Process.StandardError%2A> Methoden zoals <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, en <xref:System.IO.StreamReader.ReadToEnd%2A>synchrone leesbewerkingen op de uitvoerstroom fout van het proces uitvoeren.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Deze synchrone lezen bewerkingen niet voltooit tot de bijbehorende <xref:System.Diagnostics.Process>schrijft naar de <xref:System.Diagnostics.Process.StandardError%2A>streamen of de stroom wordt gesloten.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Daarentegen BeginErrorReadLine begint asynchrone leesbewerkingen op de <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> Deze methode kunt de aangewezen gebeurtenis-handler voor de Stroomuitvoer en retourneert onmiddellijk naar de aanroeper die andere taken uitvoeren kunt terwijl de Stroomuitvoer van de is omgeleid naar de gebeurtenis-handler.       Volg deze stappen voor het uitvoeren van asynchrone leesbewerkingen op <xref:System.Diagnostics.Process.StandardError%2A>voor een <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>      3.  De gebeurtenis-handler toevoegen de <xref:System.Diagnostics.Process.ErrorDataReceived>gebeurtenis.</xref:System.Diagnostics.Process.ErrorDataReceived> De gebeurtenis-handler moet overeenkomen met de <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>handtekening van gemachtigden.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Start de <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  BeginErrorReadLine niet aanroepen voor de <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Deze aanroep wordt gestart voor asynchrone leesbewerkingen op <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A>       Wanneer asynchrone leesbewerkingen start en de gebeurtenis-handler wordt aangeroepen wanneer de bijbehorende <xref:System.Diagnostics.Process>schrijft u een regel met tekst naar de <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       U kunt een asynchrone leesbewerking annuleren door het aanroepen van <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> De leesbewerking kan worden geannuleerd door de aanroeper of door de gebeurtenis-handler. Na het annuleren, roept u BeginErrorReadLine opnieuw uit om te hervatten asynchrone leesbewerkingen.      > [!NOTE] > U asynchrone als synchrone leesbewerkingen voor een omgeleide stroom niet door elkaar. Eenmaal op de omgeleide stroom van een <xref:System.Diagnostics.Process>wordt geopend in de synchrone of asynchrone modus alle verdere Lees bewerkingen in deze stroom moeten zich in dezelfde modus.</xref:System.Diagnostics.Process> Bijvoorbeeld, volg niet BeginErrorReadLine met een aanroep naar <xref:System.IO.StreamReader.ReadLine%2A>op de <xref:System.Diagnostics.Process.StandardError%2A>stream, of vice versa.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> U kunt echter twee verschillende stromen in verschillende modi lezen. Bijvoorbeeld: call BeginErrorReadLine en vervolgens aanroepen <xref:System.IO.StreamReader.ReadLine%2A>voor de <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/m-system.diagnostics.pro_4_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/m-system.diagnostics.pro_4_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_4_1.vb)]"
  syntax:
    content: public void BeginErrorReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginErrorReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardError*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardError*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginOutputReadLine
  id: BeginOutputReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Asynchrone leesbewerkingen op de omgeleide begint <xref:System.Diagnostics.Process.StandardOutput*>stroom van de toepassing.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "De <xref:System.Diagnostics.Process.StandardOutput%2A>stroom kan worden gelezen synchroon of asynchroon.</xref:System.Diagnostics.Process.StandardOutput%2A> Methoden zoals <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, en <xref:System.IO.StreamReader.ReadToEnd%2A>synchrone leesbewerkingen op de uitvoerstroom van het proces uitvoeren.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Deze synchrone lezen bewerkingen niet voltooit tot de bijbehorende <xref:System.Diagnostics.Process>schrijft naar de <xref:System.Diagnostics.Process.StandardOutput%2A>streamen of de stroom wordt gesloten.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Daarentegen BeginOutputReadLine begint asynchrone leesbewerkingen op de <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Deze methode kan een aangewezen gebeurtenis-handler voor de Stroomuitvoer van de en retourneert onmiddellijk naar de aanroeper die andere taken uitvoeren kunt terwijl de Stroomuitvoer van de is omgeleid naar de gebeurtenis-handler.       Volg deze stappen voor het uitvoeren van asynchrone leesbewerkingen op <xref:System.Diagnostics.Process.StandardOutput%2A>voor een <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>      3.  De gebeurtenis-handler toevoegen de <xref:System.Diagnostics.Process.OutputDataReceived>gebeurtenis.</xref:System.Diagnostics.Process.OutputDataReceived> De gebeurtenis-handler moet overeenkomen met de <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>handtekening van gemachtigden.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Start de <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  BeginOutputReadLine niet aanroepen voor de <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Deze aanroep wordt gestart voor asynchrone leesbewerkingen op <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A>       Wanneer asynchrone leesbewerkingen start en de gebeurtenis-handler wordt aangeroepen wanneer de bijbehorende <xref:System.Diagnostics.Process>schrijft u een regel met tekst naar de <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       U kunt een asynchrone leesbewerking annuleren door het aanroepen van <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> De leesbewerking kan worden geannuleerd door de aanroeper of door de gebeurtenis-handler. Na het annuleren, roept u BeginOutputReadLine opnieuw uit om te hervatten asynchrone leesbewerkingen.      > [!NOTE] > U asynchrone als synchrone leesbewerkingen voor een omgeleide stroom niet door elkaar. Eenmaal op de omgeleide stroom van een <xref:System.Diagnostics.Process>wordt geopend in de synchrone of asynchrone modus alle verdere Lees bewerkingen in deze stroom moeten zich in dezelfde modus.</xref:System.Diagnostics.Process> Bijvoorbeeld, volg niet BeginOutputReadLine met een aanroep naar <xref:System.IO.StreamReader.ReadLine%2A>op de <xref:System.Diagnostics.Process.StandardOutput%2A>stream, of vice versa.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A> U kunt echter twee verschillende stromen in verschillende modi lezen. Bijvoorbeeld: call BeginOutputReadLine en vervolgens aanroepen <xref:System.IO.StreamReader.ReadLine%2A>voor de <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command. The `sort` command is a console application that reads and sorts text input.  \n  \n The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.  \n  \n [!code-cpp[Process_AsyncStreams#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_13_1.cpp)]\n [!code-vb[Process_AsyncStreams#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_13_1.vb)]\n [!code-cs[Process_AsyncStreams#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_13_1.cs)]"
  syntax:
    content: public void BeginOutputReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginOutputReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardOutput*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardOutput*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelErrorRead
  id: CancelErrorRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Annuleert de asynchrone leesbewerking op de omgeleide <xref:System.Diagnostics.Process.StandardError*>stroom van een toepassing.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>Start een asynchrone leesbewerking op de <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A></xref:System.Diagnostics.Process.BeginErrorReadLine%2A> CancelErrorRead eindigt de asynchrone leesbewerking.       Na het annuleren, kunt u de asynchrone leesbewerking hervatten door het aanroepen van <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>opnieuw.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>       Wanneer u CancelErrorRead aanroept, status van alle bewerkingen voor lezen <xref:System.Diagnostics.Process.StandardError%2A>zijn voltooid en vervolgens de gebeurtenis-handler is uitgeschakeld.</xref:System.Diagnostics.Process.StandardError%2A> Alle uitvoer naar verdere omgeleid <xref:System.Diagnostics.Process.StandardError%2A>wordt opgeslagen in een buffer.</xref:System.Diagnostics.Process.StandardError%2A> Als u opnieuw met een aanroep naar de gebeurtenis-handler inschakelen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, de uitvoer van de opgeslagen wordt verzonden naar de gebeurtenis-handler en hervatten voor asynchrone leesbewerkingen.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Als u wijzigen van de gebeurtenis-handler wilt voor asynchrone leesbewerkingen hervatten, moet u de bestaande gebeurtenis-handler verwijderen voordat u de nieuwe gebeurtenis-handler toevoegt: ```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```       >  [!NOTE] > u niet door elkaar asynchrone als synchrone leesbewerkingen op de omgeleide <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> Eenmaal op de omgeleide stroom van een <xref:System.Diagnostics.Process>wordt geopend in de synchrone of asynchrone modus alle verdere Lees bewerkingen in deze stroom moeten zich in dezelfde modus.</xref:System.Diagnostics.Process> Als u annuleert een asynchrone leesbewerking op <xref:System.Diagnostics.Process.StandardError%2A>en vervolgens opnieuw te lezen uit de stroom, moet u moet <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>hervatten asynchrone leesbewerkingen.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process.StandardError%2A> Volg CancelErrorRead niet met een aanroep naar de synchrone lezen methoden van <xref:System.Diagnostics.Process.StandardError%2A>zoals <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, of <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardError%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_7_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_7_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_7_1.vb)]"
  syntax:
    content: public void CancelErrorRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelErrorRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De <xref:System.Diagnostics.Process.StandardError*>stroom is niet ingeschakeld voor asynchrone leesbewerkingen.</xref:System.Diagnostics.Process.StandardError*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelOutputRead
  id: CancelOutputRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Annuleert de asynchrone leesbewerking op de omgeleide <xref:System.Diagnostics.Process.StandardOutput*>stroom van een toepassing.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>Start een asynchrone leesbewerking op de <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A> CancelOutputRead eindigt de asynchrone leesbewerking.       U kunt na het annuleren, asynchrone leesbewerkingen hervatten door het aanroepen van <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>opnieuw.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>       Wanneer u CancelOutputRead aanroept, status van alle bewerkingen voor lezen <xref:System.Diagnostics.Process.StandardOutput%2A>zijn voltooid en vervolgens de gebeurtenis-handler is uitgeschakeld.</xref:System.Diagnostics.Process.StandardOutput%2A> Alle uitvoer naar verdere omgeleid <xref:System.Diagnostics.Process.StandardOutput%2A>wordt opgeslagen in een buffer.</xref:System.Diagnostics.Process.StandardOutput%2A> Als u opnieuw met een aanroep naar de gebeurtenis-handler inschakelen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, de opgeslagen uitvoer wordt verzonden naar de gebeurtenis-handler en hervatten voor asynchrone leesbewerkingen.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Als u wijzigen van de gebeurtenis-handler wilt voor asynchrone leesbewerkingen hervatten, moet u de bestaande gebeurtenis-handler verwijderen voordat u de nieuwe gebeurtenis-handler toevoegt: ```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```       >  [!NOTE] > u niet door elkaar asynchrone als synchrone leesbewerkingen op de omgeleide <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Eenmaal op de omgeleide stroom van een <xref:System.Diagnostics.Process>wordt geopend in de synchrone of asynchrone modus alle verdere Lees bewerkingen in deze stroom moeten zich in dezelfde modus.</xref:System.Diagnostics.Process> Als u annuleert een asynchrone leesbewerking op <xref:System.Diagnostics.Process.StandardOutput%2A>en vervolgens opnieuw te lezen uit de stroom, moet u moet <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>hervatten asynchrone leesbewerkingen.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> Volg CancelOutputRead niet met een aanroep naar de synchrone lezen methoden van <xref:System.Diagnostics.Process.StandardOutput%2A>zoals <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, of <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public void CancelOutputRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelOutputRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De <xref:System.Diagnostics.Process.StandardOutput*>stroom is niet ingeschakeld voor asynchrone leesbewerkingen.</xref:System.Diagnostics.Process.StandardOutput*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.Close
  id: Close
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Alle resources die gekoppeld aan dit onderdeel zijn maakt."
  remarks: "De methode Close zorgt ervoor dat het proces om te stoppen met wachten afsluiten als deze zich bevonden, sluit u de proceskoppeling en processpecifieke eigenschappen wist. Sluit sluit niet de standaard uitvoer, invoer- en foutberichten en schrijfprogramma geval zijn extern wordt verwezen.      > [!NOTE] > De <xref:System.Diagnostics.Process.Dispose%2A>methodeaanroepen sluiten.</xref:System.Diagnostics.Process.Dispose%2A> Plaatsing van de <xref:System.Diagnostics.Process>object in een `using` blok verwijdert bronnen zonder dat het nodig om aan te roepen sluit.</xref:System.Diagnostics.Process>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_0_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.Process.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.CloseMainWindow
  id: CloseMainWindow
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee sluit u een proces waarbij een gebruikersinterface heeft een afsluitbericht verzonden naar het hoofdvenster."
  remarks: "Wanneer een proces wordt uitgevoerd, is de berichtenlus van het in de status van een ogenblik geduld. De berichtenlus uitgevoerd telkens wanneer een Windows-bericht naar het proces is verzonden door het besturingssysteem. Het aanroepen van CloseMainWindow verzendt een aanvraag naar dicht bij het hoofdvenster van die in een goed ingedeelde toepassing onderliggende vensters sluit en trekt alle actieve bericht lussen voor de toepassing. De aanvraag om af te sluiten van het proces door het aanroepen van CloseMainWindow niet voor dat de toepassing af te sluiten. De toepassing voor gebruikersverificatie voordat u afsluit kunt vragen of hij kunt weigeren om af te sluiten. Als u wilt dat de toepassing af te sluiten, gebruikt u de <xref:System.Diagnostics.Process.Kill%2A>methode.</xref:System.Diagnostics.Process.Kill%2A> Het gedrag van CloseMainWindow is identiek aan die van een gebruiker via het systeemmenu voor hoofdvenster van de toepassing sluiten. De aanvraag om af te sluiten van het proces door te sluiten van het hoofdvenster dwingt daarom niet de toepassing onmiddellijk afgesloten.       Gegevens die door het proces is bewerkt of resources toegewezen aan het proces kunnen verloren gaan als u <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> aanroepen <xref:System.Diagnostics.Process.Kill%2A>zorgt ervoor dat een abnormale beëindigen en alleen indien nodig moet worden gebruikt.</xref:System.Diagnostics.Process.Kill%2A> CloseMainWindow Hiermee een geordende beëindiging van het proces en sluit alle vensters zodat het verdient de voorkeur voor toepassingen met een interface. Als CloseMainWindow mislukt, kunt u <xref:System.Diagnostics.Process.Kill%2A>het proces is beëindigd.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>is de enige manier om de processen die u geen grafische interfaces hebt wordt beëindigd.</xref:System.Diagnostics.Process.Kill%2A>       U kunt aanroepen <xref:System.Diagnostics.Process.Kill%2A>en CloseMainWindow alleen voor processen die worden uitgevoerd op de lokale computer.</xref:System.Diagnostics.Process.Kill%2A> Er kan geen processen op externe computers om af te sluiten. U kunt alleen gegevens weergeven voor processen die worden uitgevoerd op externe computers."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_18_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public bool CloseMainWindow ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als dit bericht is verzonden; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> als het bijbehorende proces geen een hoofdvenster heeft of als het hoofdvenster is uitgeschakeld (bijvoorbeeld als een modaal dialoogvenster wordt weergegeven)."
  overload: System.Diagnostics.Process.CloseMainWindow*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me); Stel de &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; eigenschap <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> voor toegang tot deze eigenschap in Windows 98 en Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces is al afgesloten.       - of - er is geen proces gekoppeld aan dit <xref href=&quot;System.Diagnostics.Process&quot;> </xref> object."
  platform:
  - net462
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Geeft alle resources die door dit proces gebruikt."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>voor het vrijgeven van zowel beheerde als onbeheerde hulpbronnen; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om alleen niet-beheerde bronnen vrij te geven."
  overload: System.Diagnostics.Process.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld of de <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> gebeurtenis moet worden verhoogd wanneer het proces wordt beëindigd."
  remarks: "De eigenschap EnableRaisingEvents geeft aan of het onderdeel moet worden gewaarschuwd wanneer het besturingssysteem een proces is afgesloten. De eigenschap EnableRaisingEvents wordt gebruikt bij het verwerken van asynchrone te melden van uw toepassing waarmee u een proces is afgesloten. Als u wilt afdwingen van uw toepassing synchroon wachttijd voor een gebeurtenis exit (die de verwerking van de toepassing wordt onderbroken totdat de afsluitcode gebeurtenis heeft plaatsgevonden), gebruiken de <xref:System.Diagnostics.Process.WaitForExit%2A>methode.</xref:System.Diagnostics.Process.WaitForExit%2A>      > [!NOTE] > Als u met behulp van Visual Studio en dubbelklik op een <xref:System.Diagnostics.Process>onderdeel in uw project een <xref:System.Diagnostics.Process.Exited>gebeurtenisgemachtigde en gebeurtenis-handler automatisch worden gegenereerd.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.Process> Aanvullende code stelt de eigenschap EnableRaisingEvents op `false`. U moet deze eigenschap te wijzigen `true` voor de gebeurtenis-handler moet worden uitgevoerd wanneer het bijbehorende proces is afgesloten.       Wanneer een bijbehorende proces bestaat na een afgesloten door het besturingssysteem hetzij via een gewone of abnormaal beëindigd, verschijnt het bericht elk procesonderdeel waarmee het proces gekoppeld is, zolang EnableRaisingEvents-waarde van het onderdeel is `true`. Als een onderdeel is het proces gestart, kan het onderdeel toegang krijgen tot de beheergegevens voor het bijbehorende proces dat is nog steeds door het besturingssysteem wordt opgeslagen. Deze informatie omvat de <xref:System.Diagnostics.Process.ExitTime%2A>, en de <xref:System.Diagnostics.Process.ExitCode%2A>.</xref:System.Diagnostics.Process.ExitCode%2A> </xref:System.Diagnostics.Process.ExitTime%2A>       Nadat het bijbehorende proces is afgesloten, wordt de <xref:System.Diagnostics.Process.Handle%2A>van het onderdeel niet meer verwijst naar een bestaande proces resource.</xref:System.Diagnostics.Process.Handle%2A> In plaats daarvan kan deze alleen worden gebruikt voor toegang tot informatie over de bron van het proces van het besturingssysteem. Het besturingssysteem is op de hoogte dat er ingangen naar afgesloten processen die niet zijn vrijgegeven zijn door <xref:System.Diagnostics.Process>onderdelen, zodat het zorgt ervoor dat de <xref:System.Diagnostics.Process.ExitTime%2A>en <xref:System.Diagnostics.Process.Handle%2A>gegevens uit het geheugen.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Er is een kosten in verband met het bekijken voor een proces om af te sluiten. Als EnableRaisingEvents `true`, wordt de <xref:System.Diagnostics.Process.Exited>gebeurtenis treedt op wanneer het bijbehorende proces wordt beëindigd.</xref:System.Diagnostics.Process.Exited> De procedures die u hebt opgegeven voor de <xref:System.Diagnostics.Process.Exited>gebeurtenis op dat moment worden uitgevoerd.</xref:System.Diagnostics.Process.Exited>       Soms wordt uw toepassing wordt gestart van een proces maar niet hoeft te worden gesteld van de sluiting. Uw toepassing kan bijvoorbeeld start Kladblok zodat de gebruiker om uit te voeren met het bewerken van tekst, maar er is geen verdere gebruik maken van de toepassing Kladblok. U kunt niet worden gewaarschuwd wanneer het proces is afgesloten, omdat deze niet relevant zijn voor de ononderbroken werking van uw toepassing. Als u EnableRaisingEvents op `false` systeembronnen worden opgeslagen."
  example:
  - "The following code example creates a process that prints a file. It sets the EnableRaisingEvents property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits. The <xref:System.Diagnostics.Process.Exited> event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_38_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_38_1.cs)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> gebeurtenis moet worden geactiveerd wanneer het bijbehorende proces wordt beëindigd (via een afsluiten of een aanroep van <xref:System.Diagnostics.Process.Kill*>); anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.Kill*> De standaardwaarde is <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.EnableRaisingEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnterDebugMode
  id: EnterDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Plaatst een <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel in staat om te communiceren met het besturingssysteem verwerkt die in een speciale modus worden uitgevoerd door het inschakelen van de eigenschap native <xref uid=&quot;langword_csharp_SeDebugPrivilege&quot; name=&quot;SeDebugPrivilege&quot; href=&quot;&quot;> </xref> in de huidige thread."
  remarks: "Sommige besturingssysteem worden uitgevoerd in een speciale modus. Bij het lezen van de eigenschappen van of koppelen aan deze processen is niet mogelijk tenzij u EnterDebugMode voor het onderdeel hebt aangeroepen. Roep <xref:System.Diagnostics.Process.LeaveDebugMode%2A>Wanneer u niet langer toegang tot deze processen die in een speciale modus worden uitgevoerd.</xref:System.Diagnostics.Process.LeaveDebugMode%2A>"
  syntax:
    content: public static void EnterDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.EnterDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ErrorDataReceived
  id: ErrorDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Deze gebeurtenis treedt op wanneer een toepassing naar de omgeleide schrijft <xref:System.Diagnostics.Process.StandardError*>stream.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "De gebeurtenis ErrorDataReceived geeft aan dat het bijbehorende proces is geschreven naar de omgeleide <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A>       De gebeurtenis vindt alleen plaats tijdens asynchrone leesbewerkingen op <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A> Voor asynchrone leesbewerkingen begint, moet u de <xref:System.Diagnostics.Process.StandardError%2A>stroom van <xref:System.Diagnostics.Process>de gebeurtenis-handler voor de gebeurtenis ErrorDataReceived toe en roep <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> omleiden Daarna wordt de ErrorDataReceived gebeurtenis signalen telkens wanneer het proces schrijft een regel op de omgeleide <xref:System.Diagnostics.Process.StandardError%2A>stream, totdat het proces wordt afgesloten of aanroepen <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> </xref:System.Diagnostics.Process.StandardError%2A>      > [!NOTE] > De toepassing die wordt verwerkt door de uitvoer van de asynchrone aanroep moet de <xref:System.Diagnostics.Process.WaitForExit%2A>methode om ervoor te zorgen dat de uitvoerbuffer is leeggemaakt.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/e-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/e-system.diagnostics.pro_0_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitCode
  id: ExitCode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee wordt de waarde die het bijbehorende proces opgegeven wanneer het proces beëindigd."
  remarks: "ExitCode gebruiken om de status die het systeemproces geretourneerd wanneer deze is afgesloten. U kunt de afsluitcode veel zoals een geheel getal retourneert de waarde van een `main()` procedure.       De waarde ExitCode voor een proces geeft de specifieke overeenkomst geïmplementeerd door de ontwikkelaar van de toepassing voor dit proces. Als u de afsluitcodewaarde om beslissingen te nemen in uw code gebruikt, moet u dat u weet dat de afsluitcode code overeenkomst die wordt gebruikt door het toepassingsproces.       Ontwikkelaars meestal duiden op een geslaagde afsluiten door een waarde van nul ExitCode en fouten aanwijzen door andere waarden dan nul die de aangeroepen methode gebruiken kunt om de oorzaak van een proces abnormale beëindiging te identificeren. Het is niet nodig dat u deze richtlijnen, maar ze zijn van de overeenkomst.       Als u probeert te krijgen van de afsluitcode voordat het proces is afgesloten, er een poging een uitzondering gegenereerd. Bekijk de <xref:System.Diagnostics.Process.HasExited%2A>eigenschap eerst om te controleren of het bijbehorende proces is beëindigd.</xref:System.Diagnostics.Process.HasExited%2A>      > [!NOTE] > Als standaarduitvoer wordt omgeleid naar de asynchrone gebeurtenis-handlers, is het mogelijk dat de verwerking van de uitvoer wordt niet hebt voltooid wanneer <xref:System.Diagnostics.Process.HasExited%2A>retourneert `true`.</xref:System.Diagnostics.Process.HasExited%2A> Roep de <xref:System.Diagnostics.Process.WaitForExit>overbelasting waarvoor geen parameter voordat u controleert <xref:System.Diagnostics.Process.HasExited%2A>.</xref:System.Diagnostics.Process.HasExited%2A> zijn vereist</xref:System.Diagnostics.Process.WaitForExit> om ervoor te zorgen dat asynchrone verwerking is voltooid,       U kunt de <xref:System.Diagnostics.Process.CloseMainWindow%2A>of de <xref:System.Diagnostics.Process.Kill%2A>methode om te leiden tot een bijbehorende proces om af te sluiten.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A>       Er zijn twee manieren om gewaarschuwd als het bijbehorende proces wordt afgesloten: synchroon en asynchroon. Synchrone melding is afhankelijk van de aanroepen van de <xref:System.Diagnostics.Process.WaitForExit%2A>methode voor het verwerken van uw toepassing wacht totdat de bijbehorende component wordt afgesloten.</xref:System.Diagnostics.Process.WaitForExit%2A> Asynchrone melding is afhankelijk van de <xref:System.Diagnostics.Process.Exited>gebeurtenis.</xref:System.Diagnostics.Process.Exited> Bij gebruik van asynchrone melding <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>moet worden ingesteld op `true` voor de <xref:System.Diagnostics.Process>onderdeel van het bericht aangegeven dat het proces is afgesloten.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.EnableRaisingEvents%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_6_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_6_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_6_1.vb)]"
  syntax:
    content: public int ExitCode { get; }
    return:
      type: System.Int32
      description: "De code die het bijbehorende proces opgegeven wanneer het proces beëindigd."
  overload: System.Diagnostics.Process.ExitCode*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces is niet afgesloten.       - of - het proces <xref:System.Diagnostics.Process.Handle*>is niet geldig.</xref:System.Diagnostics.Process.Handle*>"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap ExitCode voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.Exited
  id: Exited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Deze gebeurtenis treedt op wanneer een proces wordt afgesloten."
  remarks: "De gebeurtenis Exited geeft aan dat het bijbehorende proces is afgesloten. Dit exemplaar betekent die het proces beëindigd (afgebroken) of is gesloten. Deze gebeurtenis kan optreden als de waarde van de <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>eigenschap is `true`.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Er zijn twee manieren om gewaarschuwd als het bijbehorende proces wordt afgesloten: synchroon en asynchroon. Synchrone kennisgeving aanroepen: de <xref:System.Diagnostics.Process.WaitForExit%2A>methode de huidige thread blokkeren totdat het proces wordt afgesloten.</xref:System.Diagnostics.Process.WaitForExit%2A> De gebeurtenis Exited, waardoor de aanroepende thread op uitvoering in de tussentijd maakt gebruik van asynchrone melding. In het laatste geval <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>moet worden ingesteld op `true` voor de aanroepende toepassing voor het ontvangen van de gebeurtenis Exited.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Wanneer het besturingssysteem een proces wordt afgesloten, informeert het andere processen die handlers voor de gebeurtenis Exited hebt geregistreerd. Op dit moment de ingang van het proces dat zojuist is afgesloten kan worden gebruikt voor toegang tot sommige eigenschappen zoals <xref:System.Diagnostics.Process.ExitTime%2A>en <xref:System.Diagnostics.Process.HasExited%2A>dat het besturingssysteem behoudt totdat deze volledig die ingang loslaat.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.ExitTime%2A>      > [!NOTE] > Zelfs als er een ingang naar een afgesloten proces, u niet aanroepen <xref:System.Diagnostics.Process.Start%2A>opnieuw naar de nieuwe verbinding maken met hetzelfde proces.</xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Start%2A>Automatisch het bijbehorende proces releases en maakt verbinding met een proces met hetzelfde bestand, maar een geheel nieuwe <xref:System.Diagnostics.Process.Handle%2A>.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.Start%2A> aanroepen       Zie voor meer informatie over het gebruik van de gebeurtenis Exited in Windows Forms-toepassingen, de <xref:System.Diagnostics.Process.SynchronizingObject%2A>eigenschap.</xref:System.Diagnostics.Process.SynchronizingObject%2A>"
  example:
  - "The following code example creates a process that prints a file. It raises the Exited event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created. The Exited event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_1_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/e-system.diagnostics.pro_1_1.cs)]"
  syntax:
    content: public event EventHandler Exited;
    return:
      type: System.EventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitTime
  id: ExitTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de tijd die het bijbehorende proces is afgesloten."
  remarks: "Als het proces is niet beëindigd er bij het ophalen van de eigenschap ExitTime een uitzondering gegenereerd. Gebruik <xref:System.Diagnostics.Process.HasExited%2A>voordat u de eigenschap ExitTime om te bepalen of het bijbehorende proces is beëindigd.</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example creates a process that prints a file. The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the ExitTime property and other process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_14_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public DateTime ExitTime { get; }
    return:
      type: System.DateTime
      description: "Een <xref:System.DateTime>die aangeeft wanneer het bijbehorende proces is beëindigd.</xref:System.DateTime>"
  overload: System.Diagnostics.Process.ExitTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap ExitTime voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetCurrentProcess
  id: GetCurrentProcess
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een nieuwe opgehaald <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel en koppelt u deze met het actieve proces."
  remarks: "Gebruik deze methode voor het maken van een nieuwe <xref:System.Diagnostics.Process>-instantie en deze koppelen aan de bron van het proces op de lokale computer.</xref:System.Diagnostics.Process>       Als de vergelijkbare <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, en <xref:System.Diagnostics.Process.GetProcesses%2A>methoden, GetCurrentProcess een bestaande resource koppelt aan een nieuwe <xref:System.Diagnostics.Process>onderdeel.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetCurrentProcess ();
    parameters: []
    return:
      type: System.Diagnostics.Process
      description: "Een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel gekoppeld aan de proces-resource die de aanroepende toepassing wordt uitgevoerd."
  overload: System.Diagnostics.Process.GetCurrentProcess*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  id: GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Retourneert een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel, krijgen de id van een proces op de lokale computer."
  remarks: "Gebruik deze methode voor het maken van een nieuwe <xref:System.Diagnostics.Process>onderdeel en deze koppelen aan een resource van het proces op de lokale computer.</xref:System.Diagnostics.Process> De proces-bron moet al bestaan op de computer, omdat GetProcessById een systeembron niet maakt, maar in plaats daarvan wordt gekoppeld aan een resource met een toepassing gegenereerde <xref:System.Diagnostics.Process>onderdeel.</xref:System.Diagnostics.Process> Een proces <xref:System.Diagnostics.Process.Id%2A>alleen voor een proces die momenteel wordt uitgevoerd op de computer kan worden opgehaald.</xref:System.Diagnostics.Process.Id%2A> Nadat het proces is beëindigd, genereert GetProcessById een uitzondering als u gebruikmaakt van een id verlopen.       De id van een proces is op een bepaalde computer, uniek zijn. GetProcessById retourneert hooguit één proces. Als u wilt ophalen van alle processen die een bepaalde toepassing uitvoert, gebruikt u <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Als meerdere processen op de computer met de opgegeven toepassing bestaat <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>retourneert een matrix met de bijbehorende processen.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> U kunt elk van deze processen op zijn beurt voor de id opvragen. De proces-id kan worden weergegeven in de `Processes` Configuratiescherm van Windows Taakbeheer. De `PID` kolom wordt de proces-id die is toegewezen aan een proces weergegeven."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_19_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_19_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_19_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId);
    parameters:
    - id: processId
      type: System.Int32
      description: "De systeem-unieke id van de bron van een proces."
    return:
      type: System.Diagnostics.Process
      description: "Een <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel dat is gekoppeld aan de bron lokaal proces is geïdentificeerd door de <code> processId </code> parameter."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Het proces dat is opgegeven door de <code> processId </code> parameter wordt niet uitgevoerd. De id kan zijn verlopen."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces is niet gestart door dit object."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  id: GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Retourneert een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel, een proces-id en de naam van een computer op het netwerk worden gegeven."
  remarks: "Gebruik deze methode voor het maken van een nieuwe <xref:System.Diagnostics.Process>onderdeel en deze koppelen aan een resource van het proces op een externe computer op het netwerk.</xref:System.Diagnostics.Process> De proces-bron moet al bestaan op de opgegeven computer omdat GetProcessById een systeembron niet maakt, maar in plaats daarvan koppelt u een resource met een toepassing gegenereerde <xref:System.Diagnostics.Process>onderdeel.</xref:System.Diagnostics.Process> Een proces <xref:System.Diagnostics.Process.Id%2A>alleen voor een proces die momenteel wordt uitgevoerd op de computer kan worden opgehaald.</xref:System.Diagnostics.Process.Id%2A> Nadat het proces is beëindigd, genereert GetProcessById een uitzondering als u gebruikmaakt van een id verlopen.       De id van een proces is op een bepaalde computer, uniek zijn. GetProcessById retourneert hooguit één proces. Als u wilt ophalen van alle processen die een bepaalde toepassing uitvoert, gebruikt u <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Als meerdere processen op de computer met de opgegeven toepassing bestaat <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>retourneert een matrix met de bijbehorende processen.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> U kunt elk van deze processen op zijn beurt voor de id opvragen. De proces-id kan worden weergegeven in de `Processes` Configuratiescherm van Windows Taakbeheer. De `PID` kolom wordt de proces-id die is toegewezen aan een proces weergegeven.       Als u geen opgeeft een `machineName`, de lokale computer wordt gebruikt. U kunt ook de lokale computer opgeven door in te stellen `machineName` op de waarde &quot;. &quot; of een lege tekenreeks (&quot;&quot;)."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_8_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_8_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_8_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId, string machineName);
    parameters:
    - id: processId
      type: System.Int32
      description: "De systeem-unieke id van de bron van een proces."
    - id: machineName
      type: System.String
      description: "De naam van een computer op het netwerk."
    return:
      type: System.Diagnostics.Process
      description: "Een <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel dat is gekoppeld aan een extern proces resource met de <code> processId </code> parameter."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Het proces dat is opgegeven door de <code> processId </code> parameter wordt niet uitgevoerd. De id kan zijn verlopen.       - of - de <code> machineName </code> syntaxis van de parameter is ongeldig. De naam van de wellicht lengte nul (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces is niet gestart door dit object."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses
  id: GetProcesses
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Maakt een nieuw <xref href=&quot;System.Diagnostics.Process&quot;> </xref> component voor elke resource proces op de lokale computer."
  remarks: "Deze methode gebruiken voor het maken van een matrix van nieuwe <xref:System.Diagnostics.Process>onderdelen en deze koppelt met de proces-resources op de lokale computer.</xref:System.Diagnostics.Process> De proces-resources moeten al bestaan op de lokale computer omdat GetProcesses geen systeembronnen maken, maar in plaats daarvan koppelt u resources met de toepassing gegenereerde <xref:System.Diagnostics.Process>onderdelen.</xref:System.Diagnostics.Process> Omdat het besturingssysteem zelf wordt achtergrondprocessen uitgevoerd, is deze matrix nooit leeg.       Als u niet ophalen van alle processen die worden uitgevoerd op de computer wilt, kunt u hun aantal beperken met behulp van de <xref:System.Diagnostics.Process.GetProcessById%2A>of <xref:System.Diagnostics.Process.GetProcessesByName%2A>methode.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>maakt een <xref:System.Diagnostics.Process>onderdeel dat is gekoppeld aan het proces op het systeem wordt geïdentificeerd door de proces-id die u aan de methode doorgeeft.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>maakt een matrix van <xref:System.Diagnostics.Process>onderdelen waarvan u de bijbehorende proces bronnen het uitvoerbare bestand delen dat u doorgeeft aan de methode.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>      > [!NOTE] > Meerdere Windows-services kunnen worden geladen in hetzelfde exemplaar van het ServiceHost-proces (svchost.exe). GetProcesses niet geïdentificeerd die afzonderlijke services; Zie <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_15_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_15_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_15_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses ();
    parameters: []
    return:
      type: System.Diagnostics.Process[]
      description: "Een matrix van het type <xref href=&quot;System.Diagnostics.Process&quot;> </xref> die staat voor alle proces resources die worden uitgevoerd op de lokale computer."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  id: GetProcesses(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Maakt een nieuw <xref href=&quot;System.Diagnostics.Process&quot;> </xref> component voor elke resource proces op de opgegeven computer."
  remarks: "Deze methode gebruiken voor het maken van een matrix van nieuwe <xref:System.Diagnostics.Process>onderdelen en deze koppelt met de proces-resources op de opgegeven computer (meestal extern).</xref:System.Diagnostics.Process> De proces-resources moeten al bestaan op de lokale computer omdat <xref:System.Diagnostics.Process.GetProcesses%2A>geen systeembronnen maken, maar in plaats daarvan koppelt u resources met de toepassing gegenereerde <xref:System.Diagnostics.Process>onderdelen.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> Omdat het besturingssysteem zelf wordt achtergrondprocessen uitgevoerd, is deze matrix nooit leeg.       Als u niet ophalen van alle processen die worden uitgevoerd op de computer wilt, kunt u hun aantal beperken met behulp van de <xref:System.Diagnostics.Process.GetProcessById%2A>of <xref:System.Diagnostics.Process.GetProcessesByName%2A>methode.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>maakt een <xref:System.Diagnostics.Process>onderdeel dat is gekoppeld aan het proces op het systeem wordt geïdentificeerd door de proces-id die u aan de methode doorgeeft.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>maakt een matrix van <xref:System.Diagnostics.Process>onderdelen waarvan u de bijbehorende proces bronnen het uitvoerbare bestand delen dat u doorgeeft aan de methode.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>       Deze overbelasting van de <xref:System.Diagnostics.Process.GetProcesses%2A>methode wordt doorgaans gebruikt voor het ophalen van de lijst met resources van proces uitgevoerd op een externe computer op het netwerk, maar u kunt de lokale computer opgeven door &quot;. &quot;.</xref:System.Diagnostics.Process.GetProcesses%2A>      > [!NOTE] > Meerdere Windows-services kunnen worden geladen in hetzelfde exemplaar van het ServiceHost-proces (svchost.exe). GetProcesses niet geïdentificeerd die afzonderlijke services; Zie <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_11_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_11_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "De computer van waaruit de lijst met processen te lezen."
    return:
      type: System.Diagnostics.Process[]
      description: "Een matrix van het type <xref href=&quot;System.Diagnostics.Process&quot;> </xref> die staat voor alle proces resources die worden uitgevoerd op de opgegeven computer."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De <code> machineName </code> syntaxis van de parameter is ongeldig. Het is wellicht lengte nul (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform van het besturingssysteem biedt geen ondersteuning voor deze bewerking op externe computers."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er zijn problemen met het openen van het prestatiemeteritem-API&quot;s gebruikt om op te halen van de procesinformatie. Deze uitzondering is specifiek voor Windows NT, Windows 2000 en Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Er is een probleem opgetreden bij toegang tot een onderliggende API-systeem."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  id: GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Maakt een matrix van nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdelen en koppelt u ze aan alle proces resources op de lokale computer die de opgegeven procesnaam delen."
  remarks: "Deze methode gebruiken voor het maken van een matrix van nieuwe <xref:System.Diagnostics.Process>onderdelen en alle resources van proces met hetzelfde uitvoerbare bestand op de lokale computer koppelen.</xref:System.Diagnostics.Process> De proces-resources moeten al bestaan op de computer, omdat GetProcessesByName geen systeembronnen maken, maar wordt deze in plaats daarvan gekoppeld aan de toepassing gegenereerde <xref:System.Diagnostics.Process>onderdelen.</xref:System.Diagnostics.Process> Een `processName` kan worden opgegeven voor een uitvoerbaar bestand dat niet wordt uitgevoerd op de lokale computer, zodat de matrix de methode retourneert kan niet leeg zijn.       De procesnaam is een beschrijvende naam voor het proces, zoals Outlook, dat de extensie .exe of het pad niet omvat. GetProcessesByName is handig voor het ophalen van en de processen die gekoppeld aan hetzelfde uitvoerbare bestand zijn bewerken. Bijvoorbeeld, geeft u de naam van een uitvoerbaar bestand als de `processName` parameter om alle actieve exemplaren van het uitvoerbare bestand afgesloten.       Hoewel een proces <xref:System.Diagnostics.Process.Id%2A>is uniek is voor een enkel proces resource op het systeem, meerdere processen op de lokale computer kunnen worden uitgevoerd de toepassing die is opgegeven door de `processName` parameter.</xref:System.Diagnostics.Process.Id%2A> Daarom <xref:System.Diagnostics.Process.GetProcessById%2A>retourneert één proces hoogstens maar GetProcessesByName retourneert een matrix met de bijbehorende processen.</xref:System.Diagnostics.Process.GetProcessById%2A> Als u bewerken van het proces met standaard API-aanroepen wilt, kunt u elk van deze processen op zijn beurt voor de id opvragen. U geen toegang tot Proces bronnen met alleen de procesnaam van het, maar wanneer u een matrix van hebt opgehaald <xref:System.Diagnostics.Process>onderdelen die gekoppeld zijn met de proces-bronnen, kunt u starten, beëindigen en manipuleren anders de systeembronnen.</xref:System.Diagnostics.Process>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_6_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_6_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_6_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName);
    parameters:
    - id: processName
      type: System.String
      description: "De beschrijvende naam van het proces."
    return:
      type: System.Diagnostics.Process[]
      description: "Een matrix van het type <xref href=&quot;System.Diagnostics.Process&quot;> </xref> die staat voor de proces-resources met de opgegeven toepassing of bestand."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er zijn problemen met het openen van het prestatiemeteritem-API&quot;s gebruikt om op te halen van de procesinformatie. Deze uitzondering is specifiek voor Windows NT, Windows 2000 en Windows XP."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  id: GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Maakt een matrix van nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdelen en koppelt u ze aan alle proces bronnen op een externe computer die de opgegeven procesnaam delen."
  remarks: "Deze methode gebruiken voor het maken van een matrix van nieuwe <xref:System.Diagnostics.Process>onderdelen en alle resources van proces met hetzelfde uitvoerbare bestand op de opgegeven computer koppelen.</xref:System.Diagnostics.Process> De proces-resources moeten al bestaan op de computer, omdat <xref:System.Diagnostics.Process.GetProcessesByName%2A>geen systeembronnen maken, maar wordt deze in plaats daarvan gekoppeld aan de toepassing gegenereerde <xref:System.Diagnostics.Process>onderdelen.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcessesByName%2A> Een `processName` kan worden opgegeven voor een uitvoerbaar bestand dat niet wordt uitgevoerd op de lokale computer, zodat de matrix de methode retourneert kan niet leeg zijn.       De procesnaam is een beschrijvende naam voor het proces, zoals Outlook, dat de extensie .exe of het pad niet omvat. <xref:System.Diagnostics.Process.GetProcessesByName%2A>is handig voor het ophalen van en de processen die gekoppeld aan hetzelfde uitvoerbare bestand zijn bewerken.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Bijvoorbeeld, geeft u de naam van een uitvoerbaar bestand als de `processName` parameter om alle actieve exemplaren van het uitvoerbare bestand afgesloten.       Hoewel een proces <xref:System.Diagnostics.Process.Id%2A>is uniek is voor een enkel proces resource op het systeem, meerdere processen op de lokale computer kunnen worden uitgevoerd de toepassing die is opgegeven door de `processName` parameter.</xref:System.Diagnostics.Process.Id%2A> Daarom <xref:System.Diagnostics.Process.GetProcessById%2A>hoogstens één proces retourneert maar <xref:System.Diagnostics.Process.GetProcessesByName%2A>retourneert een matrix met de bijbehorende processen.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> Als u bewerken van het proces met standaard API-aanroepen wilt, kunt u elk van deze processen op zijn beurt voor de id opvragen. U geen toegang tot Proces bronnen met alleen de procesnaam van het, maar wanneer u een matrix van hebt opgehaald <xref:System.Diagnostics.Process>onderdelen die gekoppeld zijn met de proces-bronnen, kunt u starten, beëindigen en manipuleren anders de systeembronnen.</xref:System.Diagnostics.Process>       U kunt deze overbelasting gebruiken om op te halen van processen op de lokale computer, evenals op een externe computer. Gebruik &quot;. &quot; om op te geven van de lokale computer. Er bestaat een andere overload die maakt standaard gebruik van de lokale computer.       U kunt toegang tot processen op externe computers alleen om informatie te bekijken, zoals statistieken over de processen. U kan niet sluiten, beëindigd (met behulp van <xref:System.Diagnostics.Process.Kill%2A>), of start u processen op externe computers.</xref:System.Diagnostics.Process.Kill%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_14_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_14_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);
    parameters:
    - id: processName
      type: System.String
      description: "De beschrijvende naam van het proces."
    - id: machineName
      type: System.String
      description: "De naam van een computer op het netwerk."
    return:
      type: System.Diagnostics.Process[]
      description: "Een matrix van het type <xref href=&quot;System.Diagnostics.Process&quot;> </xref> die staat voor de proces-resources met de opgegeven toepassing of bestand."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De <code> machineName </code> syntaxis van de parameter is ongeldig. Het is wellicht lengte nul (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform van het besturingssysteem biedt geen ondersteuning voor deze bewerking op externe computers."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er zijn problemen met het openen van het prestatiemeteritem-API&quot;s gebruikt om op te halen van de procesinformatie. Deze uitzondering is specifiek voor Windows NT, Windows 2000 en Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Er is een probleem opgetreden bij toegang tot een onderliggende API-systeem."
  platform:
  - net462
- uid: System.Diagnostics.Process.Handle
  id: Handle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de systeemeigen koppeling van het bijbehorende proces."
  remarks: "Een toepassing kan een ingang naar een proces dat kan worden gebruikt als een parameter voor een groot aantal functies voor procesinformatie en controle kunt verkrijgen. U kunt deze ingang worden geïnitialiseerd een <xref:System.Threading.WaitHandle>of aan te roepen systeemeigen methoden met platform-aanroep.</xref:System.Threading.WaitHandle>       De procesingang van dit is privé voor een toepassing--met andere woorden, proces ingangen kunnen niet worden gedeeld. Een proces heeft ook een proces <xref:System.Diagnostics.Process.Id%2A>die, in tegenstelling tot de ingang is uniek en daarom geldig in het hele systeem.</xref:System.Diagnostics.Process.Id%2A>       Alleen processen die zijn gestart door een aanroep van <xref:System.Diagnostics.Process.Start%2A>Stel de eigenschap ingang van de bijbehorende <xref:System.Diagnostics.Process>exemplaren.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>"
  syntax:
    content: public IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "De koppeling die het besturingssysteem die is toegewezen aan het bijbehorende proces wanneer het proces is gestart. Deze koppeling gebruikt door het systeem voor het bijhouden van proces kenmerken."
  overload: System.Diagnostics.Process.Handle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces is niet gestart of is afgesloten. De eigenschap ingang kan niet worden gelezen omdat er geen methode die is gekoppeld aan dit is <xref href=&quot;System.Diagnostics.Process&quot;> </xref> exemplaar.       - of - de <xref href=&quot;System.Diagnostics.Process&quot;> </xref> exemplaar is gekoppeld aan een proces dat wordt uitgevoerd, maar u hebt niet de vereiste machtigingen om het ophalen van een koppeling met volledige toegangsrechten."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap ingang voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.HandleCount
  id: HandleCount
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u het aantal ingangen geopend door het proces."
  remarks: "Ingangen bieden een manier om een proces voor het verwijzen naar objecten. Een proces kan verkrijgen ingangen naar bestanden, bronnen, berichtenwachtrijen en veel andere objecten van besturingssysteem. Het besturingssysteem haalt het geheugen dat is gekoppeld aan het proces alleen wanneer het aantal ingangen gelijk is aan nul."
  syntax:
    content: public int HandleCount { get; }
    return:
      type: System.Int32
      description: "Het aantal ingangen van besturingssysteem die het proces is geopend."
  overload: System.Diagnostics.Process.HandleCount*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me); Stel de &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; eigenschap <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> voor toegang tot deze eigenschap in Windows 98 en Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.HasExited
  id: HasExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Haalt een waarde die aangeeft of het bijbehorende proces is beëindigd."
  remarks: "Een waarde van `true` voor HasExited geeft aan dat het bijbehorende proces is beëindigd, normaal of abnormaal. U kunt aanvragen of het bijbehorende proces om af te sluiten door aan te roepen <xref:System.Diagnostics.Process.CloseMainWindow%2A>of <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> forceren Als een greep voor het proces is, wordt door het besturingssysteem het procesgeheugen versies wanneer het proces is afgesloten, maar administratieve informatie over het proces, zoals de ingang, afsluitcode en afsluiten tijd behoudt. Als u deze informatie, kunt u de <xref:System.Diagnostics.Process.ExitCode%2A>en <xref:System.Diagnostics.Process.ExitTime%2A>Eigenschappen.</xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process.ExitCode%2A> Deze eigenschappen worden automatisch ingevuld voor processen die zijn gestart door dit onderdeel. De administratieve informatie wordt vrijgegeven wanneer alle de <xref:System.Diagnostics.Process>onderdelen die gekoppeld aan het systeemproces zijn vernietigd en niet meer handles houdt met het proces van afgesloten.</xref:System.Diagnostics.Process>       Een proces kan worden beëindigd, onafhankelijk van uw code. Als u het proces met dit onderdeel is gestart, het systeem de waarde van HasExited automatisch bijgewerkt, zelfs als het bijbehorende proces onafhankelijk wordt afgesloten.      > [!NOTE] > Als standaarduitvoer wordt omgeleid naar de asynchrone gebeurtenis-handlers, is het mogelijk dat de verwerking van de uitvoer niet hebt voltooid als deze eigenschap de waarde `true`. Om ervoor te zorgen dat asynchrone verwerking is voltooid, Roep de <xref:System.Diagnostics.Process.WaitForExit>overbelasting waarvoor geen parameter voordat HasExited gecontroleerd.</xref:System.Diagnostics.Process.WaitForExit>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_33_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_33_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_33_1.vb)]"
  syntax:
    content: public bool HasExited { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het proces van het besturingssysteem waarnaar wordt verwezen door de <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel is beëindigd; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.HasExited*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er is geen methode die is gekoppeld aan het object."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "De afsluitcode voor het proces kan niet worden opgehaald."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap HasExited voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.Id
  id: Id
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee wordt de unieke id voor het bijbehorende proces."
  remarks: "Het proces-Id is niet geldig als het bijbehorende proces niet wordt uitgevoerd. Daarom moet u ervoor zorgen dat het proces wordt uitgevoerd voordat u probeert om op te halen van de eigenschap Id. Totdat het proces wordt beëindigd, kunt u de proces-id een unieke identificatie van het proces in het hele systeem.       U kunt verbinding maken voor een proces dat wordt uitgevoerd op een lokale of externe computer naar een nieuwe <xref:System.Diagnostics.Process>exemplaar door het doorgeven van de proces-id voor de <xref:System.Diagnostics.Process.GetProcessById%2A>methode.</xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.GetProcessById%2A>is een `static` methode die u maakt een nieuw onderdeel en stelt u de eigenschap Id voor de nieuwe <xref:System.Diagnostics.Process>automatisch-instantie.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A>       Proces-id&quot;s opnieuw worden gebruikt door het systeem. De eigenschap id-waarde is uniek alleen terwijl het bijbehorende proces wordt uitgevoerd. Nadat het proces is beëindigd, kunt het systeem de waarde van de Id-eigenschap voor een niet-verwante proces hergebruiken.       Omdat de id uniek zijn in het systeem is, kunt u deze doorgeven aan andere threads als alternatief voor het doorgeven van een <xref:System.Diagnostics.Process>exemplaar.</xref:System.Diagnostics.Process> Deze actie kunt systeembronnen opslaan terwijl garanderen dat het proces is geïdentificeerd."
  example:
  - "The following example demonstrates how to obtain the Id for all running instances of an application. The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the Id number to remove a specific instance.  \n  \n [!code-cs[System.Diagnostics.Process.Id#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_36_1.cs)]\n [!code-vb[System.Diagnostics.Process.Id#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_36_1.vb)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Het systeem gegenereerde unieke id van het proces dat wordt verwezen door dit <xref href=&quot;System.Diagnostics.Process&quot;> </xref> exemplaar."
  overload: System.Diagnostics.Process.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De eigenschap Id van het proces is niet ingesteld.       - of - er is geen methode die is gekoppeld aan dit <xref href=&quot;System.Diagnostics.Process&quot;> </xref> object."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me); Stel de &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; eigenschap <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> voor toegang tot deze eigenschap in Windows 98 en Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.Kill
  id: Kill
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Onmiddellijk stopt het bijbehorende proces."
  remarks: "Kill forceert een beëindiging van het proces terwijl <xref:System.Diagnostics.Process.CloseMainWindow%2A>alleen aanvragen van een beëindiging.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Bij het uitvoeren van een proces met een grafische interface, is de berichtenlus in de status van een ogenblik geduld. De berichtenlus uitgevoerd telkens wanneer een Windows-bericht naar het proces is verzonden door het besturingssysteem. Het aanroepen van <xref:System.Diagnostics.Process.CloseMainWindow%2A>stuurt een aanvraag naar dicht bij het hoofdvenster van die in een goed ingedeelde toepassing onderliggende vensters gesloten en alle actieve bericht lussen voor de toepassing trekt.</xref:System.Diagnostics.Process.CloseMainWindow%2A> De aanvraag om af te sluiten van het proces door aan te roepen <xref:System.Diagnostics.Process.CloseMainWindow%2A>hoeft niet de toepassing af te sluiten.</xref:System.Diagnostics.Process.CloseMainWindow%2A> De toepassing voor gebruikersverificatie voordat u afsluit kunt vragen of hij kunt weigeren om af te sluiten. Als u wilt dat de toepassing af te sluiten, de Kill-methode te gebruiken. Het gedrag van <xref:System.Diagnostics.Process.CloseMainWindow%2A>is gelijk aan dat een gebruiker via het systeemmenu voor hoofdvenster van de toepassing sluiten.</xref:System.Diagnostics.Process.CloseMainWindow%2A> De aanvraag om af te sluiten van het proces door te sluiten van het hoofdvenster dwingt daarom niet de toepassing onmiddellijk afgesloten.      > [!NOTE] > Voor afsluiten van de methode wordt asynchroon uitgevoerd. Na het aanroepen van de Kill-methode aanroepen de <xref:System.Diagnostics.Process.WaitForExit%2A>methode moet worden gewacht op het proces af en controleer de <xref:System.Diagnostics.Process.HasExited%2A>eigenschap om te bepalen of het proces is afgesloten.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit%2A>       Gegevens die door het proces is bewerkt of resources toegewezen aan het proces kunnen worden echter verwijderd als u Kill aanroepen. Kill zorgt ervoor dat een abnormale proces te beëindigen en alleen indien nodig moet worden gebruikt. <xref:System.Diagnostics.Process.CloseMainWindow%2A>Hiermee een geordende beëindiging van het proces en sluit alle vensters, zodat het verdient de voorkeur voor toepassingen met een interface.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Als <xref:System.Diagnostics.Process.CloseMainWindow%2A>mislukt, kunt u Kill het proces is beëindigd.</xref:System.Diagnostics.Process.CloseMainWindow%2A> KILL-instructie is de enige manier om de processen die u geen grafische interfaces hebt wordt beëindigd.       U kunt Kill aanroepen en <xref:System.Diagnostics.Process.CloseMainWindow%2A>alleen voor processen die worden uitgevoerd op de lokale computer.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Er kan geen processen op externe computers om af te sluiten. U kunt alleen gegevens weergeven voor processen die worden uitgevoerd op externe computers.      > [!NOTE] > Als de aanroep van de Kill-methode wordt gesteld terwijl het proces die momenteel wordt beëindigd, een <xref:System.ComponentModel.Win32Exception>gegenereerd voor de toegang geweigerd.</xref:System.ComponentModel.Win32Exception>"
  syntax:
    content: public void Kill ();
    parameters: []
  overload: System.Diagnostics.Process.Kill*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Het gekoppelde proces kan niet worden beëindigd.       - of - het proces wordt beëindigd.       - of - het bijbehorende proces is een Win16 uitvoerbaar bestand."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert aan te roepen kill-instructie voor een proces dat wordt uitgevoerd op een externe computer. De methode is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces is al afgesloten.       - of - er is geen methode die is gekoppeld aan dit <xref href=&quot;System.Diagnostics.Process&quot;> </xref> object."
  platform:
  - net462
- uid: System.Diagnostics.Process.LeaveDebugMode
  id: LeaveDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Neemt een <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel uit de status waarmee het communiceren met het besturingssysteemprocessen die in een speciale modus worden uitgevoerd."
  remarks: "Sommige besturingssysteem worden uitgevoerd in een speciale modus. Bij het lezen van de eigenschappen van of koppelen aan deze processen is niet mogelijk als u hebt aangeroepen <xref:System.Diagnostics.Process.EnterDebugMode%2A>voor het onderdeel.</xref:System.Diagnostics.Process.EnterDebugMode%2A> LeaveDebugMode aanroepen wanneer u niet langer toegang tot deze processen die in een speciale modus worden uitgevoerd."
  syntax:
    content: public static void LeaveDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.LeaveDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.MachineName
  id: MachineName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de naam van de computer die op het bijbehorende proces wordt uitgevoerd."
  remarks: "U kunt statistische gegevens weergeven en Procesinformatie voor processen die worden uitgevoerd op externe computers, maar kan niet worden aangeroepen <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, of <xref:System.Diagnostics.Process.Kill%2A>op externe computers.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> </xref:System.Diagnostics.Process.Start%2A>      > [!NOTE] > Het bijbehorende proces wordt uitgevoerd op de lokale computer, retourneert deze eigenschap een punt (&quot;. &quot;) voor de naam van de machine. Moet u de <xref:System.Environment.MachineName%2A?displayProperty=fullName>eigenschap ophalen van de juiste computernaam.</xref:System.Environment.MachineName%2A?displayProperty=fullName>"
  example:
  - "To use the following example you must first start at least one instance of Notepad on a remote computer. The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and MachineName properties for each instance.  \n  \n [!code-cs[process_GetProcessesByName2_2#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_26_1.cs)]\n [!code-cpp[process_GetProcessesByName2_2#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_26_1.cpp)]\n [!code-vb[process_GetProcessesByName2_2#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_26_1.vb)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "De naam van de computer waarop het bijbehorende proces wordt uitgevoerd."
  overload: System.Diagnostics.Process.MachineName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er is geen methode die is gekoppeld aan dit <xref href=&quot;System.Diagnostics.Process&quot;> </xref> object."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainModule
  id: MainModule
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee wordt de belangrijkste module voor het bijbehorende proces."
  remarks: "Een procesmodule vertegenwoordigt a.dll of .exe-bestand dat wordt geladen in een bepaald proces. De eigenschap MainModule kunt u informatie over het uitvoerbare bestand gebruikt voor het starten van het proces, inclusief de modulenaam, bestandsnaam en modulegegevens geheugen weergeven."
  syntax:
    content: public System.Diagnostics.ProcessModule MainModule { get; }
    return:
      type: System.Diagnostics.ProcessModule
      description: "De <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> die gebruikt werden om het proces te starten."
  overload: System.Diagnostics.Process.MainModule*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap MainModule voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Een 32-bits proces probeert te openen van de modules van een 64-bits proces."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me); Stel &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; naar <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> voor toegang tot deze eigenschap in Windows 98 en Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces <xref:System.Diagnostics.Process.Id*>is niet beschikbaar.</xref:System.Diagnostics.Process.Id*>       - of - het proces is afgesloten."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowHandle
  id: MainWindowHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de vensterkoppeling van het hoofdvenster van het bijbehorende proces."
  remarks: "Het hoofdvenster is het venster is geopend door het proces die momenteel de focus heeft (de <xref:System.Windows.Forms.Form.TopLevel%2A>formulier).</xref:System.Windows.Forms.Form.TopLevel%2A> Moet u de <xref:System.Diagnostics.Process.Refresh%2A>methode voor het vernieuwen van de <xref:System.Diagnostics.Process>object ophalen van de huidige hoofdvenster ingang als het is gewijzigd.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A> In het algemeen, omdat de vensterkoppeling is in de cache, gebruikt u <xref:System.Diagnostics.Process.Refresh%2A>vooraf in te garanderen dat de huidige ingang moet worden opgehaald.</xref:System.Diagnostics.Process.Refresh%2A>       U kunt de eigenschap MainWindowHandle alleen voor processen die worden uitgevoerd op de lokale computer. De eigenschap MainWindowHandle is een waarde die een unieke identificatie van het venster dat is gekoppeld aan het proces.       Een proces heeft een hoofdvenster gekoppeld alleen als het proces een grafische interface heeft. Als het bijbehorende proces geen een hoofdvenster heeft, is de waarde MainWindowHandle nul. De waarde is ook nul voor processen die zijn verborgen, dat wil zeggen, verwerkt die niet zichtbaar in de taakbalk zijn. Dit kan zijn dat het geval is voor processen die worden weergegeven als pictogrammen in het systeemvak uiterst rechts op de taakbalk.       Als u zojuist een proces gestart hebt en u wilt gebruiken, de belangrijkste vensteringang, kunt u overwegen de <xref:System.Diagnostics.Process.WaitForInputIdle%2A>methode waarmee het proces wordt gestart, waarbij u ervoor zorgt dat de belangrijkste vensterkoppeling is gemaakt.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Anders wordt een uitzondering gegenereerd."
  syntax:
    content: public IntPtr MainWindowHandle { get; }
    return:
      type: System.IntPtr
      description: "De ingang van het systeem gegenereerde venster van het hoofdvenster van het bijbehorende proces."
  overload: System.Diagnostics.Process.MainWindowHandle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De MainWindowHandle is niet gedefinieerd, omdat het proces is afgesloten."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap MainWindowHandle voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me); Stel &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; naar <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> voor toegang tot deze eigenschap in Windows 98 en Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowTitle
  id: MainWindowTitle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u het bijschrift van het hoofdvenster van het proces."
  remarks: "Een proces heeft een hoofdvenster gekoppeld alleen als het proces een grafische interface heeft. Als het bijbehorende proces niet over een hoofdvenster beschikt (zodat <xref:System.Diagnostics.Process.MainWindowHandle%2A>gelijk is aan nul), MainWindowTitle is een lege tekenreeks (&quot;&quot;).</xref:System.Diagnostics.Process.MainWindowHandle%2A> Als u zojuist een proces gestart hebt en u wilt gebruiken, de titel van het hoofdvenster, kunt u overwegen de <xref:System.Diagnostics.Process.WaitForInputIdle%2A>methode waarmee het proces wordt gestart, waarbij u ervoor zorgt dat de belangrijkste vensterkoppeling is gemaakt.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> Anders wordt er het systeem een uitzondering gegenereerd.      > [!NOTE] > Het hoofdvenster is het venster dat momenteel de focus heeft; opmerking dat dit niet het eerste venster voor het proces mogelijk zijn. Moet u de <xref:System.Diagnostics.Process.Refresh%2A>methode voor het vernieuwen van de <xref:System.Diagnostics.Process>object ophalen van de huidige hoofdvenster ingang als het is gewijzigd.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  example:
  - "The following example starts an instance of Notepad and retrieves the caption of the main window of the process.  \n  \n [!code-cpp[process_MainWindowTitle#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_45_1.cpp)]\n [!code-cs[process_MainWindowTitle#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_45_1.cs)]\n [!code-vb[process_MainWindowTitle#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_45_1.vb)]"
  syntax:
    content: public string MainWindowTitle { get; }
    return:
      type: System.String
      description: "De titel van het hoofdvenster van het proces."
  overload: System.Diagnostics.Process.MainWindowTitle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De eigenschap MainWindowTitle is niet gedefinieerd, omdat het proces is afgesloten."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap MainWindowTitle voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me); Stel &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; naar <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> voor toegang tot deze eigenschap in Windows 98 en Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MaxWorkingSet
  id: MaxWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van maximale toegestane grootte van de werkset, in bytes, voor het bijbehorende proces."
  remarks: "De werkset van een proces is de set geheugenpagina&quot;s die momenteel zichtbaar is voor het proces in het fysieke RAM-geheugen. Deze pagina&quot;s zijn beschikbaar voor een toepassing worden gebruikt zonder dat een paginafout en.       De werkset bevat de gedeelde en persoonlijke gegevens. De gedeelde gegevens omvatten de pagina&quot;s met de instructies die uw toepassing wordt uitgevoerd, met inbegrip van de pagina&quot;s in de dll-bestanden en de system.dll-bestanden. Als de werkset grootte toeneemt, verhoogt de vraag van geheugen.       Een proces heeft minimale en maximale werkende set grootten. Telkens wanneer die een resource van het proces wordt gemaakt, reserveert het systeem een hoeveelheid geheugen die gelijk is aan de minimale grootte voor het proces. De virtual memorymanager probeert te houden ten minste de minimumhoeveelheid geheugen residente wanneer het proces actief is, maar het nooit zorgt ervoor dat meer dan de maximale grootte.       Het systeem stelt de standaard set grootten werkt. U kunt deze formaten met behulp van de MaxWorkingSet wijzigen en <xref:System.Diagnostics.Process.MinWorkingSet%2A>leden.</xref:System.Diagnostics.Process.MinWorkingSet%2A> Echter, instellen van deze waarden wordt niet gegarandeerd dat het geheugen gereserveerd of residente worden.      > [!NOTE] > Als u de grootte van de werkset van een proces verhoogt, u rekening houden met fysiek geheugen weg van de rest van het systeem. Zorg ervoor dat u een grootte van de werkset minimum of maximum dat is te groot is, omdat hierdoor de systeemprestaties kan nadelig geen aanvragen."
  syntax:
    content: public IntPtr MaxWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "De maximale grootte van werkset dat is toegestaan in het geheugen voor het proces, in bytes."
  overload: System.Diagnostics.Process.MaxWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De maximumgrootte van de werkset is ongeldig. Deze moet groter zijn dan of gelijk zijn aan de minimale grootte van werkset."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Werkt set informatie kan niet worden opgehaald uit de bron van het bijbehorende proces.       - of - de proces-id of de proceskoppeling is nul omdat het proces niet is gestart."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap MaxWorkingSet voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces <xref:System.Diagnostics.Process.Id*>is niet beschikbaar.</xref:System.Diagnostics.Process.Id*>       - of - het proces is afgesloten."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.MinWorkingSet
  id: MinWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van de minimale toegestane grootte van de werkset, in bytes, voor het bijbehorende proces."
  remarks: "De werkset van een proces is de set geheugenpagina&quot;s die momenteel zichtbaar is voor het proces in het fysieke RAM-geheugen. Deze pagina&quot;s zijn beschikbaar voor een toepassing worden gebruikt zonder dat een paginafout en.       De werkset bevat de gedeelde en persoonlijke gegevens. De gedeelde gegevens omvatten de pagina&quot;s met de instructies die uw toepassing wordt uitgevoerd, met inbegrip van de pagina&quot;s in de dll-bestanden en de system.dll-bestanden. Als de werkset grootte toeneemt, verhoogt de vraag van geheugen.       Een proces heeft minimale en maximale werkende set grootten. Telkens wanneer die een resource van het proces wordt gemaakt, reserveert het systeem een hoeveelheid geheugen die gelijk is aan de minimale grootte voor het proces. De virtual memorymanager probeert te houden ten minste de minimumhoeveelheid geheugen residente wanneer het proces actief is, maar het nooit zorgt ervoor dat meer dan de maximale grootte.       Het systeem stelt de standaard set grootten werkt. Kunt u deze formaten met behulp van de <xref:System.Diagnostics.Process.MaxWorkingSet%2A>en MinWorkingSet leden.</xref:System.Diagnostics.Process.MaxWorkingSet%2A> Echter, instellen van deze waarden wordt niet gegarandeerd dat het geheugen gereserveerd of residente worden.      > [!NOTE] > Als u de grootte van de werkset van een proces verhoogt, u rekening houden met fysiek geheugen weg van de rest van het systeem. Zorg ervoor dat u een grootte van de werkset minimum of maximum dat is te groot is, omdat hierdoor de systeemprestaties kan nadelig geen aanvragen."
  syntax:
    content: public IntPtr MinWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "De minimale grootte van werkset die vereist is in het geheugen voor het proces, in bytes."
  overload: System.Diagnostics.Process.MinWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "De minimumgrootte van de werkset is ongeldig. Deze moet minder dan of gelijk aan de maximumgrootte van de werkset."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Werkt set informatie kan niet worden opgehaald uit de bron van het bijbehorende proces.       - of - de proces-id of de proceskoppeling is nul omdat het proces niet is gestart."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap MinWorkingSet voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces <xref:System.Diagnostics.Process.Id*>is niet beschikbaar.</xref:System.Diagnostics.Process.Id*>       - of - het proces is afgesloten."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.Modules
  id: Modules
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de modules die door het bijbehorende proces zijn geladen."
  remarks: "Een procesmodule vertegenwoordigt a.dll of .exe-bestand dat wordt geladen in een bepaald proces. Een <xref:System.Diagnostics.ProcessModule>exemplaar kunt u informatie weergeven over een module, inclusief de modulenaam, bestandsnaam en geheugen modulegegevens.</xref:System.Diagnostics.ProcessModule>       Een proces kan meerdere modules in het geheugen laden. .Exe-bestanden die worden geladen extra dll-bestanden hebben bijvoorbeeld meerdere modules.       Nadat het proces is gestart, is deze verzameling leeg totdat het proces is geladen door het systeem. Als het proces een hoofdvenster heeft, kunt u bellen <xref:System.Diagnostics.Process.WaitForInputIdle%2A>voordat het ophalen van deze eigenschap om ervoor te zorgen dat de verzameling niet leeg wanneer is u de lijst.</xref:System.Diagnostics.Process.WaitForInputIdle%2A>"
  syntax:
    content: public System.Diagnostics.ProcessModuleCollection Modules { get; }
    return:
      type: System.Diagnostics.ProcessModuleCollection
      description: "Een matrix van het type <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> die staat voor de modules die door het bijbehorende proces zijn geladen."
  overload: System.Diagnostics.Process.Modules*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap Modules voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces <xref:System.Diagnostics.Process.Id*>is niet beschikbaar.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me); Stel &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; naar <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> voor toegang tot deze eigenschap in Windows 98 en Windows Me."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "U probeert te krijgen tot de eigenschap Modules voor het systeemproces of het actieve proces. Deze processen zich geen modules."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  id: NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de hoeveelheid niet-wisselbaar computergeheugen dat, in bytes, voor het bijbehorende proces is toegewezen."
  syntax:
    content: public int NonpagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "De hoeveelheid geheugen in bytes, het systeem is toegewezen voor het bijbehorende proces die kan worden geschreven naar het wisselbestand van virtueel geheugen."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  id: NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de hoeveelheid niet-wisselbaar computergeheugen dat, in bytes, voor het bijbehorende proces is toegewezen."
  remarks: "De waarde die is geretourneerd door deze eigenschap vertegenwoordigt de huidige grootte van niet-wisselbare systeemgeheugen gebruikt door het proces, in bytes. Het systeemgeheugen is het fysiek geheugen die wordt gebruikt door het besturingssysteem en is onderverdeeld in de wisselbare en niet-wisselbare groepen. Niet-wisselbaar geheugentoewijzingen blijven in het systeemgeheugen en zijn niet verwijderd uit het naar het wisselbestand van virtueel geheugen.       Deze eigenschap kan worden gebruikt voor het bewaken van geheugengebruik op computers met een 32-bits processors of 64-bits processors. De eigenschapswaarde is gelijk aan de **groep wisselbaar geheugen: Bytes** prestatiemeteritem voor het proces."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_28_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_28_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_28_1.vb)]"
  syntax:
    content: public long NonpagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "De hoeveelheid systeemgeheugen in bytes, voor het bijbehorende proces die kan worden geschreven naar het wisselbestand van virtueel geheugen toegewezen."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.OnExited
  id: OnExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Geeft de <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> gebeurtenis."
  remarks: "OnExited is de API-methode die wordt gegeven de <xref:System.Diagnostics.Process.Exited>gebeurtenis.</xref:System.Diagnostics.Process.Exited> Het aanroepen van OnExited oorzaken de <xref:System.Diagnostics.Process.Exited>gebeurtenis plaatsvindt en is de enige manier om te genereren van de gebeurtenis met behulp van de <xref:System.Diagnostics.Process>onderdeel.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Exited> OnExited wordt voornamelijk gebruikt wanneer de klassen die zijn afgeleid van het onderdeel.       Als alternatief voor OnExited kunt u uw eigen gebeurtenis-handler schrijven. Maakt u uw eigen gebeurtenis-handler gemachtigde en uw eigen gebeurtenisafhandeling-methode.      > [!NOTE] > Als u van de Visual Studio-omgeving gebruikmaakt, een gebeurtenis-handler gemachtigde (AddOnExited) en een gebeurtenisafhandeling-methode (Process1_Exited) zijn voor u gemaakt wanneer u sleept een <xref:System.Diagnostics.Process>onderdeel op een formulier en dubbelklik op het pictogram.</xref:System.Diagnostics.Process> De code die u maakt om te worden uitgevoerd wanneer de <xref:System.Diagnostics.Process.Exited>gebeurtenis is ingevoerd in de procedure Process1_Exited.</xref:System.Diagnostics.Process.Exited> U hoeft niet te maken van het lid OnExited omdat deze is geïmplementeerd voor u.       Een gebeurtenis te verhogen, roept de gebeurtenis-handler via een gemachtigde. Zie voor een overzicht [gebeurtenissen](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to use the OnExited method in a derived class.  \n  \n [!code-cs[OnExitSample#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_9_1.cs)]\n [!code-vb[OnExitSample#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_9_1.vb)]"
  syntax:
    content: protected void OnExited ();
    parameters: []
  overload: System.Diagnostics.Process.OnExited*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.OutputDataReceived
  id: OutputDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Telkens wanneer een toepassing schrijft een regel in de omgeleide <xref:System.Diagnostics.Process.StandardOutput*>stream.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "De gebeurtenis OutputDataReceived geeft aan dat de bijbehorende <xref:System.Diagnostics.Process>is een regel wordt beëindigd met een teken op de omgeleide geschreven <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       De gebeurtenis is ingeschakeld tijdens asynchrone leesbewerkingen op <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A> Voor asynchrone leesbewerkingen begint, moet u de <xref:System.Diagnostics.Process.StandardOutput%2A>stroom van een <xref:System.Diagnostics.Process>uw Gebruikersgebeurtenis-handler voor de gebeurtenis OutputDataReceived toe en roep <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A> omleiden Daarna wordt de OutputDataReceived gebeurtenis signalen telkens wanneer het proces schrijft een regel op de omgeleide <xref:System.Diagnostics.Process.StandardOutput%2A>stream, totdat het proces wordt afgesloten of aanroepen <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>      > [!NOTE] > De toepassing die wordt verwerkt door de uitvoer van de asynchrone aanroep moet de <xref:System.Diagnostics.Process.WaitForExit%2A>methode om ervoor te zorgen dat de uitvoerbuffer is leeggemaakt.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.  \n  \n The example creates an event delegate for the `OutputHandler` event handler and associates it with the OutputDataReceived event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.  \n  \n [!code-cpp[Process_AsyncStreams#4](~/add/codesnippet/cpp/e-system.diagnostics.pro_2_1.cpp)]\n [!code-cs[Process_AsyncStreams#4](~/add/codesnippet/csharp/e-system.diagnostics.pro_2_1.cs)]\n [!code-vb[Process_AsyncStreams#4](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_2_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize
  id: PagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de hoeveelheid wisselbaar geheugen in bytes, voor het bijbehorende proces is toegewezen."
  syntax:
    content: public int PagedMemorySize { get; }
    return:
      type: System.Int32
      description: "De hoeveelheid geheugen in bytes, toegewezen door het bijbehorende proces die kan worden geschreven naar het wisselbestand van virtueel geheugen."
  overload: System.Diagnostics.Process.PagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize64
  id: PagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de hoeveelheid wisselbaar geheugen in bytes, voor het bijbehorende proces is toegewezen."
  remarks: "De waarde die is geretourneerd door deze eigenschap vertegenwoordigt de huidige grootte van het geheugen in het wisselbestand voor virtueel geheugen die wordt gebruikt door het proces, in bytes. Het besturingssysteem maakt gebruik van het wisselbestand van virtueel geheugen in combinatie met fysiek geheugen voor het beheren van de virtuele adresruimte voor elk proces. Wanneer wisselbaar geheugen niet gebruikt wordt, kan deze worden overgebracht naar het wisselbestand van virtueel geheugen op schijf. Gebruik om de hoeveelheid geheugen die door het besturingssysteem wordt gebruikt voor het proces de <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>eigenschap.</xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>       Deze eigenschap kan worden gebruikt voor het bewaken van geheugengebruik op computers met een 32-bits processors of 64-bits processors. De eigenschapswaarde is gelijk aan de **Bestandsbytes pagina** prestatiemeteritem voor het proces."
  example:
  - "The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public long PagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "De hoeveelheid geheugen in bytes, in het wisselbestand van virtueel geheugen voor het bijbehorende proces is toegewezen."
  overload: System.Diagnostics.Process.PagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  id: PagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de hoeveelheid wisselbaar computergeheugen dat, in bytes, voor het bijbehorende proces is toegewezen."
  syntax:
    content: public int PagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "De hoeveelheid geheugen in bytes, het systeem is toegewezen voor het bijbehorende proces die kan worden geschreven naar het wisselbestand van virtueel geheugen."
  overload: System.Diagnostics.Process.PagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  id: PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de hoeveelheid wisselbaar computergeheugen dat, in bytes, voor het bijbehorende proces is toegewezen."
  remarks: "De waarde die is geretourneerd door de waarde van deze eigenschap vertegenwoordigt de huidige grootte van wisselbaar computergeheugen dat door het proces, in bytes gebruikt. Het systeemgeheugen is het fysiek geheugen die wordt gebruikt door het besturingssysteem en is onderverdeeld in de wisselbare en niet-wisselbare groepen. Wanneer wisselbaar geheugen niet gebruikt wordt, kan deze worden overgebracht naar het wisselbestand van virtueel geheugen op schijf. Gebruik om de grootte van de toepassing geheugen dat wordt gebruikt door het proces de <xref:System.Diagnostics.Process.PagedMemorySize64%2A>eigenschap.</xref:System.Diagnostics.Process.PagedMemorySize64%2A>       Deze eigenschap kan worden gebruikt voor het bewaken van geheugengebruik op computers met een 32-bits processors of 64-bits processors. De eigenschapswaarde is gelijk aan de **groep wisselbaar geheugen: Bytes** prestatiemeteritem voor het proces."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_18_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public long PagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "De hoeveelheid systeemgeheugen in bytes, voor het bijbehorende proces die kan worden geschreven naar het wisselbestand van virtueel geheugen toegewezen."
  overload: System.Diagnostics.Process.PagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  id: PeakPagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de maximale hoeveelheid geheugen in het wisselbestand virtuele geheugen in bytes, dat wordt gebruikt door het bijbehorende proces."
  syntax:
    content: public int PeakPagedMemorySize { get; }
    return:
      type: System.Int32
      description: "De maximale hoeveelheid geheugen in bytes, toegewezen door het bijbehorende proces dat kan worden geschreven naar het wisselbestand van virtueel geheugen."
  overload: System.Diagnostics.Process.PeakPagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  id: PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de maximale hoeveelheid geheugen in het wisselbestand virtuele geheugen in bytes, dat wordt gebruikt door het bijbehorende proces."
  remarks: "De waarde die is geretourneerd door de waarde van deze eigenschap vertegenwoordigt de maximale grootte van het geheugen in het wisselbestand voor virtueel geheugen die door het proces wordt gebruikt sinds het is gestart, in bytes. Het besturingssysteem maakt gebruik van het wisselbestand van virtueel geheugen in combinatie met fysiek geheugen voor het beheren van de virtuele adresruimte voor elk proces. Wanneer wisselbaar geheugen niet gebruikt wordt, kan deze worden overgebracht naar het wisselbestand van virtueel geheugen op schijf.       Deze eigenschap kan worden gebruikt voor het bewaken van geheugengebruik op computers met een 32-bits processors of 64-bits processors. De eigenschapswaarde is gelijk aan de **piekwaarde bestand Bytes** prestatiemeteritem voor het proces."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_24_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_24_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_24_1.vb)]"
  syntax:
    content: public long PeakPagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "De maximale hoeveelheid geheugen in bytes, in het wisselbestand van virtueel geheugen voor het bijbehorende proces is toegewezen sinds het is gestart."
  overload: System.Diagnostics.Process.PeakPagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  id: PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de maximale hoeveelheid virtueel geheugen in bytes, dat wordt gebruikt door het bijbehorende proces."
  syntax:
    content: public int PeakVirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "De maximale hoeveelheid virtueel geheugen in bytes, dat het bijbehorende proces heeft aangevraagd."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  id: PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de maximale hoeveelheid virtueel geheugen in bytes, dat wordt gebruikt door het bijbehorende proces."
  remarks: "De waarde die is geretourneerd door deze eigenschap vertegenwoordigt de maximale grootte van virtueel geheugen gebruikt door het proces sinds het is gestart, in bytes. De virtuele adresruimte voor elk proces op de pagina&quot;s geladen in het fysieke geheugen of naar pagina&quot;s die zijn opgeslagen in het wisselbestand van virtueel geheugen op de schijf wordt toegewezen door het besturingssysteem.       Deze eigenschap kan worden gebruikt voor het bewaken van geheugengebruik op computers met een 32-bits processors of 64-bits processors. De eigenschapswaarde is gelijk aan de **Piekwaarde virtuele Bytes** prestatiemeteritem voor het proces."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_23_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_23_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_23_1.vb)]"
  syntax:
    content: public long PeakVirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "De maximale hoeveelheid virtueel geheugen, in bytes, voor het bijbehorende proces is toegewezen sinds het is gestart."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet
  id: PeakWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de piekgrootte van werkset van het bijbehorende proces in bytes."
  remarks: "De werkset van een proces is de set geheugenpagina&quot;s die momenteel zichtbaar is voor het proces in het fysieke RAM-geheugen. Deze pagina&quot;s zijn beschikbaar voor een toepassing worden gebruikt zonder dat een paginafout en.       De werkset bevat de gedeelde en persoonlijke gegevens. De gedeelde gegevens omvatten de pagina&quot;s met de instructies die het proces wordt uitgevoerd, met inbegrip van procesmodellen en de systeembibliotheken."
  syntax:
    content: public int PeakWorkingSet { get; }
    return:
      type: System.Int32
      description: "De maximale hoeveelheid fysiek geheugen dat het bijbehorende proces in één keer in bytes is vereist."
  overload: System.Diagnostics.Process.PeakWorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet64
  id: PeakWorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de maximale hoeveelheid fysiek geheugen in bytes, dat wordt gebruikt door het bijbehorende proces."
  remarks: "De waarde die is geretourneerd door deze eigenschap vertegenwoordigt de maximale grootte van de set geheugen dat wordt gebruikt door het proces sinds het is gestart, in bytes werkt. De werkset van een proces is de set geheugenpagina&quot;s die momenteel zichtbaar is voor het proces in het fysieke RAM-geheugen. Deze pagina&quot;s zijn beschikbaar voor een toepassing worden gebruikt zonder dat een paginafout en.       De werkset bevat de gedeelde en persoonlijke gegevens. De gedeelde gegevens omvatten de pagina&quot;s met de instructies die het proces wordt uitgevoerd, met inbegrip van de instructies van de procesmodellen en de systeembibliotheken.       Deze eigenschap kan worden gebruikt voor het bewaken van geheugengebruik op computers met een 32-bits processors of 64-bits processors. De eigenschapswaarde is gelijk aan de **Piekwaarde in werkset** prestatiemeteritem voor het proces."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_34_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_34_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_34_1.vb)]"
  syntax:
    content: public long PeakWorkingSet64 { get; }
    return:
      type: System.Int64
      description: "De maximale hoeveelheid fysiek geheugen in bytes, voor het bijbehorende proces is toegewezen sinds het is gestart."
  overload: System.Diagnostics.Process.PeakWorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van een waarde die aangeeft of het bijbehorende procesprioriteit tijdelijk door het besturingssysteem moet worden verhoogd wanneer het hoofdvenster de focus heeft."
  remarks: "Wanneer een thread wordt uitgevoerd in een proces waarvoor de prioriteitsklasse een van de dynamische prioriteit opsommingswaarden heeft (<xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, of <xref:System.Diagnostics.ProcessPriorityClass>), het systeem verhoogt tijdelijk de thread prioriteit wanneer deze wordt gemaakt uit de status van een ogenblik geduld.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Deze actie voorkomt u dat andere processen onderbreken van de verwerking van de huidige thread. De instelling PriorityBoostEnabled geldt voor alle bestaande threads en eventuele threads die vervolgens door het proces wordt gemaakt. Als u wilt herstellen normaal gedrag, stelt u de eigenschap PriorityBoostEnabled op `false`.      > [!NOTE] > Versterking van de prioriteit te hoog kunt verwijderen uit bronnen van essentiële besturingssysteem- en netwerkfuncties, waardoor er problemen ontstaan met andere taken van het besturingssysteem."
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als u dynamische versterking van de prioriteit van het proces moet plaatsvinden voor een proces wanneer deze wordt gemaakt uit de status wachten; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. De standaardwaarde is <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Prioriteit versterking gegevens kunnen niet worden opgehaald uit de bron van het bijbehorende proces."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap.       - of - de proces-id of Proceskoppeling is nul. (Het proces is niet gestart.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap PriorityBoostEnabled voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces <xref:System.Diagnostics.Process.Id*>is niet beschikbaar.</xref:System.Diagnostics.Process.Id*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityClass
  id: PriorityClass
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van de algehele prioriteit categorie voor het bijbehorende proces."
  remarks: "Een proces prioriteitsklasse omvat een bereik van de thread prioriteitsniveaus. Threads met verschillende prioriteiten die worden uitgevoerd in het proces ten opzichte van de prioriteitsklasse van het proces worden uitgevoerd. Win32 gebruikt vier prioriteitsklassen met zeven basisprioriteit niveaus per klasse. Deze proces prioriteitsklassen zijn vastgelegd in de <xref:System.Diagnostics.ProcessPriorityClass>opsomming, waarmee u de prioriteit van het proces ingesteld op <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, of <xref:System.Diagnostics.ProcessPriorityClass>.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Op basis van de tijd is verstreken of andere verhoogt, het grondtal prioriteitsniveau kunnen worden gewijzigd door het besturingssysteem, wanneer nodig is om te worden genomen voor anderen voor toegang tot de processor. Bovendien kunt u instellen de <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>tijdelijk vergroten het prioriteitsniveau van de threads die uit de status van de wacht is gezet.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> De prioriteit wordt opnieuw ingesteld wanneer het proces weer de status van de wachttijd.       De <xref:System.Diagnostics.Process.BasePriority%2A>eigenschap kunt u de eerste prioriteit die is toegewezen aan een proces weergeven.</xref:System.Diagnostics.Process.BasePriority%2A> Echter, omdat het kenmerk alleen-lezen, u niet gebruiken de <xref:System.Diagnostics.Process.BasePriority%2A>eigenschap in te stellen de prioriteit van een proces.</xref:System.Diagnostics.Process.BasePriority%2A> Als u wilt de prioriteit wilt wijzigen, gebruik de eigenschap PriorityClass, die de algehele prioriteit categorie voor het proces opgehaald of ingesteld.       De prioriteitsklasse kan niet worden weergegeven met Systeemmonitor. De volgende tabel toont de relatie tussen de <xref:System.Diagnostics.Process.BasePriority%2A>en PriorityClass waarden.</xref:System.Diagnostics.Process.BasePriority%2A>      | BasePriority | PriorityClass |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_29_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_29_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_29_1.vb)]"
  syntax:
    content: public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }
    return:
      type: System.Diagnostics.ProcessPriorityClass
      description: "De categorie prioriteit voor het bijbehorende proces, van waaruit de <xref:System.Diagnostics.Process.BasePriority*>van het proces wordt berekend.</xref:System.Diagnostics.Process.BasePriority*>"
  overload: System.Diagnostics.Process.PriorityClass*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Prioriteit procesinformatie kan niet worden ingesteld of opgehaald uit de bron van het bijbehorende proces.       - of - de proces-id of Proceskoppeling is nul. (Het proces is niet gestart.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap PriorityClass voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces <xref:System.Diagnostics.Process.Id*>is niet beschikbaar.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "U hebt de PriorityClass ingesteld op <xref uid=&quot;langword_csharp_AboveNormal&quot; name=&quot;AboveNormal&quot; href=&quot;&quot;> </xref> of <xref uid=&quot;langword_csharp_BelowNormal&quot; name=&quot;BelowNormal&quot; href=&quot;&quot;> </xref> wanneer u Windows 98 of Windows ME (Me). Deze platforms bieden geen ondersteuning voor deze waarden voor de prioriteitsklasse."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "Prioriteitsklasse kan alleen worden ingesteld omdat deze geen gebruik maakt geen geldige waarde, zoals gedefinieerd in de <xref href=&quot;System.Diagnostics.ProcessPriorityClass&quot;> </xref> opsomming."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize
  id: PrivateMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de hoeveelheid privé-geheugen in bytes, voor het bijbehorende proces is toegewezen."
  syntax:
    content: public int PrivateMemorySize { get; }
    return:
      type: System.Int32
      description: "Het aantal bytes dat is toegewezen door het bijbehorende proces dat kan worden gedeeld met andere processen."
  overload: System.Diagnostics.Process.PrivateMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize64
  id: PrivateMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de hoeveelheid privé-geheugen in bytes, voor het bijbehorende proces is toegewezen."
  remarks: "De waarde die is geretourneerd door deze eigenschap vertegenwoordigt de huidige grootte van het geheugen dat wordt gebruikt door het proces, in bytes, dat kan worden gedeeld met andere processen.       Deze eigenschap kan worden gebruikt voor het bewaken van geheugengebruik op computers met een 32-bits processors of 64-bits processors. De eigenschapswaarde is gelijk aan de **eigen Bytes** prestatiemeteritem voor het proces."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_17_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_17_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_17_1.vb)]"
  syntax:
    content: public long PrivateMemorySize64 { get; }
    return:
      type: System.Int64
      description: "De hoeveelheid geheugen in bytes, voor het bijbehorende proces dat kan worden gedeeld met andere processen toegewezen."
  overload: System.Diagnostics.Process.PrivateMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de bevoorrechte processortijd voor dit proces."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_37_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_37_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_37_1.vb)]"
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Een <xref:System.TimeSpan>die aangeeft dat de hoeveelheid tijd aangegeven dat het proces is de code in de kern van het besturingssysteem is uitgevoerd.</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.PrivilegedProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap PrivilegedProcessorTime voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessName
  id: ProcessName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de naam van het proces."
  remarks: "De eigenschap procesnaam bevat de naam van een uitvoerbaar bestand, zoals Outlook, dat de extensie .exe of het pad niet omvat. Het is nuttig voor het ophalen van en de processen die gekoppeld aan hetzelfde uitvoerbare bestand zijn bewerken.      > [!NOTE] > Op [!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)] besturingssystemen, de eigenschap ProcessName kan worden afgekapt tot 15 tekens als de informatie van de module proces kan niet worden verkregen.       U kunt aanroepen <xref:System.Diagnostics.Process.GetProcessesByName%2A>, de naam van een uitvoerbaar bestand voor het ophalen van een matrix met elk exemplaar dat wordt uitgevoerd op de opgegeven computer doorgeeft.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Deze matrix, bijvoorbeeld, kunt u alle actieve exemplaren van het uitvoerbare bestand afgesloten."
  syntax:
    content: public string ProcessName { get; }
    return:
      type: System.String
      description: "De naam die wordt gebruikt voor het identificeren van het proces voor de gebruiker."
  overload: System.Diagnostics.Process.ProcessName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces heeft geen id, of er zijn geen processen die zijn gekoppeld aan de <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.       - of - het bijbehorende proces is afgesloten."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me); Stel &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; naar <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> voor toegang tot deze eigenschap in Windows 98 en Windows Me."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Het proces is niet op deze computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van de processors op waarop de threads in dit proces kunnen worden gepland om uit te voeren."
  remarks: "In Windows 2000 en hoger, kunt een thread in een proces van processor voor processor migreren met elk migratie opnieuw laden van de processorcache. Onder zware wordt geladen, aangeven welke processor moet een specifieke thread worden uitgevoerd kan de prestaties verbeteren door het aantal keren die opnieuw van de processorcache wordt geladen. De koppeling tussen een processor en een thread kan de processoraffiniteit wordt genoemd.       Iedere processor wordt als iets vertegenwoordigd. Bits 0 is processor een, 1-bits processor twee, enzovoort. Als u iets aan de waarde 1 instelt, wordt de bijbehorende processor geselecteerd voor de toewijzing van de thread. Als u de waarde ProcessorAffinity op nul instelt, instellen van het besturingssysteem plannen algoritmen van de thread-affiniteit. Als de waarde ProcessorAffinity is ingesteld op een andere waarde dan nul, wordt de waarde geïnterpreteerd als een bitmasker waarmee die in aanmerking komen voor selectie processors.       De volgende tabel ziet een selectie van ProcessorAffinity waarden voor een&8;-processor.      | Bitmasker | Binaire waarde | In aanmerking komende processors |   |-------------|------------------|-------------------------|   | 0x0001 | 00000000 00000001 | 1 |   | 0x0003 | 00000000 00000011 | 1 en 2 |   | 0x0007 | 00000000 00000111 | 1, 2 en 3 |   | 0x0009 | 00000000 00001001 | 1 en 4 |   | 0x007F | 00000000 01111111 | 1, 2, 3, 4, 5, 6 en 7 |"
  syntax:
    content: public IntPtr ProcessorAffinity { get; set; }
    return:
      type: System.IntPtr
      description: "Een bitmasker dat vertegenwoordigt de processors waarop de threads in het gekoppelde proces kunnen worden uitgevoerd. De standaardwaarde is afhankelijk van het aantal processors op de computer. De standaardwaarde is 2 <sup>n</sup> -1, waarbij n het aantal processors is."
  overload: System.Diagnostics.Process.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "ProcessorAffinity informatie kan niet worden ingesteld of opgehaald uit de bron van het bijbehorende proces.       - of - de proces-id of Proceskoppeling is nul. (Het proces is niet gestart.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap ProcessorAffinity voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces <xref:System.Diagnostics.Process.Id*>is niet beschikbaar.</xref:System.Diagnostics.Process.Id*>       - of - het proces is afgesloten."
  platform:
  - net462
- uid: System.Diagnostics.Process.Refresh
  id: Refresh
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Verwijdert alle informatie over het bijbehorende proces dat is opgeslagen in het cachegeheugen in het procesonderdeel."
  remarks: "Nadat de vernieuwing wordt genoemd, is de eerste aanvraag voor meer informatie over elke eigenschap zorgt ervoor dat het procesonderdeel aan een nieuwe waarde niet ophalen van het bijbehorende proces.       Wanneer een <xref:System.Diagnostics.Process>onderdeel is gekoppeld aan een resource proces de eigenschapwaarden van de <xref:System.Diagnostics.Process>onmiddellijk worden ingevuld op basis van de status van het bijbehorende proces.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Als de informatie over het bijbehorende proces vervolgens wordt gewijzigd, worden deze wijzigingen niet doorgevoerd in de <xref:System.Diagnostics.Process>van onderdeel waarden in de cache opgeslagen.</xref:System.Diagnostics.Process> De <xref:System.Diagnostics.Process>onderdeel is van een momentopname van de bron van het proces op het moment dat ze gekoppeld zijn.</xref:System.Diagnostics.Process> Als u wilt weergeven in de huidige waarden van het bijbehorende proces, roept u de methode vernieuwen."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_1_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_1_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_1_1.vb)]"
  syntax:
    content: public void Refresh ();
    parameters: []
  overload: System.Diagnostics.Process.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Responding
  id: Responding
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Haalt een waarde die aangeeft of de gebruikersinterface van het proces reageert."
  remarks: "Als een proces een gebruikersinterface heeft, neemt de gebruikersinterface om te bepalen of het proces op invoer van de gebruiker reageert contact op met de eigenschap reageren. Als de interface niet onmiddellijk, de eigenschap reageren retourneert reageert `false`. Gebruik deze eigenschap om te bepalen of de interface van het bijbehorende proces reageert.       Als het proces beschikt niet over een <xref:System.Diagnostics.Process.MainWindowHandle%2A>, retourneert deze eigenschap `true`.</xref:System.Diagnostics.Process.MainWindowHandle%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_39_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_39_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_39_1.vb)]"
  syntax:
    content: public bool Responding { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de gebruikersinterface van het bijbehorende proces op het systeem reageert. anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.Responding*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me); Stel &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; naar <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> voor toegang tot deze eigenschap in Windows 98 en Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er is geen methode die is gekoppeld aan dit <xref href=&quot;System.Diagnostics.Process&quot;> </xref> object."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap reageert voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.SafeHandle
  id: SafeHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de systeemeigen koppeling voor dit proces."
  remarks: "De ingang is alleen beschikbaar als het proces voor de aanroepende component gestart."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeProcessHandle
      description: "De systeemeigen koppeling voor dit proces."
  overload: System.Diagnostics.Process.SafeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.SessionId
  id: SessionId
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee wordt de sessie-id van Terminal Services voor het bijbehorende proces."
  remarks: "De eigenschap SessionId identificeert de sessie waarin de toepassing wordt uitgevoerd."
  syntax:
    content: public int SessionId { get; }
    return:
      type: System.Int32
      description: "De Terminal Services-sessie-id van het bijbehorende proces."
  overload: System.Diagnostics.Process.SessionId*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Er is geen sessie die is gekoppeld aan dit proces."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er is geen methode die is gekoppeld aan deze sessie-id.       - of - het bijbehorende proces is niet op deze machine."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "De eigenschap SessionId wordt niet ondersteund op Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardError
  id: StandardError
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u een stroom die wordt gebruikt om te lezen van de foutuitvoer van de toepassing."
  remarks: "Wanneer een <xref:System.Diagnostics.Process>schrijft van tekst naar de Standaardfoutstroom dat tekst normaal gesproken wordt weergegeven in de console.</xref:System.Diagnostics.Process> U kunt omleiden van de StandardError-stroom, bewerken of de foutuitvoer van een proces te onderdrukken. U kunt bijvoorbeeld de tekst filteren, anders opmaken of de uitvoer naar zowel de console en een aangewezen logboekbestand schrijven.      > [!NOTE] > Met StandardError, moet u stelt <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>naar `false`, en moet u instellen <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName>naar `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Anders wordt er bij het lezen van de StandardError-stroom een uitzondering gegenereerd.       De omgeleide StandardError-stroom kan worden gelezen synchroon of asynchroon. Methoden zoals <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, en <xref:System.IO.StreamReader.ReadToEnd%2A>synchrone leesbewerkingen op de uitvoerstroom fout van het proces uitvoeren.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Deze synchrone lezen bewerkingen niet voltooit tot de bijbehorende <xref:System.Diagnostics.Process>schrijft naar het StandardError-stroom of de stroom wordt gesloten.</xref:System.Diagnostics.Process>       Daarentegen <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>begint asynchrone leesbewerkingen op de StandardError-stroom.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Deze methode kan een aangewezen gebeurtenis-handler voor de Stroomuitvoer van de en retourneert onmiddellijk naar de aanroeper die andere taken uitvoeren kunt terwijl de Stroomuitvoer van de is omgeleid naar de gebeurtenis-handler.       Synchrone leesbewerkingen introduceert een afhankelijkheid tussen de aanroeper lezen van de StandardError-stroom en het onderliggende proces schrijven naar deze stroom. Deze afhankelijkheden kunnen resulteren in een impasse voorwaarden. Wanneer de aanroeper is gelezen uit de omgeleide stroom van een onderliggend proces, is afhankelijk van de onderliggende. De aanroeper wacht op de leesbewerking tot het onderliggende naar de stroom schrijft of de stroom wordt gesloten. Wanneer het onderliggende proces voldoende gegevens schrijft voor het vervullen van de omgeleide stroom, is afhankelijk van het bovenliggende item. Het onderliggende proces wacht op de volgende schrijfbewerking totdat de bovenliggende van de volledige stroom leest of de stroom wordt gesloten. De impassesituatie treedt op wanneer de aanroeper en het onderliggende proces wacht op elkaar om een bewerking te voltooien en geen van beide kunt doorgaan. U kunt impassen voorkomen door het evalueren van afhankelijkheden tussen de aanroeper en het onderliggende proces.       De volgende C#-code ziet u bijvoorbeeld het lezen van een omgeleide stroom en wacht tot het onderliggende proces om af te sluiten.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```In het voorbeeld wordt een deadlock voorkomen door het aanroepen van `p.StandardError.ReadToEnd` voordat `p.WaitForExit`. Een deadlock kan optreden als de bovenliggende aanroepen verwerken `p.WaitForExit` voordat `p.StandardError.ReadToEnd` en het onderliggende proces schrijft voldoende tekst in om aan te vullen van de omgeleide stroom. Het bovenliggende proces zou voor onbepaalde tijd wachten op het onderliggende proces om af te sluiten. Het onderliggende proces zou voor onbepaalde tijd wachten op de bovenliggende lezen van de volledige StandardError-stroom.       Er is een soortgelijk probleem bij het lezen van alle tekst in de standaarduitvoer en de standaardfout stromen. De volgende C#-code, voert bijvoorbeeld een leesbewerking op beide stromen.      ```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```In het voorbeeld wordt de impassesituatie voorkomen door het uitvoeren van asynchrone leesbewerkingen op de <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Een deadlock resulteert als het bovenliggende proces aanroepen `p.StandardOutput.ReadToEnd` gevolgd door `p.StandardError.ReadToEnd` en het onderliggende proces schrijft voldoende tekst in om aan te vullen van de foutstroom. Het bovenliggende proces voor onbepaalde tijd wilt wachten op het onderliggende proces sluit de <xref:System.Diagnostics.Process.StandardOutput%2A>stream.</xref:System.Diagnostics.Process.StandardOutput%2A> Het onderliggende proces zou voor onbepaalde tijd wachten op de bovenliggende lezen van de volledige StandardError-stroom.       U kunt de asynchrone leesbewerkingen gebruiken om te voorkomen dat deze afhankelijkheden en hun mogelijke impasse. U kunt ook de impassesituatie voorkomen door het maken van twee threads en het lezen van de uitvoer van elke stroom op een afzonderlijke thread.      > [!NOTE] > U asynchrone als synchrone leesbewerkingen voor een omgeleide stroom niet door elkaar. Eenmaal op de omgeleide stroom van een <xref:System.Diagnostics.Process>wordt geopend in de synchrone of asynchrone modus alle verdere Lees bewerkingen in deze stroom moeten zich in dezelfde modus.</xref:System.Diagnostics.Process> Bijvoorbeeld, volg niet <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>met een aanroep naar <xref:System.IO.StreamReader.ReadLine%2A>op de StandardError-stroom of vice versa.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> U kunt echter twee verschillende stromen in verschillende modi lezen. U kunt bijvoorbeeld aanroepen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>en roept u vervolgens <xref:System.IO.StreamReader.ReadLine%2A>voor de StandardError-stroom.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example uses the `net use` command together with a user supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_41_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_41_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_41_1.vb)]"
  syntax:
    content: public System.IO.StreamReader StandardError { get; }
    return:
      type: System.IO.StreamReader
      description: "Een <xref:System.IO.StreamReader>die kunnen worden gebruikt om te lezen van de Standaardfoutstroom van de toepassing.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardError*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardError stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardError stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginErrorReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardInput
  id: StandardInput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u een stroom die wordt gebruikt om te schrijven van de invoer van de toepassing."
  remarks: "Een <xref:System.Diagnostics.Process>invoertekst kunnen worden gelezen vanaf de Standaardinvoerstroom, meestal het toetsenbord.</xref:System.Diagnostics.Process> U kunt de invoer programmatisch opgeven door het omleiden van de StandardInput-stroom. Bijvoorbeeld, in plaats van de invoer van het toetsenbord, kunt u opgeven tekst van de inhoud van een opgegeven bestand of de uitvoer van een andere toepassing.      > [!NOTE] > Voor het gebruik van StandardInput, moet u instellen <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>naar `false`, en moet u instellen <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName>naar `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Anders er schrijven naar het StandardInput stroom een uitzondering gegenereerd."
  example:
  - "The following example illustrates how to redirect the StandardInput stream of a process. The example starts the `sort` command with redirected input. It then prompts the user for text, and passes that to the `sort` process by means of the redirected StandardInput stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_0_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_0_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public System.IO.StreamWriter StandardInput { get; }
    return:
      type: System.IO.StreamWriter
      description: "Een <xref:System.IO.StreamWriter>die kunnen worden gebruikt om te schrijven Standaardinvoerstroom van de toepassing.</xref:System.IO.StreamWriter>"
  overload: System.Diagnostics.Process.StandardInput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De StandardInput-stroom is niet gedefinieerd omdat &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt; is ingesteld op <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardOutput
  id: StandardOutput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u een stroom die wordt gebruikt om te lezen van de uitvoer van de tekst van de toepassing."
  remarks: "Wanneer een <xref:System.Diagnostics.Process>schrijft tekst naar de standaard stroom of tekst normaal wordt weergegeven in de console.</xref:System.Diagnostics.Process> U kunt omleiden StandardOutput-stroom, bewerken of de uitvoer van een proces te onderdrukken. U kunt bijvoorbeeld de tekst filteren, anders opmaken of de uitvoer naar zowel de console en een aangewezen logboekbestand schrijven.      > [!NOTE] > Met StandardOutput, moet u stelt <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>naar `false`, en moet u instellen <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName>naar `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Anders wordt er bij het lezen van het StandardOutput-stroom een uitzondering gegenereerd.       De omgeleide StandardOutput-stroom kan worden gelezen synchroon of asynchroon. Methoden zoals <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, en <xref:System.IO.StreamReader.ReadToEnd%2A>synchrone leesbewerkingen op de uitvoerstroom van het proces uitvoeren.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Deze synchrone lezen bewerkingen niet voltooit tot de bijbehorende <xref:System.Diagnostics.Process>schrijft naar het StandardOutput-stroom of de stroom wordt gesloten.</xref:System.Diagnostics.Process>       Daarentegen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>begint asynchrone leesbewerkingen op de StandardOutput-stroom.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Deze methode kan een aangewezen gebeurtenis-handler voor de Stroomuitvoer van de en retourneert onmiddellijk naar de aanroeper die andere taken uitvoeren kunt terwijl de Stroomuitvoer van de is omgeleid naar de gebeurtenis-handler.       Synchrone leesbewerkingen introduceert een afhankelijkheid tussen de aanroeper lezen van het StandardOutput-stroom en het onderliggende proces schrijven naar deze stroom. Deze afhankelijkheden kunnen resulteren in een impasse voorwaarden. Wanneer de aanroeper is gelezen uit de omgeleide stroom van een onderliggend proces, is afhankelijk van de onderliggende. De aanroeper wacht op de leesbewerking tot het onderliggende naar de stroom schrijft of de stroom wordt gesloten. Wanneer het onderliggende proces voldoende gegevens schrijft voor het vervullen van de omgeleide stroom, is afhankelijk van het bovenliggende item. Het onderliggende proces wacht op de volgende schrijfbewerking totdat de bovenliggende van de volledige stroom leest of de stroom wordt gesloten. De impassesituatie treedt op wanneer de aanroeper en het onderliggende proces wacht op elkaar om een bewerking te voltooien en geen van beide kunt doorgaan. U kunt impassen voorkomen door het evalueren van afhankelijkheden tussen de aanroeper en het onderliggende proces.       De volgende C#-code ziet u bijvoorbeeld het lezen van een omgeleide stroom en wacht tot het onderliggende proces om af te sluiten.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```In het voorbeeld wordt een deadlock voorkomen door het aanroepen van `p.StandardOutput.ReadToEnd` voordat `p.WaitForExit`. Een deadlock kan optreden als de bovenliggende aanroepen verwerken `p.WaitForExit` voordat `p.StandardOutput.ReadToEnd` en het onderliggende proces schrijft voldoende tekst in om aan te vullen van de omgeleide stroom. Het bovenliggende proces zou voor onbepaalde tijd wachten op het onderliggende proces om af te sluiten. Het onderliggende proces zou voor onbepaalde tijd wachten op de bovenliggende lezen van de volledige StandardOutput-stroom.       Er is een soortgelijk probleem bij het lezen van alle tekst in de standaarduitvoer en de standaardfout stromen. De volgende C#-code, voert bijvoorbeeld een leesbewerking op beide stromen.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```In het voorbeeld wordt de impassesituatie voorkomen door het uitvoeren van asynchrone leesbewerkingen op de StandardOutput-stroom. Een deadlock resulteert als het bovenliggende proces aanroepen `p.StandardOutput.ReadToEnd` gevolgd door `p.StandardError.ReadToEnd` en het onderliggende proces schrijft voldoende tekst in om aan te vullen van de foutstroom. Het bovenliggende proces zou voor onbepaalde tijd wachten op het onderliggende proces naar het StandardOutput-stroom niet sluiten. Het onderliggende proces voor onbepaalde tijd wilt wachten op het bovenliggende item te lezen van de volledige <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A>       U kunt de asynchrone leesbewerkingen gebruiken om te voorkomen dat deze afhankelijkheden en hun mogelijke impasse. U kunt ook de impassesituatie voorkomen door het maken van twee threads en het lezen van de uitvoer van elke stroom op een afzonderlijke thread.      > [!NOTE] > U asynchrone als synchrone leesbewerkingen voor een omgeleide stroom niet door elkaar. Eenmaal op de omgeleide stroom van een <xref:System.Diagnostics.Process>wordt geopend in de synchrone of asynchrone modus alle verdere Lees bewerkingen in deze stroom moeten zich in dezelfde modus.</xref:System.Diagnostics.Process> Bijvoorbeeld, volg niet <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>met een aanroep naar <xref:System.IO.StreamReader.ReadLine%2A>op de StandardOutput-stroom of vice versa.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> U kunt echter twee verschillende stromen in verschillende modi lezen. U kunt bijvoorbeeld aanroepen <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>en roept u vervolgens <xref:System.IO.StreamReader.ReadLine%2A>voor de <xref:System.Diagnostics.Process.StandardError%2A>stream.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.  \n  \n [!code-vb[Process_StandardOutput#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process_StandardOutput#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_11_1.cs)]\n [!code-cpp[Process_StandardOutput#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_11_1.cpp)]"
  syntax:
    content: public System.IO.StreamReader StandardOutput { get; }
    return:
      type: System.IO.StreamReader
      description: "Een <xref:System.IO.StreamReader>die kunnen worden gebruikt om te lezen van de standaard uitvoerstroom van de toepassing.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardOutput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardOutput stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardOutput stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginOutputReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start
  id: Start
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Start (of hergebruikt) op de proces-resource die is opgegeven door de <xref:System.Diagnostics.Process.StartInfo*>eigenschap van dit <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel en associeert deze met het onderdeel.</xref:System.Diagnostics.Process.StartInfo*>"
  remarks: "Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component. The return value `true` indicates that a new process resource was started. If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and `false` is returned.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n> [!NOTE]\n>  If you are using Visual Studio, this overload of the Start method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer. Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property. Your changes will appear in the form's `InitializeComponent` procedure.  \n  \n This overload of Start is not a `static` method. You must call it from an instance of the <xref:System.Diagnostics.Process> class. Before calling Start, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.  \n  \n The other overloads of the Start method are `static` members. You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method. Instead, you can call Start for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started. Or, `null` is returned if a process was reused. The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the Start method.  \n  \n The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property. For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box. For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use Start to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_16_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_16_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_16_1.cs)]"
  syntax:
    content: public bool Start ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als een resource van het proces wordt gestart; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> als er geen nieuwe proces resource wordt gestart (bijvoorbeeld als een bestaand proces opnieuw wordt gebruikt)."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er is geen bestandsnaam is opgegeven in de <xref href=&quot;System.Diagnostics.Process&quot;> </xref> van onderdeel <> </> *>.       - of - de &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; lid is van de <> </> *> eigenschap is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> terwijl &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt;, of &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Er is een fout opgetreden bij het openen van het bijbehorende bestand."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Het procesobject is al verwijderd."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  id: Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "De proces-resource die is opgegeven door de parameter met start procesinformatie (bijvoorbeeld, de bestandsnaam van het proces starten) wordt gestart en koppelt u de resource met een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel."
  remarks: "Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle>.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_17_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_17_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_17_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);
    parameters:
    - id: startInfo
      type: System.Diagnostics.ProcessStartInfo
      description: "De <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> die de informatie die wordt gebruikt voor het starten van het proces, inclusief de bestandsnaam en opdrachtregelargumenten bevat."
    return:
      type: System.Diagnostics.Process
      description: "Een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> dat is gekoppeld aan de resource proces of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er is geen resource van het proces wordt gestart. Houd er rekening mee dat een nieuw proces wordt gestart naast de exemplaren van hetzelfde proces al actief wordt onafhankelijk van de andere. Bovendien Start met een niet-null-proces kan retourneren de <xref:System.Diagnostics.Process.HasExited*>eigenschap is al ingesteld op <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> In dit geval kan het gestarte proces een bestaand exemplaar van zichzelf geactiveerd en vervolgens is afgesloten."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er is geen bestandsnaam is opgegeven in de <code> startInfo </code> van parameter <> </> *> eigenschap.       -or-       The <>*> property of the <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> and the <>*>, <>*>, or <>*> property is also <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.       - of - de <> </> *> eigenschap van de <code> startInfo </code> parameter <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> en de <> </> *> eigenschap is niet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> of leeg zijn of de <> </> *> eigenschap is niet <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Het procesobject is al verwijderd."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Het opgegeven bestand in de <code> startInfo </code> van parameter <xref:System.Diagnostics.ProcessStartInfo.FileName*>eigenschap kan niet worden gevonden.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Er is een fout opgetreden bij het openen van het bijbehorende bestand.       - of - de som van de lengte van de argumenten en de lengte van het volledige pad naar het proces 2080 overschrijdt. Het foutbericht wordt weergegeven die zijn gekoppeld aan deze uitzondering kan een van de volgende zijn: &quot;het gegevensgebied doorgegeven aan een systeemaanroep is te klein.&quot; of &quot;Toegang geweigerd.&quot;"
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String)
  id: Start(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een proces resource begint met het opgeven van de naam van een document of de toepassing het bestand en koppelt u de resource met een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel."
  remarks: "Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\".  \n  \n This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=fullName> overloads.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "De naam van een document of de toepassing het bestand in het proces uit te voeren."
    return:
      type: System.Diagnostics.Process
      description: "Een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> dat is gekoppeld aan de resource proces of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er is geen resource van het proces wordt gestart. Houd er rekening mee dat een nieuw proces wordt gestart naast de exemplaren van hetzelfde proces al actief wordt onafhankelijk van de andere. Bovendien Start met een niet-null-proces kan retourneren de <xref:System.Diagnostics.Process.HasExited*>eigenschap is al ingesteld op <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> In dit geval kan het gestarte proces een bestaand exemplaar van zichzelf geactiveerd en vervolgens is afgesloten."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Er is een fout opgetreden bij het openen van het bijbehorende bestand."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Het procesobject is al verwijderd."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "De omgevingsvariabele PATH heeft een tekenreeks met aanhalingstekens."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  id: Start(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Een resource van het proces door te geven van de naam van een toepassing en een reeks opdrachtregelargumenten gestart en wordt de bron gekoppeld aan een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel."
  remarks: "Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\". If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`. If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a \"`/c`\" or \"`/k`\" argument to specify whether the command window exits or remains after completion.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_20_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_20_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_20_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "De naam van een bestand in het proces uit te voeren."
    - id: arguments
      type: System.String
      description: "De opdrachtregelargumenten doorgeven bij het starten van het proces."
    return:
      type: System.Diagnostics.Process
      description: "Een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> dat is gekoppeld aan de resource proces of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er is geen resource van het proces wordt gestart. Houd er rekening mee dat een nieuw proces wordt gestart naast de exemplaren van hetzelfde proces al actief wordt onafhankelijk van de andere. Bovendien Start met een niet-null-proces kan retourneren de <xref:System.Diagnostics.Process.HasExited*>eigenschap is al ingesteld op <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> In dit geval kan het gestarte proces een bestaand exemplaar van zichzelf geactiveerd en vervolgens is afgesloten."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <code>fileName</code> or <code>arguments</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Er is een fout opgetreden bij het openen van het bijbehorende bestand.       - of - de som van de lengte van de argumenten en de lengte van het volledige pad naar het proces 2080 overschrijdt. Het foutbericht wordt weergegeven die zijn gekoppeld aan deze uitzondering kan een van de volgende zijn: &quot;het gegevensgebied doorgegeven aan een systeemaanroep is te klein.&quot; of &quot;Toegang geweigerd.&quot;"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Het procesobject is al verwijderd."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "De omgevingsvariabele PATH heeft een tekenreeks met aanhalingstekens."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Start een resource proces door te geven van de naam van een toepassing, een gebruikersnaam, wachtwoord en een domein en koppelt u de resource met een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel."
  remarks: "Gebruik deze overbelasting te maken van een nieuw proces en de primaire thread door te geven van de bestandsnaam, gebruikersnaam, wachtwoord en domein. Het nieuwe proces voor het opgegeven uitvoerbare bestand wordt vervolgens wordt uitgevoerd in de beveiligingscontext van de opgegeven referenties (gebruiker, domein en wachtwoord).      > [!NOTE] > Wanneer het uitvoerbare bestand bevindt zich op een extern station, moet u de netwerkshare identificeren met behulp van een uniform resource identifier (URI) stationsletter is gekoppeld.      > [!NOTE] > Als het adres van het uitvoerbare bestand te starten een URL is, wordt het proces is niet gestart en `null` geretourneerd.       Deze overbelasting kunt u een proces te starten zonder eerst te maken een nieuwe <xref:System.Diagnostics.Process>exemplaar.</xref:System.Diagnostics.Process> De overbelasting is een alternatief voor de expliciete stappen voor het maken van een nieuw <xref:System.Diagnostics.Process>exemplaar, instellen van de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, en <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>Eigenschappen van de <xref:System.Diagnostics.Process.StartInfo%2A>eigenschap en aanroepen <xref:System.Diagnostics.Process.Start%2A>voor de <xref:System.Diagnostics.Process>exemplaar.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Op deze manier op dezelfde manier waarop de **uitvoeren** in het dialoogvenster kan de naam van een uitvoerbaar bestand met of zonder de extensie .exe accepteren, is de extensie .exe optioneel in de `fileName` parameter. U kunt bijvoorbeeld instellen de `fileName` parameter &quot;Notepad.exe&quot; of &quot;Kladblok&quot;. Als de `fileName` parameter een uitvoerbaar bestand vertegenwoordigt de `arguments` parameter mogelijk een bestand moet worden ondernomen, zoals het tekstbestand in weer `Notepad.exe myfile.txt`.      > [!NOTE] > De bestandsnaam moet vertegenwoordigen een uitvoerbaar bestand in de <xref:System.Diagnostics.Process.Start%2A>overloads die hebben `userName`, `password`, en `domain` parameters.</xref:System.Diagnostics.Process.Start%2A>       Wanneer u gebruik <xref:System.Diagnostics.Process.Start%2A>om te starten, moet u mogelijk sluiten of verloren gaan systeembronnen.</xref:System.Diagnostics.Process.Start%2A> Processen met behulp van <xref:System.Diagnostics.Process.CloseMainWindow%2A>of <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> sluiten U kunt controleren of een proces al afgesloten is met behulp van de <xref:System.Diagnostics.Process.HasExited%2A>eigenschap...</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.  \n  \n [!code-cs[System.Diagnostics.Process.Start#1](~/add/codesnippet/csharp/fff1e658-5eee-484b-80e5-_1.cs)]\n [!code-vb[System.Diagnostics.Process.Start#1](~/add/codesnippet/visualbasic/fff1e658-5eee-484b-80e5-_1.vb)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "De naam van een bestand in het proces uit te voeren."
    - id: userName
      type: System.String
      description: "De gebruikersnaam moet worden gebruikt wanneer het proces wordt gestart."
    - id: password
      type: System.Security.SecureString
      description: "Een <xref href=&quot;System.Security.SecureString&quot;> </xref> die het wachtwoord moet worden gebruikt bij het starten van het proces bevat."
    - id: domain
      type: System.String
      description: "Het domein moet worden gebruikt wanneer het proces wordt gestart."
    return:
      type: System.Diagnostics.Process
      description: "Een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> dat is gekoppeld aan de resource proces of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er is geen resource van het proces wordt gestart. Houd er rekening mee dat een nieuw proces wordt gestart naast de exemplaren van hetzelfde proces al actief wordt onafhankelijk van de andere. Bovendien Start met een niet-null-proces kan retourneren de <xref:System.Diagnostics.Process.HasExited*>eigenschap is al ingesteld op <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> In dit geval kan het gestarte proces een bestaand exemplaar van zichzelf geactiveerd en vervolgens is afgesloten."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er is geen bestandsnaam is opgegeven."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Er is een fout opgetreden bij het openen van het bijbehorende bestand."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Het procesobject is al verwijderd."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Start een resource proces door te geven van de naam van een toepassing, een reeks opdrachtregelargumenten, een gebruikersnaam, wachtwoord en een domein en koppelt u de resource met een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel."
  remarks: "Gebruik deze overbelasting te maken van een nieuw proces en de primaire thread door te geven van de bestandsnaam, opdrachtregelargumenten gebruikersnaam, wachtwoord en domein. Het nieuwe proces voor het opgegeven uitvoerbare bestand wordt vervolgens wordt uitgevoerd in de beveiligingscontext van de opgegeven referenties (gebruiker, domein en wachtwoord).      > [!NOTE] > Wanneer het uitvoerbare bestand bevindt zich op een extern station, moet u de netwerkshare identificeren met behulp van een uniform resource identifier (URI) stationsletter is gekoppeld.      > [!NOTE] > Als het adres van het uitvoerbare bestand te starten een URL is, wordt het proces is niet gestart en `null` geretourneerd.       Deze overbelasting kunt u een proces te starten zonder eerst te maken een nieuwe <xref:System.Diagnostics.Process>exemplaar.</xref:System.Diagnostics.Process> De overbelasting is een alternatief voor de expliciete stappen voor het maken van een nieuw <xref:System.Diagnostics.Process>exemplaar, instellen van de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, en <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>Eigenschappen van de <xref:System.Diagnostics.Process.StartInfo%2A>eigenschap en aanroepen <xref:System.Diagnostics.Process.Start%2A>voor de <xref:System.Diagnostics.Process>exemplaar.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Op deze manier op dezelfde manier waarop de **uitvoeren** in het dialoogvenster kan de naam van een uitvoerbaar bestand met of zonder de extensie .exe accepteren, is de extensie .exe optioneel in de `fileName` parameter. U kunt bijvoorbeeld instellen de `fileName` parameter &quot;Notepad.exe&quot; of &quot;Kladblok&quot;. Als de `fileName` parameter een uitvoerbaar bestand vertegenwoordigt de `arguments` parameter mogelijk een bestand moet worden ondernomen, zoals het tekstbestand in weer `Notepad.exe myfile.txt`.      > [!NOTE] > De bestandsnaam moet vertegenwoordigen een uitvoerbaar bestand in de <xref:System.Diagnostics.Process.Start%2A>overloads die hebben `userName`, `password`, en `domain` parameters.</xref:System.Diagnostics.Process.Start%2A>       Wanneer u gebruik <xref:System.Diagnostics.Process.Start%2A>om te starten, moet u mogelijk sluiten of verloren gaan systeembronnen.</xref:System.Diagnostics.Process.Start%2A> Processen met behulp van <xref:System.Diagnostics.Process.CloseMainWindow%2A>of <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> sluiten U kunt controleren of een proces al afgesloten is met behulp van de <xref:System.Diagnostics.Process.HasExited%2A>eigenschap...</xref:System.Diagnostics.Process.HasExited%2A>"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "De naam van een bestand in het proces uit te voeren."
    - id: arguments
      type: System.String
      description: "De opdrachtregelargumenten doorgeven bij het starten van het proces."
    - id: userName
      type: System.String
      description: "De gebruikersnaam moet worden gebruikt wanneer het proces wordt gestart."
    - id: password
      type: System.Security.SecureString
      description: "Een <xref href=&quot;System.Security.SecureString&quot;> </xref> die het wachtwoord moet worden gebruikt bij het starten van het proces bevat."
    - id: domain
      type: System.String
      description: "Het domein moet worden gebruikt wanneer het proces wordt gestart."
    return:
      type: System.Diagnostics.Process
      description: "Een nieuwe <xref href=&quot;System.Diagnostics.Process&quot;> </xref> dat is gekoppeld aan de resource proces of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er is geen resource van het proces wordt gestart. Houd er rekening mee dat een nieuw proces wordt gestart naast de exemplaren van hetzelfde proces al actief wordt onafhankelijk van de andere. Bovendien Start met een niet-null-proces kan retourneren de <xref:System.Diagnostics.Process.HasExited*>eigenschap is al ingesteld op <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> In dit geval kan het gestarte proces een bestaand exemplaar van zichzelf geactiveerd en vervolgens is afgesloten."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er is geen bestandsnaam is opgegeven."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Er is een fout opgetreden bij het openen van het bijbehorende bestand.       - of - de som van de lengte van de argumenten en de lengte van het volledige pad naar het bijbehorende bestand 2080 overschrijdt. Het foutbericht wordt weergegeven die zijn gekoppeld aan deze uitzondering kan een van de volgende zijn: &quot;het gegevensgebied doorgegeven aan een systeemaanroep is te klein.&quot; of &quot;Toegang geweigerd.&quot;"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Het procesobject is al verwijderd."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartInfo
  id: StartInfo
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van de eigenschappen moeten worden doorgegeven aan de <xref:System.Diagnostics.Process.Start*>methode van de <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.</xref:System.Diagnostics.Process.Start*>"
  remarks: "StartInfo vertegenwoordigt de set parameters gebruiken om een proces te starten. Wanneer <xref:System.Diagnostics.Process.Start%2A>is aangeroepen, de StartInfo wordt gebruikt om op te geven van het proces te starten.</xref:System.Diagnostics.Process.Start%2A> Het lid dat alleen de benodigde StartInfo om in te stellen de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>eigenschap.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Starten van een proces door te geven de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>eigenschap is vergelijkbaar met het typen van de informatie in de **uitvoeren** in het dialoogvenster van de Windows **Start** menu.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Daarom de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>eigenschap hoeft niet te vertegenwoordigen een uitvoerbaar bestand.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Het kan zijn van elk bestandstype waarvoor de extensie gekoppeld aan een toepassing op het systeem geïnstalleerd is. Bijvoorbeeld de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>kan een txt-extensie hebben als u bestanden hebt gekoppeld met een teksteditor, zoals Kladblok, of kan een .doc als er bestanden met een hulpprogramma tekstverwerkingsprogramma zoals Microsoft Word associated.doc.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Op deze manier op dezelfde manier waarop de **uitvoeren** in het dialoogvenster kan de naam van een uitvoerbaar bestand met of zonder de extensie .exe accepteren, is de extensie .exe optioneel in de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>lid.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> U kunt bijvoorbeeld instellen de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>eigenschap in op &quot;Notepad.exe&quot; of &quot;Kladblok&quot;.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       U kunt een ClickOnce-toepassing starten door in te stellen de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>eigenschap naar de locatie (bijvoorbeeld een webadres) van waaruit u de toepassing oorspronkelijk zijn geïnstalleerd.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Een ClickOnce-toepassing niet starten door op te geven van de geïnstalleerde locatie op de harde schijf.       Als de bestandsnaam een niet-uitvoerbare bestand, zoals een doc-bestand omvat, kunt u een term die opgeven welke actie moet worden uitgevoerd op het bestand opnemen. Bijvoorbeeld, u kunt instellen de <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>naar &quot;Print&quot; voor een bestand dat eindigt op de extensie .doc.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> De bestandsnaam die is opgegeven in de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>eigenschap niet hoeft te hebben de extensie als u handmatig een waarde op voor de <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>eigenschap.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Echter, als u de <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>eigenschap om te bepalen welke bewerkingen beschikbaar zijn, moet u de extensie opnemen.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       Kunt u de parameters die zijn opgegeven in de eigenschap StartInfo tot het moment dat u de <xref:System.Diagnostics.Process.Start%2A>methode voor het proces.</xref:System.Diagnostics.Process.Start%2A> Nadat u het proces starten, het wijzigen van de waarden StartInfo niet van invloed zijn op of het bijbehorende proces opnieuw starten. Als u de <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>methode met de <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName>en <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName>eigenschappen ingesteld, is de niet-beheerde `CreateProcessWithLogonW` functie wordt aangeroepen, waarmee het proces wordt gestart in een nieuw venster zelfs als de <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>waarde voor eigenschap `true` of de <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>waarde van eigenschap is <xref:System.Diagnostics.ProcessWindowStyle>.</xref:System.Diagnostics.ProcessWindowStyle> </xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> </xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName> </xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>       Als u niet gebruikt de <xref:System.Diagnostics.Process.Start%2A>methode voor het starten van een proces, de eigenschap StartInfo komt niet overeen met de parameters voor het proces te starten.</xref:System.Diagnostics.Process.Start%2A> Als u bijvoorbeeld <xref:System.Diagnostics.Process.GetProcesses%2A>ophalen van een matrix van processen die worden uitgevoerd op de computer, de eigenschap StartInfo van elke <xref:System.Diagnostics.Process>bevat niet de originele bestandsnaam of argumenten gebruikt om het proces te starten.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A>       Wanneer het proces wordt gestart, de bestandsnaam is het bestand dat de (alleen-lezen) gevuld <xref:System.Diagnostics.Process.MainModule%2A>eigenschap.</xref:System.Diagnostics.Process.MainModule%2A> Als u wilt ophalen van het uitvoerbare bestand dat is gekoppeld aan het proces nadat het proces is gestart, gebruikt u de <xref:System.Diagnostics.Process.MainModule%2A>eigenschap.</xref:System.Diagnostics.Process.MainModule%2A> Als u wilt instellen van het uitvoerbare bestand van een <xref:System.Diagnostics.Process>exemplaar voor die een bijbehorende proces is niet gestart, gebruikt u de StartInfo-eigenschap <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>lid.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process> Omdat de leden van de eigenschap StartInfo argumenten die worden doorgegeven aan de <xref:System.Diagnostics.Process.Start%2A>methode van een proces, het wijzigen van de <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>eigenschap nadat het bijbehorende proces is gestart, wordt niet opnieuw de <xref:System.Diagnostics.Process.MainModule%2A>eigenschap.</xref:System.Diagnostics.Process.MainModule%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process.Start%2A> Deze eigenschappen zijn alleen voor het initialiseren van het bijbehorende proces gebruikt."
  example:
  - "The following example populates a StartInfo with the file to execute, the action performed on it and whether it should displays a user interface. For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }
    return:
      type: System.Diagnostics.ProcessStartInfo
      description: "De <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> die staat voor de gegevens waarmee het proces te starten. Deze argumenten bevatten de naam van het uitvoerbare bestand of het document dat wordt gebruikt om het proces te starten."
  overload: System.Diagnostics.Process.StartInfo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "De waarde die aangeeft van de StartInfo <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartTime
  id: StartTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de tijd waarop het bijbehorende proces is gestart."
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "Een object dat wordt aangegeven wanneer het proces is gestart. Als het proces niet wordt uitgevoerd, wordt er een uitzondering gegenereerd."
  overload: System.Diagnostics.Process.StartTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap StartTime voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces is afgesloten.       - of - het proces is niet gestart."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Er is een fout opgetreden in de aanroep naar de Windows-functie."
  platform:
  - net462
- uid: System.Diagnostics.Process.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Opgehaald of ingesteld van het object dat wordt gebruikt voor het marshallen van aanroepen van de gebeurtenis-handler die zijn uitgegeven als gevolg van een gebeurtenis proces afsluiten."
  remarks: "Wanneer <xref:System.Diagnostics.EventLog.SynchronizingObject%2A>is `null`, methoden voor het verwerken van de <xref:System.Diagnostics.Process.Exited>gebeurtenis worden aangeroepen voor een thread van de threadgroep system.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.EventLog.SynchronizingObject%2A> Zie voor meer informatie over het thread-systeemgroepen <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Wanneer de <xref:System.Diagnostics.Process.Exited>gebeurtenis wordt verwerkt door een visual Windows Forms-onderdeel, zoals een <xref:System.Windows.Forms.Button>, toegang tot het onderdeel via de threadgroep systeem werkt mogelijk niet of kan leiden tot een uitzondering.</xref:System.Windows.Forms.Button> </xref:System.Diagnostics.Process.Exited> Dit voorkomen door SynchronizingObject in te stellen op een Windows Forms-onderdeel, waardoor de methoden afhandeling van de <xref:System.Diagnostics.Process.Exited>gebeurtenis moet worden aangeroepen op dezelfde thread waarop het onderdeel is gemaakt.</xref:System.Diagnostics.Process.Exited>       Als de <xref:System.Diagnostics.Process>wordt gebruikt binnen [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] in een Windows Forms-designer SynchronizingObject automatisch ingesteld op het besturingselement met de <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Als u bijvoorbeeld een <xref:System.Diagnostics.Process>op een ontwerpfunctie voor `Form1` (die eigenschappen overneemt van <xref:System.Windows.Forms.Form>) de eigenschap SynchronizingObject van <xref:System.Diagnostics.Process>is ingesteld op het exemplaar van `Form1`: [!code-cpp [Process_SynchronizingObject&#2;](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)][!code-cs[Process_SynchronizingObject&#2;](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)][!code-vb[Process_SynchronizingObject&#2;](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb) ] normaal gesproken deze eigenschap is ingesteld als het onderdeel wordt geplaatst in een besturingselement of een formulier, omdat deze onderdelen zijn gebonden aan een specifieke thread.    </xref:System.Diagnostics.Process> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.Process>"
  example:
  - >-
    [!code-vb[Process_SynchronizingObject#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_2.vb)]
     [!code-cpp[Process_SynchronizingObject#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_2.cpp)]
     [!code-cs[Process_SynchronizingObject#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_2.cs)]
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "De <xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> gebruikt voor het marshallen van aanroepen van de gebeurtenis-handler die zijn uitgegeven als gevolg van een <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> gebeurtenis in het proces."
  overload: System.Diagnostics.Process.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Threads
  id: Threads
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de verzameling threads die in het bijbehorende proces worden uitgevoerd."
  remarks: "Een thread wordt de code in een proces uitgevoerd. Elk proces is gestart met één thread, de primaire thread. Een willekeurige thread kan meer threads maken. Threads in proces delen de adresruimte van het proces.       Gebruik <xref:System.Diagnostics.ProcessThread>om op te halen van de threads die zijn gekoppeld aan het huidige proces.</xref:System.Diagnostics.ProcessThread> De primaire thread is niet noodzakelijkerwijs op index&0; in de matrix."
  syntax:
    content: public System.Diagnostics.ProcessThreadCollection Threads { get; }
    return:
      type: System.Diagnostics.ProcessThreadCollection
      description: "Een matrix van het type <xref href=&quot;System.Diagnostics.ProcessThread&quot;> </xref> dat het besturingssysteem threads in het bijbehorende proces momenteel worden uitgevoerd."
  overload: System.Diagnostics.Process.Threads*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Het proces beschikt niet over een <xref:System.Diagnostics.Process.Id*>, of er zijn geen processen die zijn gekoppeld aan de <xref href=&quot;System.Diagnostics.Process&quot;> </xref> exemplaar.</xref:System.Diagnostics.Process.Id*>       - of - het bijbehorende proces is afgesloten."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me); Stel &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; naar <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> voor toegang tot deze eigenschap in Windows 98 en Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.ToString
  id: ToString
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "De naam van het proces wordt opgemaakt als een tekenreeks, gecombineerd met het bovenliggende onderdeeltype, indien van toepassing."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "De <> </> *>, gecombineerd met de base component <> </> *> waarde retourneren."
  overload: System.Diagnostics.Process.ToString*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "ToString wordt niet ondersteund op Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de totale processortijd voor dit proces."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_15_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_15_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_15_1.vb)]"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Een <xref:System.TimeSpan>die aangeeft dat de hoeveelheid tijd dat het bijbehorende proces met behulp van de CPU heeft gebruikt.</xref:System.TimeSpan> Deze waarde is de som van de <> </> *> en de <> </> *>."
  overload: System.Diagnostics.Process.TotalProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap TotalProcessorTime voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt u de tijd in gebruikersmodus van processor voor dit proces."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_21_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_21_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_21_1.vb)]"
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Een <xref:System.TimeSpan>die aangeeft dat de hoeveelheid tijd dat het bijbehorende proces heeft code uitgevoerd binnen de toepassing deel van het proces (niet in de kern van het besturingssysteem).</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.UserProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "U probeert te krijgen tot de eigenschap UserProcessorTime voor een proces dat wordt uitgevoerd op een externe computer. Deze eigenschap is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize
  id: VirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de grootte van virtueel geheugen van het proces in bytes."
  syntax:
    content: public int VirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "De hoeveelheid virtueel geheugen in bytes, dat het bijbehorende proces heeft aangevraagd."
  overload: System.Diagnostics.Process.VirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize64
  id: VirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de hoeveelheid virtueel geheugen, in bytes, voor het bijbehorende proces is toegewezen."
  remarks: "De waarde die is geretourneerd door deze eigenschap vertegenwoordigt de huidige grootte van virtueel geheugen gebruikt door het proces, in bytes. De virtuele adresruimte voor elk proces op de pagina&quot;s geladen in het fysieke geheugen of naar pagina&quot;s die zijn opgeslagen in het wisselbestand van virtueel geheugen op de schijf wordt toegewezen door het besturingssysteem.       Deze eigenschap kan worden gebruikt voor het bewaken van geheugengebruik op computers met een 32-bits processors of 64-bits processors. De eigenschapswaarde is gelijk aan de **virtuele Bytes** prestatiemeteritem voor het proces."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_13_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_13_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_13_1.vb)]"
  syntax:
    content: public long VirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "De hoeveelheid virtueel geheugen, in bytes, voor het bijbehorende proces is toegewezen."
  overload: System.Diagnostics.Process.VirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit
  id: WaitForExit
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee geeft u de <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel moet worden gewacht voor onbepaalde tijd op het bijbehorende proces om af te sluiten."
  remarks: "WaitForExit kunt u de huidige thread wacht totdat het bijbehorende proces wordt beëindigd.  Worden moet aangeroepen nadat alle andere methoden worden aangeroepen op het proces. Om te voorkomen dat de huidige thread worden geblokkeerd, gebruiken de <xref:System.Diagnostics.Process.Exited>gebeurtenis.</xref:System.Diagnostics.Process.Exited>       Hiermee geeft u deze methode de <xref:System.Diagnostics.Process>onderdeel moet worden gewacht een oneindige tijdsduur voor de processerver en de gebeurtenis-handlers om af te sluiten.</xref:System.Diagnostics.Process> Hierdoor kan een toepassing niet meer reageren. Bijvoorbeeld, als u aanroepen <xref:System.Diagnostics.Process.CloseMainWindow%2A>voor een proces dat een gebruikersinterface, de aanvraag voor het besturingssysteem naar het bijbehorende proces is beëindigd kan niet worden afgehandeld als het proces is geschreven in te voeren nooit de berichtenlus.</xref:System.Diagnostics.Process.CloseMainWindow%2A>      > [!NOTE] > In de [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] en eerdere versies, de overbelasting WaitForExit gewacht <xref:System.Int32.MaxValue>milliseconden (ongeveer 24 dagen), niet voor onbepaalde tijd.</xref:System.Int32.MaxValue> Ook eerdere versies kon niet wachten totdat de gebeurtenis-handlers om af te sluiten als de volledige <xref:System.Int32.MaxValue>tijd is bereikt.</xref:System.Int32.MaxValue>       Deze overbelasting zorgt ervoor dat de verwerking is voltooid, met inbegrip van de verwerking van asynchrone gebeurtenissen voor omgeleide standaarduitvoer. U moet deze overbelasting gebruiken na een aanroep van de <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>overbelasting als standaarduitvoer wordt omgeleid naar de asynchrone gebeurtenis-handlers.</xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>       Wanneer een bijbehorende proces wordt afgesloten (dat wil zeggen, wanneer deze wordt afgesloten door het besturingssysteem door middel van een normale of abnormale beëindiging), wordt het systeem slaat administratieve informatie over het proces en retourneert naar het onderdeel waarmee WaitForExit had aangeroepen. De <xref:System.Diagnostics.Process>onderdeel krijgen vervolgens toegang tot de informatie, waaronder de <xref:System.Diagnostics.Process.ExitTime%2A>, met behulp van de <xref:System.Diagnostics.Process.Handle%2A>met het proces van afgesloten.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Omdat het bijbehorende proces is afgesloten, de <xref:System.Diagnostics.Process.Handle%2A>eigenschap van het onderdeel niet meer verwijst naar een bestaande proces resource.</xref:System.Diagnostics.Process.Handle%2A> In plaats daarvan kan de ingang alleen worden gebruikt voor toegang tot informatie over de bron van het proces van het besturingssysteem. Het systeem is op de hoogte van ingangen voor afgesloten processen die niet zijn vrijgegeven door <xref:System.Diagnostics.Process>onderdelen, zodat het zorgt ervoor dat de <xref:System.Diagnostics.Process.ExitTime%2A>en <xref:System.Diagnostics.Process.Handle%2A>gegevens uit het geheugen tot het <xref:System.Diagnostics.Process>onderdeel specifiek de bronnen worden vrijgegeven.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Om deze reden elk gewenst moment u aanroepen <xref:System.Diagnostics.Process.Start%2A>voor een <xref:System.Diagnostics.Process>exemplaar, roepen <xref:System.Diagnostics.Process.Close%2A>wanneer het bijbehorende proces is beëindigd en u niet meer informatie over deze beheerdersrechten nodig hebben</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>maakt het geheugen toegewezen aan het proces afgesloten.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.
  syntax:
    content: public void WaitForExit ();
    parameters: []
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "De wachtinstelling is niet toegankelijk."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Er zijn geen processen <> </> *> is ingesteld, en een <> </> *> van waaruit de <xref:System.Diagnostics.Process.Id*>eigenschap kan worden bepaald bestaat niet.</xref:System.Diagnostics.Process.Id*>       - of - er is geen methode die is gekoppeld aan dit <xref href=&quot;System.Diagnostics.Process&quot;> </xref> object.       - of - u probeert aan te roepen WaitForExit voor een proces dat wordt uitgevoerd op een externe computer. Deze methode is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  id: WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee geeft u de <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel moet worden gewacht van het opgegeven aantal milliseconden voor het bijbehorende proces om af te sluiten."
  remarks: "WaitForExit kunt u de huidige thread wacht totdat het bijbehorende proces wordt beëindigd. Worden moet aangeroepen nadat alle andere methoden worden aangeroepen op het proces. Om te voorkomen dat de huidige thread worden geblokkeerd, gebruiken de <xref:System.Diagnostics.Process.Exited>gebeurtenis.</xref:System.Diagnostics.Process.Exited>       Hiermee geeft u deze methode de <xref:System.Diagnostics.Process>onderdeel moet worden gewacht een eindige hoeveelheid tijd voor het proces om af te sluiten.</xref:System.Diagnostics.Process> Als het bijbehorende proces niet aan het einde van het interval bestaat omdat de aanvraag is beëindigd is geweigerd, `false` wordt geretourneerd naar de aanroepende procedure. U kunt opgeven dat een negatief getal (<xref:System.Threading.Timeout.Infinite>) voor `milliseconds`, en WaitForExit gedraagt zich hetzelfde zijn als de <xref:System.Diagnostics.Process.WaitForExit>overbelasting.</xref:System.Diagnostics.Process.WaitForExit> </xref:System.Threading.Timeout.Infinite> Als u 0 (nul) aan de methode doorgeven, retourneert `true` alleen als het proces al afgesloten is; anders onmiddellijk wordt `false`.      > [!NOTE] > In de [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] en eerdere versies als `milliseconds` is -1, de WaitForExit overbelasting gewacht <xref:System.Int32.MaxValue>milliseconden (ongeveer 24 dagen), niet voor onbepaalde tijd.</xref:System.Int32.MaxValue>       Als standaarduitvoer wordt omgeleid naar de asynchrone gebeurtenis-handlers, is het mogelijk dat de verwerking van de uitvoer niet hebt voltooid wanneer deze methode retourneert. Om ervoor te zorgen dat asynchrone verwerking is voltooid, Roep de <xref:System.Diagnostics.Process.WaitForExit>overbelasting waarvoor geen parameter na ontvangst een `true` van deze overbelasting.</xref:System.Diagnostics.Process.WaitForExit> Om ervoor te zorgen dat de <xref:System.Diagnostics.Process.Exited>gebeurtenis correct wordt afgehandeld in Windows Forms-toepassingen, stelt u de <xref:System.Diagnostics.Process.SynchronizingObject%2A>eigenschap.</xref:System.Diagnostics.Process.SynchronizingObject%2A> </xref:System.Diagnostics.Process.Exited>       Wanneer een bijbehorende proces wordt afgesloten (wordt afgesloten door het besturingssysteem door middel van een normale of abnormale beëindiging), het systeem opgeslagen administratieve informatie over het proces en retourneert naar het onderdeel waarmee WaitForExit heeft aangeroepen. De <xref:System.Diagnostics.Process>onderdeel krijgen vervolgens toegang tot de informatie, waaronder de <xref:System.Diagnostics.Process.ExitTime%2A>, met behulp van de <xref:System.Diagnostics.Process.Handle%2A>met het proces van afgesloten.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Omdat het bijbehorende proces is afgesloten, de <xref:System.Diagnostics.Process.Handle%2A>eigenschap van het onderdeel niet meer verwijst naar een bestaande proces resource.</xref:System.Diagnostics.Process.Handle%2A> In plaats daarvan kan de ingang alleen worden gebruikt voor toegang tot informatie over de bron van het proces van het besturingssysteem. Het systeem is op de hoogte van ingangen voor afgesloten processen die niet zijn vrijgegeven door <xref:System.Diagnostics.Process>onderdelen, zodat het zorgt ervoor dat de <xref:System.Diagnostics.Process.ExitTime%2A>en <xref:System.Diagnostics.Process.Handle%2A>gegevens uit het geheugen tot het <xref:System.Diagnostics.Process>onderdeel specifiek de bronnen worden vrijgegeven.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> Om deze reden elk gewenst moment u aanroepen <xref:System.Diagnostics.Process.Start%2A>voor een <xref:System.Diagnostics.Process>exemplaar, roepen <xref:System.Diagnostics.Process.Close%2A>wanneer het bijbehorende proces is beëindigd en u niet meer informatie over deze beheerdersrechten nodig hebben</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>maakt het geheugen toegewezen aan het proces afgesloten.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.
  syntax:
    content: public bool WaitForExit (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "De hoeveelheid tijd in milliseconden wachttijd voor het bijbehorende proces om af te sluiten. Het maximum is de hoogst mogelijke waarde van een 32-bits geheel getal, waarmee oneindig wordt aangeduid met het besturingssysteem."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het bijbehorende proces is afgesloten; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "De wachtinstelling is niet toegankelijk."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Er zijn geen processen <> </> *> is ingesteld, en een <> </> *> van waaruit de <xref:System.Diagnostics.Process.Id*>eigenschap kan worden bepaald bestaat niet.</xref:System.Diagnostics.Process.Id*>       - of - er is geen methode die is gekoppeld aan dit <xref href=&quot;System.Diagnostics.Process&quot;> </xref> object.       - of - u probeert aan te roepen WaitForExit voor een proces dat wordt uitgevoerd op een externe computer. Deze methode is alleen beschikbaar voor processen die worden uitgevoerd op de lokale computer."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle
  id: WaitForInputIdle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zorgt ervoor dat de <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel moet worden gewacht voor onbepaalde tijd op het bijbehorende proces invoeren van een niet-actieve status. Deze overbelasting geldt alleen voor processen met een gebruikersinterface en daarom een berichtenlus."
  remarks: "WaitForInputIdle gebruiken om de verwerking van uw toepassing moet worden gewacht totdat de berichtenlus heeft geretourneerd naar de niet-actieve status. Bij het uitvoeren van een proces met een gebruikersinterface, de berichtenlus telkens wanneer een Windows-bericht naar het proces is verzonden door het besturingssysteem wordt uitgevoerd. Het proces wordt vervolgens naar de berichtenlus terugkeert. Een proces is worden in een niet-actieve status wanneer er wordt gewacht tot berichten binnen een berichtenlus genoemd. Deze status is bijvoorbeeld handig als uw toepassing moet wachten tot een starten van de procedure te voltooien met het maken van het hoofdvenster voordat de toepassing met dit venster communiceert.       Als een proces geen een berichtenlus WaitForInputIdle genereert een <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       Hiermee geeft u de overbelasting WaitForInputIdle de <xref:System.Diagnostics.Process>onderdeel moet worden gewacht voor onbepaalde tijd van het proces actief blijft in de berichtenlus.</xref:System.Diagnostics.Process> Deze instructie kan leiden tot een toepassing niet meer reageren. Bijvoorbeeld, als het proces wordt geschreven naar altijd de berichtenlus onmiddellijk afgesloten, zoals in het codefragment `while(true)`."
  syntax:
    content: public bool WaitForInputIdle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het bijbehorende proces een niet-actieve status bereikt is."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces geen grafische interface.       - of - is een onbekende fout opgetreden. Het proces kan niet in te voeren van een niet-actieve status.       - of - het proces is al afgesloten.       - of - er is geen proces gekoppeld aan dit <xref href=&quot;System.Diagnostics.Process&quot;> </xref> object."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  id: WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zorgt ervoor dat de <xref href=&quot;System.Diagnostics.Process&quot;> </xref> onderdeel moet worden gewacht van het opgegeven aantal milliseconden voor het bijbehorende proces invoeren van een niet-actieve status. Deze overbelasting geldt alleen voor processen met een gebruikersinterface en daarom een berichtenlus."
  remarks: "WaitForInputIdle gebruiken om de verwerking van uw toepassing moet worden gewacht totdat de berichtenlus heeft geretourneerd naar de niet-actieve status. Bij het uitvoeren van een proces met een gebruikersinterface, de berichtenlus telkens wanneer een Windows-bericht naar het proces is verzonden door het besturingssysteem wordt uitgevoerd. Het proces wordt vervolgens naar de berichtenlus terugkeert. Een proces is worden in een niet-actieve status wanneer er wordt gewacht tot berichten binnen een berichtenlus genoemd. Deze status is bijvoorbeeld handig als uw toepassing moet wachten tot een starten van de procedure te voltooien met het maken van het hoofdvenster voordat de toepassing met dit venster communiceert.       Als een proces geen een berichtenlus WaitForInputIdle genereert een <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       Hiermee geeft u de overbelasting WaitForInputIdle de <xref:System.Diagnostics.Process>onderdeel moet een eindige hoeveelheid tijd van het proces actief blijft in de berichtenlus wachten.</xref:System.Diagnostics.Process> Als het bijbehorende proces is niet actief blijft door het einde van het interval omdat de lus berichten, steeds verwerkt nog `false` geretourneerd naar de aanroepende procedure.       Zie voor meer informatie over het verwerken van gebeurtenissen [gebeurtenissen](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public bool WaitForInputIdle (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Een waarde van 1 tot en met <xref:System.Int32>die Hiermee geeft u de tijdsduur in milliseconden wachttijd voor het bijbehorende proces actief blijft.</xref:System.Int32> Een waarde van 0 geeft u een onmiddellijke rendement en een waarde van-1 geeft aan dat een oneindige wachttijd."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het bijbehorende proces is een niet-actieve status; bereikt anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Het proces geen grafische interface.       - of - is een onbekende fout opgetreden. Het proces kan niet in te voeren van een niet-actieve status.       - of - het proces is al afgesloten.       - of - er is geen proces gekoppeld aan dit <xref href=&quot;System.Diagnostics.Process&quot;> </xref> object."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet
  id: WorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt het bijbehorende proces fysieke geheugengebruik, in bytes."
  remarks: "De waarde die is geretourneerd door deze eigenschap vertegenwoordigt de huidige grootte van de set-geheugen gebruikt door het proces, in bytes werkt. De werkset van een proces is de set geheugenpagina&quot;s die momenteel zichtbaar is voor het proces in het fysieke RAM-geheugen. Deze pagina&quot;s zijn beschikbaar voor een toepassing worden gebruikt zonder dat een paginafout en.       De werkset bevat de gedeelde en persoonlijke gegevens. De gedeelde gegevens omvatten de pagina&quot;s met de instructies die het proces wordt uitgevoerd, met inbegrip van de procesmodellen en de systeembibliotheken."
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process' exit code.  \n  \n [!code-vb[process_sample#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_40_1.vb)]\n [!code-cpp[process_sample#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_40_1.cpp)]\n [!code-cs[process_sample#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_40_1.cs)]"
  syntax:
    content: public int WorkingSet { get; }
    return:
      type: System.Int32
      description: "De totale hoeveelheid fysiek geheugen het bijbehorende proces is gebruikt, in bytes."
  overload: System.Diagnostics.Process.WorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet64
  id: WorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Hiermee haalt de hoeveelheid fysiek geheugen in bytes, voor het bijbehorende proces is toegewezen."
  remarks: "De waarde die is geretourneerd door deze eigenschap vertegenwoordigt de huidige grootte van de set-geheugen gebruikt door het proces, in bytes werkt. De werkset van een proces is de set geheugenpagina&quot;s die momenteel zichtbaar is voor het proces in het fysieke RAM-geheugen. Deze pagina&quot;s zijn beschikbaar voor een toepassing worden gebruikt zonder dat een paginafout en.       De werkset bevat de gedeelde en persoonlijke gegevens. De gedeelde gegevens omvatten de pagina&quot;s met de instructies die het proces wordt uitgevoerd, met inbegrip van de instructies in de procesmodellen en de systeembibliotheken.       Deze eigenschap kan worden gebruikt voor het bewaken van geheugengebruik op computers met een 32-bits processors of 64-bits processors. De eigenschapswaarde is gelijk aan de **werkset** prestatiemeteritem voor het proces."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_32_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_32_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_32_1.vb)]"
  syntax:
    content: public long WorkingSet64 { get; }
    return:
      type: System.Int64
      description: "De hoeveelheid fysiek geheugen in bytes, voor het bijbehorende proces is toegewezen."
  overload: System.Diagnostics.Process.WorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Het platform is Windows 98 of Windows ME (Windows Me), die geen ondersteuning biedt voor deze eigenschap."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.Diagnostics.Process.#ctor
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
- uid: System.Diagnostics.Process.BasePriority
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.Process.BeginErrorReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
- uid: System.Diagnostics.Process.BeginOutputReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
- uid: System.Diagnostics.Process.CancelErrorRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
- uid: System.Diagnostics.Process.CancelOutputRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
- uid: System.Diagnostics.Process.Close
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
- uid: System.Diagnostics.Process.CloseMainWindow
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
- uid: System.Diagnostics.Process.EnableRaisingEvents
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
- uid: System.Diagnostics.Process.ErrorDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
- uid: System.Diagnostics.DataReceivedEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: DataReceivedEventHandler
  nameWithType: DataReceivedEventHandler
  fullName: System.Diagnostics.DataReceivedEventHandler
- uid: System.Diagnostics.Process.ExitCode
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
- uid: System.Diagnostics.Process.Exited
  parent: System.Diagnostics.Process
  isExternal: false
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Diagnostics.Process.ExitTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.Process.GetCurrentProcess
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
- uid: System.Diagnostics.Process
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.Process.GetProcesses
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
- uid: System.Diagnostics.Process[]
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process[]
  spec.csharp:
  - uid: System.Diagnostics.Process
    name: Process
    nameWithType: Process
    fullName: Process[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
- uid: System.Diagnostics.Process.Handle
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.Process.HandleCount
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
- uid: System.Diagnostics.Process.HasExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
- uid: System.Diagnostics.Process.Id
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
- uid: System.Diagnostics.Process.Kill
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
- uid: System.Diagnostics.Process.LeaveDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
- uid: System.Diagnostics.Process.MachineName
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
- uid: System.Diagnostics.Process.MainModule
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
- uid: System.Diagnostics.ProcessModule
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModule
  nameWithType: ProcessModule
  fullName: System.Diagnostics.ProcessModule
- uid: System.Diagnostics.Process.MainWindowHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
- uid: System.Diagnostics.ProcessModuleCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModuleCollection
  nameWithType: ProcessModuleCollection
  fullName: System.Diagnostics.ProcessModuleCollection
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.Process.OnExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
- uid: System.Diagnostics.Process.OutputDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
- uid: System.Diagnostics.Process.PagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
- uid: System.Diagnostics.ProcessPriorityClass
  parent: System.Diagnostics
  isExternal: false
  name: ProcessPriorityClass
  nameWithType: ProcessPriorityClass
  fullName: System.Diagnostics.ProcessPriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.Process.ProcessName
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
- uid: System.Diagnostics.Process.Responding
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
- uid: System.Diagnostics.Process.SafeHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
- uid: Microsoft.Win32.SafeHandles.SafeProcessHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeProcessHandle
  nameWithType: SafeProcessHandle
  fullName: Microsoft.Win32.SafeHandles.SafeProcessHandle
- uid: System.Diagnostics.Process.SessionId
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
- uid: System.Diagnostics.Process.StandardError
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.Diagnostics.Process.StandardInput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.Diagnostics.Process.StandardOutput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
- uid: System.Diagnostics.Process.Start
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
- uid: System.Diagnostics.ProcessStartInfo
  parent: System.Diagnostics
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
- uid: System.Diagnostics.Process.Start(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
- uid: System.Diagnostics.Process.StartInfo
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
- uid: System.Diagnostics.Process.StartTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.Process.Threads
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
- uid: System.Diagnostics.ProcessThreadCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessThreadCollection
  nameWithType: ProcessThreadCollection
  fullName: System.Diagnostics.ProcessThreadCollection
- uid: System.Diagnostics.Process.ToString
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
- uid: System.Diagnostics.Process.TotalProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
- uid: System.Diagnostics.Process.WaitForInputIdle
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
- uid: System.Diagnostics.Process.WorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
- uid: System.Diagnostics.Process.#ctor*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process
  nameWithType: Process.Process
- uid: System.Diagnostics.Process.BasePriority*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
- uid: System.Diagnostics.Process.BeginErrorReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine
  nameWithType: Process.BeginErrorReadLine
- uid: System.Diagnostics.Process.BeginOutputReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine
  nameWithType: Process.BeginOutputReadLine
- uid: System.Diagnostics.Process.CancelErrorRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead
  nameWithType: Process.CancelErrorRead
- uid: System.Diagnostics.Process.CancelOutputRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead
  nameWithType: Process.CancelOutputRead
- uid: System.Diagnostics.Process.Close*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close
  nameWithType: Process.Close
- uid: System.Diagnostics.Process.CloseMainWindow*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow
  nameWithType: Process.CloseMainWindow
- uid: System.Diagnostics.Process.Dispose*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose
  nameWithType: Process.Dispose
- uid: System.Diagnostics.Process.EnableRaisingEvents*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode
  nameWithType: Process.EnterDebugMode
- uid: System.Diagnostics.Process.ExitCode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
- uid: System.Diagnostics.Process.ExitTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
- uid: System.Diagnostics.Process.GetCurrentProcess*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess
  nameWithType: Process.GetCurrentProcess
- uid: System.Diagnostics.Process.GetProcessById*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById
  nameWithType: Process.GetProcessById
- uid: System.Diagnostics.Process.GetProcesses*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses
  nameWithType: Process.GetProcesses
- uid: System.Diagnostics.Process.GetProcessesByName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName
  nameWithType: Process.GetProcessesByName
- uid: System.Diagnostics.Process.Handle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
- uid: System.Diagnostics.Process.HandleCount*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
- uid: System.Diagnostics.Process.HasExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
- uid: System.Diagnostics.Process.Id*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
- uid: System.Diagnostics.Process.Kill*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill
  nameWithType: Process.Kill
- uid: System.Diagnostics.Process.LeaveDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode
  nameWithType: Process.LeaveDebugMode
- uid: System.Diagnostics.Process.MachineName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
- uid: System.Diagnostics.Process.MainModule*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
- uid: System.Diagnostics.Process.MainWindowHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
- uid: System.Diagnostics.Process.OnExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited
  nameWithType: Process.OnExited
- uid: System.Diagnostics.Process.PagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
- uid: System.Diagnostics.Process.ProcessName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh
  nameWithType: Process.Refresh
- uid: System.Diagnostics.Process.Responding*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
- uid: System.Diagnostics.Process.SafeHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
- uid: System.Diagnostics.Process.SessionId*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
- uid: System.Diagnostics.Process.StandardError*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
- uid: System.Diagnostics.Process.StandardInput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
- uid: System.Diagnostics.Process.StandardOutput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
- uid: System.Diagnostics.Process.Start*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start
  nameWithType: Process.Start
- uid: System.Diagnostics.Process.StartInfo*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
- uid: System.Diagnostics.Process.StartTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
- uid: System.Diagnostics.Process.Threads*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
- uid: System.Diagnostics.Process.ToString*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString
  nameWithType: Process.ToString
- uid: System.Diagnostics.Process.TotalProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit
  nameWithType: Process.WaitForExit
- uid: System.Diagnostics.Process.WaitForInputIdle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle
  nameWithType: Process.WaitForInputIdle
- uid: System.Diagnostics.Process.WorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
