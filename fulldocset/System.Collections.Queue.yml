### YamlMime:ManagedReference
items:
- uid: System.Collections.Queue
  id: Queue
  children:
  - System.Collections.Queue.#ctor
  - System.Collections.Queue.#ctor(System.Collections.ICollection)
  - System.Collections.Queue.#ctor(System.Int32)
  - System.Collections.Queue.#ctor(System.Int32,System.Single)
  - System.Collections.Queue.Clear
  - System.Collections.Queue.Clone
  - System.Collections.Queue.Contains(System.Object)
  - System.Collections.Queue.CopyTo(System.Array,System.Int32)
  - System.Collections.Queue.Count
  - System.Collections.Queue.Dequeue
  - System.Collections.Queue.Enqueue(System.Object)
  - System.Collections.Queue.GetEnumerator
  - System.Collections.Queue.IsSynchronized
  - System.Collections.Queue.Peek
  - System.Collections.Queue.Synchronized(System.Collections.Queue)
  - System.Collections.Queue.SyncRoot
  - System.Collections.Queue.ToArray
  - System.Collections.Queue.TrimToSize
  langs:
  - csharp
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
  type: Class
  summary: "Een collectie first in, First-out &quot;-objecten."
  remarks: "Deze klasse wordt een wachtrij geïmplementeerd als een circulaire matrix. Objecten die zijn opgeslagen in een wachtrij zijn ingevoegd aan het ene uiteinde en verwijderd uit de andere.       Wachtrijen en stacks zijn nuttig wanneer u nodig hebt als tijdelijke opslag voor gegevens; dat wil zeggen, wanneer u mogelijk wilt negeren een element bij het ophalen van de waarde ervan. Wachtrij gebruiken als u nodig hebt voor toegang tot de gegevens in dezelfde volgorde als waarin deze is opgeslagen in de verzameling. Gebruik <xref:System.Collections.Stack>Als u toegang wilt tot de informatie in omgekeerde volgorde.</xref:System.Collections.Stack> Gebruik <xref:System.Collections.Concurrent.ConcurrentQueue%601>of <xref:System.Collections.Concurrent.ConcurrentStack%601>Als u toegang wilt tot de verzameling vanuit meerdere threads gelijktijdig.</xref:System.Collections.Concurrent.ConcurrentStack%601> </xref:System.Collections.Concurrent.ConcurrentQueue%601>       Drie belangrijkste bewerkingen kunnen worden uitgevoerd op een wachtrij en de bijbehorende elementen:- <xref:System.Collections.Queue.Enqueue%2A>een element toegevoegd aan het einde van de wachtrij.</xref:System.Collections.Queue.Enqueue%2A>      - <xref:System.Collections.Queue.Dequeue%2A>wordt het oudste element vanaf het begin van de wachtrij verwijderd.</xref:System.Collections.Queue.Dequeue%2A>      - <xref:System.Collections.Queue.Peek%2A>wordt het oudste geretourneerd die aan het begin van de wachtrij, maar niet uit de wachtrij verwijderd.</xref:System.Collections.Queue.Peek%2A>       De capaciteit van een wachtrij is het aantal elementen dat de wachtrij kan bevatten. Als elementen worden toegevoegd aan een wachtrij, de capaciteit automatisch wordt verhoogd door Hertoewijzing zoals wordt vereist.  De capaciteit kan door het aanroepen van <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> worden verlaagd.       De groeifactor is het aantal waarmee de huidige capaciteit wordt vermenigvuldigd wanneer een grotere capaciteit vereist is.  De groeifactor wordt bepaald wanneer de wachtrij is samengesteld. De groeifactor van de standaardwaarde is 2.0. De capaciteit van de wachtrij wordt altijd vergroten door ten minste ten minste vier, ongeacht de groeifactor. Bijvoorbeeld, wordt een wachtrij met een groeifactor van 1.0 altijd vergroten capaciteit door vier wanneer een grotere capaciteit vereist is.       Wachtrij accepteert `null` als een geldige waarde en dubbele elementen zijn toegestaan.       Zie voor de algemene versie van deze verzameling<xref:System.Collections.Generic.Queue%601?displayProperty=fullName></xref:System.Collections.Generic.Queue%601?displayProperty=fullName>"
  example:
  - "The following example shows how to create and add values to a Queue and how to print out its values.  \n  \n [!code-cs[Classic Queue Example#1](~/add/codesnippet/csharp/t-system.collections.queue_1.cs)]\n [!code-cpp[Classic Queue Example#1](~/add/codesnippet/cpp/t-system.collections.queue_1.cpp)]\n [!code-vb[Classic Queue Example#1](~/add/codesnippet/visualbasic/t-system.collections.queue_1.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Queue : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor
  id: '#ctor'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Collections.Queue&quot;> </xref> klasse die leeg is, is de initiële standaardcapaciteit en de groeifactor standaard gebruikt."
  remarks: "De capaciteit van een <xref:System.Collections.Queue>is het aantal elementen de <xref:System.Collections.Queue>kan bevatten.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Wanneer elementen worden toegevoegd aan een <xref:System.Collections.Queue>, de capaciteit automatisch verhoogd zoals vereist door Hertoewijzing.</xref:System.Collections.Queue>  De capaciteit kan door het aanroepen van <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> worden verlaagd.       De groeifactor is het aantal waarmee de huidige capaciteit wordt vermenigvuldigd wanneer een grotere capaciteit vereist is.  De groeifactor wordt bepaald wanneer de <xref:System.Collections.Queue>is samengesteld.</xref:System.Collections.Queue>       Deze constructor is een bewerking O(1)."
  syntax:
    content: public Queue ();
    parameters: []
  overload: System.Collections.Queue.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Collections.Queue&quot;> </xref> klasse die elementen die zijn gekopieerd uit de opgegeven verzameling bevat de dezelfde begincapaciteit als het aantal elementen die zijn gekopieerd, gebruikt, en de groeifactor standaard."
  remarks: "De capaciteit van een <xref:System.Collections.Queue>is het aantal elementen de <xref:System.Collections.Queue>kan bevatten.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Wanneer elementen worden toegevoegd aan een <xref:System.Collections.Queue>, de capaciteit automatisch verhoogd zoals vereist door Hertoewijzing.</xref:System.Collections.Queue>  De capaciteit kan door het aanroepen van <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> worden verlaagd.       De groeifactor is het aantal waarmee de huidige capaciteit wordt vermenigvuldigd wanneer een grotere capaciteit vereist is.  De groeifactor wordt bepaald wanneer de <xref:System.Collections.Queue>is samengesteld.</xref:System.Collections.Queue>       De elementen zijn gekopieerd naar de <xref:System.Collections.Queue>in dezelfde volgorde als die ze worden gelezen door de <xref:System.Collections.IEnumerator>van de <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> </xref:System.Collections.Queue>       Deze constructor is een O (`n`)-bewerking, waarbij `n` is het aantal elementen in `col`."
  syntax:
    content: public Queue (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "De <xref:System.Collections.ICollection>kopiëren van elementen uit.</xref:System.Collections.ICollection>"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Collections.Queue&quot;> </xref> klasse die leeg is, heeft de opgegeven capaciteit van de eerste en de groeifactor standaard gebruikt."
  remarks: "De capaciteit van een <xref:System.Collections.Queue>is het aantal elementen de <xref:System.Collections.Queue>kan bevatten.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Wanneer elementen worden toegevoegd aan een <xref:System.Collections.Queue>, de capaciteit automatisch verhoogd zoals vereist door Hertoewijzing.</xref:System.Collections.Queue>  De capaciteit kan door het aanroepen van <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> worden verlaagd.       De groeifactor is het aantal waarmee de huidige capaciteit wordt vermenigvuldigd wanneer een grotere capaciteit vereist is.  De groeifactor wordt bepaald wanneer de <xref:System.Collections.Queue>is samengesteld.</xref:System.Collections.Queue>       Als de grootte van de verzameling kan worden geschat, voorkomen geven de begincapaciteit moet een aantal formaatwijzigingen bij het toevoegen van elementen in de <xref:System.Collections.Queue>.</xref:System.Collections.Queue> uitvoeren       Deze constructor is een O (`n`)-bewerking, waarbij `n` is `capacity`."
  syntax:
    content: public Queue (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Het eerste aantal elementen die de <xref href=&quot;System.Collections.Queue&quot;> </xref> kan bevatten."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>is kleiner dan nul."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Collections.Queue&quot;> </xref> klasse die leeg is, heeft de opgegeven capaciteit van de eerste en maakt gebruik van de opgegeven groeifactor."
  remarks: "De capaciteit van een <xref:System.Collections.Queue>is het aantal elementen de <xref:System.Collections.Queue>kan bevatten.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Wanneer elementen worden toegevoegd aan een <xref:System.Collections.Queue>, de capaciteit automatisch verhoogd zoals vereist door Hertoewijzing.</xref:System.Collections.Queue>  De capaciteit kan door het aanroepen van <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> worden verlaagd.       De groeifactor is het aantal waarmee de huidige capaciteit wordt vermenigvuldigd wanneer een grotere capaciteit vereist is.  De groeifactor wordt bepaald wanneer de <xref:System.Collections.Queue>is samengesteld.</xref:System.Collections.Queue> De capaciteit van de <xref:System.Collections.Queue>altijd wordt verhoogd door een minimumwaarde instelt, ongeacht de groeifactor; een groeifactor van 1.0 voorkomt niet dat de <xref:System.Collections.Queue>uit in omvang toeneemt.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Als de grootte van de verzameling kan worden geschat, voorkomen geven de begincapaciteit moet een aantal formaatwijzigingen bij het toevoegen van elementen in de <xref:System.Collections.Queue>.</xref:System.Collections.Queue> uitvoeren       Deze constructor is een O (`n`)-bewerking, waarbij `n` is `capacity`."
  syntax:
    content: public Queue (int capacity, float growFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Het eerste aantal elementen die de <xref href=&quot;System.Collections.Queue&quot;> </xref> kan bevatten."
    - id: growFactor
      type: System.Single
      description: "De factor in waarmee de capaciteit van de <xref href=&quot;System.Collections.Queue&quot;> </xref> is uitgevouwen."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>is kleiner dan nul.       - of - <code>growFactor</code> kleiner is dan 1.0 of groter zijn dan 10.0."
  platform:
  - net462
- uid: System.Collections.Queue.Clear
  id: Clear
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hiermee verwijdert u alle objecten van de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "<xref:System.Collections.Queue.Count%2A>is ingesteld op nul en verwijzingen naar andere objecten in de elementen van de verzameling ook worden vrijgegeven.</xref:System.Collections.Queue.Count%2A>       De capaciteit blijft ongewijzigd. De capaciteit van de <xref:System.Collections.Queue>bel <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> </xref:System.Collections.Queue> opnieuw instellen Een lege bijsnijden <xref:System.Collections.Queue>Hiermee stelt u de capaciteit van de <xref:System.Collections.Queue>naar de standaardcapaciteit.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Deze methode is een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.que_6_1.cpp)]\n [!code-cs[Classic Queue.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.que_6_1.cs)]\n [!code-vb[Classic Queue.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_6_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Queue.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Clone
  id: Clone
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Maakt een recente kopie van de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Een recente kopie van een verzameling kopieert alleen de elementen van de verzameling of ze verwijzingstypen of typen zijn, maar deze worden niet gekopieerd door de objecten die de verwijzingen naar verwijzen. De verwijzingen in de nieuwe verzameling verwijzen naar dezelfde objecten die de verwijzingen in de oorspronkelijke verzameling naar verwijzen.       Daarentegen een diepe kopie van een verzameling kopieert de elementen en alles direct of indirect waarnaar wordt verwezen door de elementen.       Deze methode is een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Een recente kopie van de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hiermee wordt bepaald of een element in de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Deze methode bepaalt gelijkheid door het aanroepen van <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Deze methode voert een lineaire zoeken; Deze methode is daarom een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>       Beginnen met .NET Framework 2.0, deze methode maakt gebruik van een verzameling objecten <xref:System.Object.Equals%2A>en <xref:System.IComparable.CompareTo%2A>methoden op `obj` om te bepalen of `item` bestaat.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> In eerdere versies van .NET Framework, deze beslissing is gemaakt met behulp van de <xref:System.Object.Equals%2A>en <xref:System.IComparable.CompareTo%2A>methoden van de `obj` parameter voor de objecten in de verzameling.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "De <xref:System.Object>te vinden in de <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Object> De waarde kan zijn <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>obj</code> is found in the <xref href=&quot;System.Collections.Queue&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Queue.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopieert de <xref href=&quot;System.Collections.Queue&quot;> </xref> elementen aan een bestaande eendimensionale <xref:System.Array>, te beginnen bij de index van de opgegeven matrix.</xref:System.Array>"
  remarks: "De elementen zijn gekopieerd naar de <xref:System.Array>in dezelfde volgorde als waarin de enumerator de <xref:System.Collections.Queue>.</xref:System.Collections.Queue> doorloopt</xref:System.Array>       Deze methode is een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_4_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_4_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_4_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "De eendimensionale <xref:System.Array>die het doel van de elementen die zijn gekopieerd uit <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Array> De <xref:System.Array>moet hebben op nul gebaseerde indexering.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "De op nul gebaseerde index in `array` welke kopiëren begint."
  overload: System.Collections.Queue.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>is kleiner dan nul."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>is multidimensionaal.       - of - het aantal elementen in de bron <xref href=&quot;System.Collections.Queue&quot;> </xref> groter is dan de beschikbare ruimte vanaf <code>index</code> aan het einde van de bestemming <code>array</code>."
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "Het type van de bron <xref href=&quot;System.Collections.Queue&quot;> </xref> kan niet automatisch worden geconverteerd naar het type van de bestemming <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Queue.Count
  id: Count
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hiermee wordt het aantal elementen in de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "De capaciteit van een <xref:System.Collections.Queue>is het aantal elementen die de <xref:System.Collections.Queue>kunt opslaan.</xref:System.Collections.Queue> </xref:System.Collections.Queue> Aantal is het aantal elementen die daadwerkelijk in de <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       De capaciteit van een <xref:System.Collections.Queue>altijd is groter dan of gelijk aan Count.</xref:System.Collections.Queue> Als het aantal hoger is dan de capaciteit tijdens het toevoegen van elementen, wordt de capaciteit automatisch verhoogd met het opnieuw toewijzen van de interne matrix voordat de oude elementen kopiëren en toevoegen van nieuwe elementen. De nieuwe capaciteit wordt bepaald door de huidige capaciteit vermenigvuldigen met de groeifactor die wordt bepaald wanneer de <xref:System.Collections.Queue>is samengesteld.</xref:System.Collections.Queue> De capaciteit van de <xref:System.Collections.Queue>altijd wordt verhoogd door een minimumwaarde instelt, ongeacht de groeifactor; een groeifactor van 1.0 voorkomt niet dat de <xref:System.Collections.Queue>uit in omvang toeneemt.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       De capaciteit kan door het aanroepen van <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> worden verlaagd.       Ophalen van de waarde van deze eigenschap is een O(1)-bewerking."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "Het aantal elementen in de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Dequeue
  id: Dequeue
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Verwijdert en retourneert het object aan het begin van de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Deze methode is vergelijkbaar met de <xref:System.Collections.Queue.Peek%2A>methode, maar <xref:System.Collections.Queue.Peek%2A>niet de <xref:System.Collections.Queue>.</xref:System.Collections.Queue> wijzigt</xref:System.Collections.Queue.Peek%2A> </xref:System.Collections.Queue.Peek%2A>       `null`kan worden toegevoegd aan de <xref:System.Collections.Queue>als een waarde.</xref:System.Collections.Queue> Onderscheid maken tussen een null-waarde en het einde van de <xref:System.Collections.Queue>, Controleer de <xref:System.Collections.Queue.Count%2A>eigenschap of catch de <xref:System.InvalidOperationException>, die wordt gegenereerd wanneer de <xref:System.Collections.Queue>is leeg.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Deze methode is een bewerking O(1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_0_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_0_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_0_1.cpp)]"
  syntax:
    content: public virtual object Dequeue ();
    parameters: []
    return:
      type: System.Object
      description: "Het object dat wordt verwijderd uit het begin van de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Dequeue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De <xref href=&quot;System.Collections.Queue&quot;> </xref> is leeg."
  platform:
  - net462
- uid: System.Collections.Queue.Enqueue(System.Object)
  id: Enqueue(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Een object toegevoegd aan het einde van de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "De capaciteit van een <xref:System.Collections.Queue>is het aantal elementen de <xref:System.Collections.Queue>kan bevatten.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Wanneer elementen worden toegevoegd aan een <xref:System.Collections.Queue>, de capaciteit automatisch verhoogd zoals vereist door Hertoewijzing.</xref:System.Collections.Queue>  De capaciteit kan door het aanroepen van <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> worden verlaagd.       De groeifactor is het aantal waarmee de huidige capaciteit wordt vermenigvuldigd wanneer een grotere capaciteit vereist is.  De groeifactor wordt bepaald wanneer de <xref:System.Collections.Queue>is samengesteld.</xref:System.Collections.Queue> De capaciteit van de <xref:System.Collections.Queue>altijd wordt verhoogd door een minimumwaarde instelt, ongeacht de groeifactor; een groeifactor van 1.0 voorkomt niet dat de <xref:System.Collections.Queue>uit in omvang toeneemt.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Als <xref:System.Collections.Queue.Count%2A>is kleiner dan de capaciteit van de interne matrix deze methode is een bewerking O(1).</xref:System.Collections.Queue.Count%2A> Als de interne matrix opnieuw worden toegewezen moet aan het nieuwe element, deze methode wordt een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_5_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_5_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_5_1.cpp)]"
  syntax:
    content: public virtual void Enqueue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Het object toevoegen aan de <xref href=&quot;System.Collections.Queue&quot;> </xref>. De waarde kan zijn <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.Enqueue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Queue
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Retourneert een enumerator die doorloopt de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "De `foreach` -instructie van de taal C# (`for each` in Visual Basic) de complexiteit van de opsommingen worden verborgen.  Daarom kan het gebruik `foreach` wordt aanbevolen, in plaats van rechtstreeks bewerken van de enumerator.       Enumerators kunnen worden gebruikt om de gegevens in de verzameling te lezen, maar ze kunnen niet worden gebruikt om de onderliggende verzameling niet wijzigen.       In eerste instantie bevindt de enumerator zich vóór het eerste element in de verzameling. <xref:System.Collections.IEnumerator.Reset%2A>brengt ook de enumerator terug naar deze positie.</xref:System.Collections.IEnumerator.Reset%2A>  Op deze positie <xref:System.Collections.IEnumerator.Current%2A>is niet gedefinieerd.</xref:System.Collections.IEnumerator.Current%2A> U moet daarom aanroepen <xref:System.Collections.IEnumerator.MoveNext%2A>om door te gaan van de enumerator voor het eerste element van de verzameling voordat het lezen van <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>retourneert de hetzelfde object totdat de <xref:System.Collections.IEnumerator.MoveNext%2A>of <xref:System.Collections.IEnumerator.Reset%2A>wordt aangeroepen.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Hiermee stelt u <xref:System.Collections.IEnumerator.Current%2A>naar het volgende element.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Als <xref:System.Collections.IEnumerator.MoveNext%2A>geeft het einde van de verzameling, de enumerator bevindt zich na het laatste element in de verzameling en <xref:System.Collections.IEnumerator.MoveNext%2A>retourneert `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Wanneer de enumerator is op deze positie, volgende aanroepen naar <xref:System.Collections.IEnumerator.MoveNext%2A>ook retourneren `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Als de laatste aanroep aan <xref:System.Collections.IEnumerator.MoveNext%2A>geretourneerd `false`, <xref:System.Collections.IEnumerator.Current%2A>is niet gedefinieerd.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Current%2A>U kunt naar het eerste element van de verzameling opnieuw aanroepen <xref:System.Collections.IEnumerator.Reset%2A>gevolgd door <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A> instellen       Een enumerator blijft geldig zolang de verzameling ongewijzigd blijft. Als er wijzigingen zijn aangebracht aan de verzameling, zoals het toevoegen, wijzigen of verwijderen van elementen, de enumerator is permanent ongeldig en het gedrag is niet gedefinieerd.       De enumerator heeft geen exclusieve toegang tot de verzameling; inventariseren door middel van een verzameling is daarom intrinsiek geen procedure thread-safe.  Om te garanderen thread veiligheid tijdens de opsomming, vergrendelt u de verzameling gedurende de volledige inventarisatie.  Als u wilt toestaan dat de verzameling worden geopend door meerdere threads voor lezen en schrijven, moet u uw eigen synchronisatie implementeren.       Deze methode is een bewerking O(1)."
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Queue&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Queue.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Queue
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Haalt een waarde die aangeeft of de toegang tot de <xref href=&quot;System.Collections.Queue&quot;> </xref> is gesynchroniseerd (thread-veilig)."
  remarks: "Om te waarborgen van de veiligheid van de thread van de <xref:System.Collections.Queue>, alle bewerkingen moeten worden uitgevoerd via de wrapper die is geretourneerd door de <xref:System.Collections.Queue.Synchronized%2A>methode.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue>       Inventariseren door middel van een verzameling is intrinsiek niet een thread-veilige procedure. Zelfs wanneer een verzameling wordt gesynchroniseerd, andere threads kunnen nog steeds de verzameling niet wijzigen, waardoor de enumerator is een uitzondering. Om te garanderen thread veiligheid tijdens de opsomming, moet u de verzameling tijdens de gehele opsomming vergrendelen of het gevolg van wijzigingen die door andere threads uitzonderingen wordt onderschept."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_0_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_0_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_0_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized, and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.que_0_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.que_0_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.que_0_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de toegang tot de <xref href=&quot;System.Collections.Queue&quot;> </xref> is gesynchroniseerd (thread-safe); anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. De standaardwaarde is <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Peek
  id: Peek
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Retourneert het object aan het begin van de <xref href=&quot;System.Collections.Queue&quot;> </xref> zonder het te verwijderen."
  remarks: "Deze methode is vergelijkbaar met de <xref:System.Collections.Queue.Dequeue%2A>methode, maar Peek de <xref:System.Collections.Queue>.</xref:System.Collections.Queue> niet wijzigen</xref:System.Collections.Queue.Dequeue%2A>       `null`kan worden toegevoegd aan de <xref:System.Collections.Queue>als een waarde.</xref:System.Collections.Queue> Onderscheid maken tussen een null-waarde en het einde van de <xref:System.Collections.Queue>, Controleer de <xref:System.Collections.Queue.Count%2A>eigenschap of catch de <xref:System.InvalidOperationException>, die wordt gegenereerd wanneer de <xref:System.Collections.Queue>is leeg.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Deze methode is een bewerking O(1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_1_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_1_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_1_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "Het object aan het begin van de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "De <xref href=&quot;System.Collections.Queue&quot;> </xref> is leeg."
  platform:
  - net462
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  id: Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Retourneert een nieuwe <xref href=&quot;System.Collections.Queue&quot;> </xref> die de oorspronkelijke wachtrij verpakt en thread-veilig is."
  remarks: "De wrapper die is geretourneerd door deze methode wordt de wachtrij vergrendeld voordat een bewerking wordt uitgevoerd, zodat deze wordt uitgevoerd op een thread-veilige manier.       Om te waarborgen van de veiligheid van de thread van de <xref:System.Collections.Queue>, alle bewerkingen via deze wrapper alleen moeten worden uitgevoerd.</xref:System.Collections.Queue>       Inventariseren door middel van een verzameling is intrinsiek niet een thread-veilige procedure. Zelfs wanneer een verzameling wordt gesynchroniseerd, andere threads kunnen nog steeds de verzameling niet wijzigen, waardoor de enumerator is een uitzondering. Om te garanderen thread veiligheid tijdens de opsomming, moet u de verzameling tijdens de gehele opsomming vergrendelen of het gevolg van wijzigingen die door andere threads uitzonderingen wordt onderschept."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. This method is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.que_3_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.que_3_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.que_3_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.que_3_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.que_3_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_3_2.vb)]"
  syntax:
    content: public static System.Collections.Queue Synchronized (System.Collections.Queue queue);
    parameters:
    - id: queue
      type: System.Collections.Queue
      description: "De <xref href=&quot;System.Collections.Queue&quot;> </xref> om te synchroniseren."
    return:
      type: System.Collections.Queue
      description: "Een <xref href=&quot;System.Collections.Queue&quot;> </xref> wrapper die is gesynchroniseerd (thread-veilig)."
  overload: System.Collections.Queue.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>queue</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.SyncRoot
  id: SyncRoot
  parent: System.Collections.Queue
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Haalt een object dat kan worden gebruikt voor het synchroniseren van toegang tot de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Maken van een gesynchroniseerde versie van de <xref:System.Collections.Queue>, gebruiken de <xref:System.Collections.Queue.Synchronized%2A>methode.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue> Afgeleide klassen kunnen evenwel de eigen gesynchroniseerde versie van de <xref:System.Collections.Queue>met behulp van de eigenschap SyncRoot.</xref:System.Collections.Queue> De code voor het synchroniseren moet bewerkingen uitvoeren op de SyncRoot van de <xref:System.Collections.Queue>, niet rechtstreeks op de <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue> Dit zorgt ervoor dat de juiste werking van de verzamelingen die zijn afgeleid van andere objecten. In het bijzonder houdt juiste synchronisatie met andere threads dat tegelijkertijd kan worden wijzigt de <xref:System.Collections.Queue>object.</xref:System.Collections.Queue>       Inventariseren door middel van een verzameling is intrinsiek niet een thread-veilige procedure. Zelfs wanneer een verzameling wordt gesynchroniseerd, andere threads kunnen nog steeds de verzameling niet wijzigen, waardoor de enumerator is een uitzondering. Om te garanderen thread veiligheid tijdens de opsomming, moet u de verzameling tijdens de gehele opsomming vergrendelen of het gevolg van wijzigingen die door andere threads uitzonderingen wordt onderschept."
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_1_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_1_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_1_1.vb)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Een object dat kan worden gebruikt voor het synchroniseren van toegang tot de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.ToArray
  id: ToArray
  parent: System.Collections.Queue
  langs:
  - csharp
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopieert de <xref href=&quot;System.Collections.Queue&quot;> </xref> elementen naar een nieuwe matrix."
  remarks: "De <xref:System.Collections.Queue>is niet gewijzigd.</xref:System.Collections.Queue> De volgorde van de elementen in de nieuwe matrix is hetzelfde als de volgorde van de elementen van het begin van de <xref:System.Collections.Queue>tot het einde.</xref:System.Collections.Queue>       Deze methode is een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_2_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_2_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_2_1.vb)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "Een nieuwe matrix met van elementen die zijn gekopieerd uit de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.ToArray*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.TrimToSize
  id: TrimToSize
  parent: System.Collections.Queue
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Hiermee stelt u de capaciteit aan het werkelijke aantal elementen in de <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Deze methode kan worden gebruikt om te minimaliseren van een wachtrij geheugen overhead als er geen nieuwe gegevens worden toegevoegd aan de wachtrij.       Om in te stellen een <xref:System.Collections.Queue>aanroepen naar de oorspronkelijke staat de <xref:System.Collections.Queue.Clear%2A>methode voordat u TrimToSize aanroept.</xref:System.Collections.Queue.Clear%2A> </xref:System.Collections.Queue> Een lege bijsnijden <xref:System.Collections.Queue>Hiermee stelt u de capaciteit van de <xref:System.Collections.Queue>naar de standaardcapaciteit.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Deze methode is een O (`n`)-bewerking, waarbij `n` is <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.Queue.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "De <xref href=&quot;System.Collections.Queue&quot;> </xref> is alleen-lezen."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArrayTypeMismatchException
  isExternal: true
  name: System.ArrayTypeMismatchException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Collections.Queue.#ctor
  parent: System.Collections.Queue
  isExternal: false
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Queue.#ctor(System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Queue.Clear
  parent: System.Collections.Queue
  isExternal: false
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
- uid: System.Collections.Queue.Clone
  parent: System.Collections.Queue
  isExternal: false
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
- uid: System.Collections.Queue.Contains(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Queue.Count
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
- uid: System.Collections.Queue.Dequeue
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
- uid: System.Collections.Queue.Enqueue(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
- uid: System.Collections.Queue.GetEnumerator
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Queue.IsSynchronized
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
- uid: System.Collections.Queue.Peek
  parent: System.Collections.Queue
  isExternal: false
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
- uid: System.Collections.Queue
  parent: System.Collections
  isExternal: false
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
- uid: System.Collections.Queue.SyncRoot
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
- uid: System.Collections.Queue.ToArray
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Queue.TrimToSize
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
- uid: System.Collections.Queue.#ctor*
  parent: System.Collections.Queue
  isExternal: false
  name: Queue
  nameWithType: Queue.Queue
- uid: System.Collections.Queue.Clear*
  parent: System.Collections.Queue
  isExternal: false
  name: Clear
  nameWithType: Queue.Clear
- uid: System.Collections.Queue.Clone*
  parent: System.Collections.Queue
  isExternal: false
  name: Clone
  nameWithType: Queue.Clone
- uid: System.Collections.Queue.Contains*
  parent: System.Collections.Queue
  isExternal: false
  name: Contains
  nameWithType: Queue.Contains
- uid: System.Collections.Queue.CopyTo*
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo
  nameWithType: Queue.CopyTo
- uid: System.Collections.Queue.Count*
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
- uid: System.Collections.Queue.Dequeue*
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue
  nameWithType: Queue.Dequeue
- uid: System.Collections.Queue.Enqueue*
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue
  nameWithType: Queue.Enqueue
- uid: System.Collections.Queue.GetEnumerator*
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator
  nameWithType: Queue.GetEnumerator
- uid: System.Collections.Queue.IsSynchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
- uid: System.Collections.Queue.Peek*
  parent: System.Collections.Queue
  isExternal: false
  name: Peek
  nameWithType: Queue.Peek
- uid: System.Collections.Queue.Synchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized
  nameWithType: Queue.Synchronized
- uid: System.Collections.Queue.SyncRoot*
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
- uid: System.Collections.Queue.ToArray*
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray
  nameWithType: Queue.ToArray
- uid: System.Collections.Queue.TrimToSize*
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize
  nameWithType: Queue.TrimToSize
