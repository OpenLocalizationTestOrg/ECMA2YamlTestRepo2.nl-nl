### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkContentElement
  id: FrameworkContentElement
  children:
  - System.Windows.FrameworkContentElement.#ctor
  - System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkContentElement.BeginInit
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkContentElement.BindingGroup
  - System.Windows.FrameworkContentElement.BindingGroupProperty
  - System.Windows.FrameworkContentElement.BringIntoView
  - System.Windows.FrameworkContentElement.ContextMenu
  - System.Windows.FrameworkContentElement.ContextMenuClosing
  - System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  - System.Windows.FrameworkContentElement.ContextMenuOpening
  - System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkContentElement.ContextMenuProperty
  - System.Windows.FrameworkContentElement.Cursor
  - System.Windows.FrameworkContentElement.CursorProperty
  - System.Windows.FrameworkContentElement.DataContext
  - System.Windows.FrameworkContentElement.DataContextChanged
  - System.Windows.FrameworkContentElement.DataContextProperty
  - System.Windows.FrameworkContentElement.DefaultStyleKey
  - System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkContentElement.EndInit
  - System.Windows.FrameworkContentElement.FindName(System.String)
  - System.Windows.FrameworkContentElement.FindResource(System.Object)
  - System.Windows.FrameworkContentElement.FocusVisualStyle
  - System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  - System.Windows.FrameworkContentElement.ForceCursor
  - System.Windows.FrameworkContentElement.ForceCursorProperty
  - System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkContentElement.GetUIParentCore
  - System.Windows.FrameworkContentElement.Initialized
  - System.Windows.FrameworkContentElement.InputScope
  - System.Windows.FrameworkContentElement.InputScopeProperty
  - System.Windows.FrameworkContentElement.IsInitialized
  - System.Windows.FrameworkContentElement.IsLoaded
  - System.Windows.FrameworkContentElement.Language
  - System.Windows.FrameworkContentElement.LanguageProperty
  - System.Windows.FrameworkContentElement.Loaded
  - System.Windows.FrameworkContentElement.LoadedEvent
  - System.Windows.FrameworkContentElement.LogicalChildren
  - System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkContentElement.Name
  - System.Windows.FrameworkContentElement.NameProperty
  - System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkContentElement.OverridesDefaultStyle
  - System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkContentElement.Parent
  - System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkContentElement.Resources
  - System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkContentElement.ShouldSerializeResources
  - System.Windows.FrameworkContentElement.ShouldSerializeStyle
  - System.Windows.FrameworkContentElement.SourceUpdated
  - System.Windows.FrameworkContentElement.Style
  - System.Windows.FrameworkContentElement.StyleProperty
  - System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkContentElement.Tag
  - System.Windows.FrameworkContentElement.TagProperty
  - System.Windows.FrameworkContentElement.TargetUpdated
  - System.Windows.FrameworkContentElement.TemplatedParent
  - System.Windows.FrameworkContentElement.ToolTip
  - System.Windows.FrameworkContentElement.ToolTipClosing
  - System.Windows.FrameworkContentElement.ToolTipClosingEvent
  - System.Windows.FrameworkContentElement.ToolTipOpening
  - System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  - System.Windows.FrameworkContentElement.ToolTipProperty
  - System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  - System.Windows.FrameworkContentElement.Unloaded
  - System.Windows.FrameworkContentElement.UnloadedEvent
  - System.Windows.FrameworkContentElement.UnregisterName(System.String)
  - System.Windows.FrameworkContentElement.UpdateDefaultStyle
  langs:
  - csharp
  name: FrameworkContentElement
  nameWithType: FrameworkContentElement
  fullName: System.Windows.FrameworkContentElement
  type: Class
  summary: "FrameworkContentElement is de uitvoering van WPF-framework-niveau en de uitbreiding van de <xref href=&quot;System.Windows.ContentElement&quot;> </xref> basisklasse. FrameworkContentElement voegt ondersteuning toe voor extra invoer [!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)] (inclusief knopinfo en context menu&quot;s), storyboards, gegevenscontext voor gegevensbinding, stijlen ondersteuning en logische structuur helper [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]."
  remarks: "Geen FrameworkContentElement nog een eigen gedrag rendering; te definiëren het instantiëren van een werkelijke FrameworkContentElement-klasse-instantie in code of opmaak is mogelijk maar niets in toont een [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] toepassing [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]. Rendering van logica moet worden opgegeven door de klassen in FrameworkContentElement afgeleide klassen of FrameworkContentElement onderliggende elementen maken als onderdeel van hun inhoudsmodel.       Werkt opzettelijk FrameworkContentElement parallel veel van dezelfde [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] als <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> Opmerking dat bepaalde [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] gevonden op <xref:System.Windows.FrameworkElement>heeft geen een equivalent FrameworkContentElement.</xref:System.Windows.FrameworkElement> Aantal van de <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] zijn voor functionaliteit zoals geometrie-weergave of lay-out die niet relevant zijn voor een FrameworkContentElement.</xref:System.Windows.FrameworkElement>       Het merendeel van de bestaande FrameworkContentElement afgeleide klassen worden gevonden in de <xref:System.Windows.Documents>naamruimte.</xref:System.Windows.Documents> Veel van deze afgeleide klassen implementeren-elementen voor het document stroom model. Bepaalde afgeleide klassen zoals <xref:System.Windows.Documents.Hyperlink>hebben sommige functionaliteit van een besturingselement, maar zijn afgeleid van FrameworkContentElement zodat de besturingselement-achtige-elementen nog steeds aan de stroom-documentobjectmodel deelnemen kunnen.</xref:System.Windows.Documents.Hyperlink>"
  syntax:
    content: >-
      [System.Windows.Markup.RuntimeNameProperty("Name")]

      [System.Windows.Markup.UsableDuringInitialization(true)]

      [System.Windows.Markup.XmlLangProperty("Language")]

      [System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]

      public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.ContentElement
  implements:
  - System.ComponentModel.ISupportInitialize
  - System.Windows.IFrameworkInputElement
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.AllowDrop
  - System.Windows.ContentElement.AllowDropProperty
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.AreAnyTouchesCaptured
  - System.Windows.ContentElement.AreAnyTouchesCapturedProperty
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithin
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOver
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.ContentElement.AreAnyTouchesOver
  - System.Windows.ContentElement.AreAnyTouchesOverProperty
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.CaptureMouse
  - System.Windows.ContentElement.CaptureStylus
  - System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.CommandBindings
  - System.Windows.ContentElement.DragEnter
  - System.Windows.ContentElement.DragEnterEvent
  - System.Windows.ContentElement.DragLeave
  - System.Windows.ContentElement.DragLeaveEvent
  - System.Windows.ContentElement.DragOver
  - System.Windows.ContentElement.DragOverEvent
  - System.Windows.ContentElement.Drop
  - System.Windows.ContentElement.DropEvent
  - System.Windows.ContentElement.Focus
  - System.Windows.ContentElement.Focusable
  - System.Windows.ContentElement.FocusableChanged
  - System.Windows.ContentElement.FocusableProperty
  - System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.ContentElement.GiveFeedback
  - System.Windows.ContentElement.GiveFeedbackEvent
  - System.Windows.ContentElement.GotFocus
  - System.Windows.ContentElement.GotFocusEvent
  - System.Windows.ContentElement.GotKeyboardFocus
  - System.Windows.ContentElement.GotKeyboardFocusEvent
  - System.Windows.ContentElement.GotMouseCapture
  - System.Windows.ContentElement.GotMouseCaptureEvent
  - System.Windows.ContentElement.GotStylusCapture
  - System.Windows.ContentElement.GotStylusCaptureEvent
  - System.Windows.ContentElement.GotTouchCapture
  - System.Windows.ContentElement.GotTouchCaptureEvent
  - System.Windows.ContentElement.HasAnimatedProperties
  - System.Windows.ContentElement.InputBindings
  - System.Windows.ContentElement.IsEnabled
  - System.Windows.ContentElement.IsEnabledChanged
  - System.Windows.ContentElement.IsEnabledCore
  - System.Windows.ContentElement.IsEnabledProperty
  - System.Windows.ContentElement.IsFocused
  - System.Windows.ContentElement.IsFocusedProperty
  - System.Windows.ContentElement.IsInputMethodEnabled
  - System.Windows.ContentElement.IsKeyboardFocused
  - System.Windows.ContentElement.IsKeyboardFocusedChanged
  - System.Windows.ContentElement.IsKeyboardFocusedProperty
  - System.Windows.ContentElement.IsKeyboardFocusWithin
  - System.Windows.ContentElement.IsKeyboardFocusWithinChanged
  - System.Windows.ContentElement.IsKeyboardFocusWithinProperty
  - System.Windows.ContentElement.IsMouseCaptured
  - System.Windows.ContentElement.IsMouseCapturedChanged
  - System.Windows.ContentElement.IsMouseCapturedProperty
  - System.Windows.ContentElement.IsMouseCaptureWithin
  - System.Windows.ContentElement.IsMouseCaptureWithinChanged
  - System.Windows.ContentElement.IsMouseCaptureWithinProperty
  - System.Windows.ContentElement.IsMouseDirectlyOver
  - System.Windows.ContentElement.IsMouseDirectlyOverChanged
  - System.Windows.ContentElement.IsMouseDirectlyOverProperty
  - System.Windows.ContentElement.IsMouseOver
  - System.Windows.ContentElement.IsMouseOverProperty
  - System.Windows.ContentElement.IsStylusCaptured
  - System.Windows.ContentElement.IsStylusCapturedChanged
  - System.Windows.ContentElement.IsStylusCapturedProperty
  - System.Windows.ContentElement.IsStylusCaptureWithin
  - System.Windows.ContentElement.IsStylusCaptureWithinChanged
  - System.Windows.ContentElement.IsStylusCaptureWithinProperty
  - System.Windows.ContentElement.IsStylusDirectlyOver
  - System.Windows.ContentElement.IsStylusDirectlyOverChanged
  - System.Windows.ContentElement.IsStylusDirectlyOverProperty
  - System.Windows.ContentElement.IsStylusOver
  - System.Windows.ContentElement.IsStylusOverProperty
  - System.Windows.ContentElement.KeyDown
  - System.Windows.ContentElement.KeyDownEvent
  - System.Windows.ContentElement.KeyUp
  - System.Windows.ContentElement.KeyUpEvent
  - System.Windows.ContentElement.LostFocus
  - System.Windows.ContentElement.LostFocusEvent
  - System.Windows.ContentElement.LostKeyboardFocus
  - System.Windows.ContentElement.LostKeyboardFocusEvent
  - System.Windows.ContentElement.LostMouseCapture
  - System.Windows.ContentElement.LostMouseCaptureEvent
  - System.Windows.ContentElement.LostStylusCapture
  - System.Windows.ContentElement.LostStylusCaptureEvent
  - System.Windows.ContentElement.LostTouchCapture
  - System.Windows.ContentElement.LostTouchCaptureEvent
  - System.Windows.ContentElement.MouseDown
  - System.Windows.ContentElement.MouseDownEvent
  - System.Windows.ContentElement.MouseEnter
  - System.Windows.ContentElement.MouseEnterEvent
  - System.Windows.ContentElement.MouseLeave
  - System.Windows.ContentElement.MouseLeaveEvent
  - System.Windows.ContentElement.MouseLeftButtonDown
  - System.Windows.ContentElement.MouseLeftButtonDownEvent
  - System.Windows.ContentElement.MouseLeftButtonUp
  - System.Windows.ContentElement.MouseLeftButtonUpEvent
  - System.Windows.ContentElement.MouseMove
  - System.Windows.ContentElement.MouseMoveEvent
  - System.Windows.ContentElement.MouseRightButtonDown
  - System.Windows.ContentElement.MouseRightButtonDownEvent
  - System.Windows.ContentElement.MouseRightButtonUp
  - System.Windows.ContentElement.MouseRightButtonUpEvent
  - System.Windows.ContentElement.MouseUp
  - System.Windows.ContentElement.MouseUpEvent
  - System.Windows.ContentElement.MouseWheel
  - System.Windows.ContentElement.MouseWheelEvent
  - System.Windows.ContentElement.OnCreateAutomationPeer
  - System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.PreviewDragEnter
  - System.Windows.ContentElement.PreviewDragEnterEvent
  - System.Windows.ContentElement.PreviewDragLeave
  - System.Windows.ContentElement.PreviewDragLeaveEvent
  - System.Windows.ContentElement.PreviewDragOver
  - System.Windows.ContentElement.PreviewDragOverEvent
  - System.Windows.ContentElement.PreviewDrop
  - System.Windows.ContentElement.PreviewDropEvent
  - System.Windows.ContentElement.PreviewGiveFeedback
  - System.Windows.ContentElement.PreviewGiveFeedbackEvent
  - System.Windows.ContentElement.PreviewGotKeyboardFocus
  - System.Windows.ContentElement.PreviewGotKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewKeyDown
  - System.Windows.ContentElement.PreviewKeyDownEvent
  - System.Windows.ContentElement.PreviewKeyUp
  - System.Windows.ContentElement.PreviewKeyUpEvent
  - System.Windows.ContentElement.PreviewLostKeyboardFocus
  - System.Windows.ContentElement.PreviewLostKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewMouseDown
  - System.Windows.ContentElement.PreviewMouseDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonDown
  - System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonUp
  - System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseMove
  - System.Windows.ContentElement.PreviewMouseMoveEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonDown
  - System.Windows.ContentElement.PreviewMouseRightButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonUp
  - System.Windows.ContentElement.PreviewMouseRightButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseUp
  - System.Windows.ContentElement.PreviewMouseUpEvent
  - System.Windows.ContentElement.PreviewMouseWheel
  - System.Windows.ContentElement.PreviewMouseWheelEvent
  - System.Windows.ContentElement.PreviewQueryContinueDrag
  - System.Windows.ContentElement.PreviewQueryContinueDragEvent
  - System.Windows.ContentElement.PreviewStylusButtonDown
  - System.Windows.ContentElement.PreviewStylusButtonDownEvent
  - System.Windows.ContentElement.PreviewStylusButtonUp
  - System.Windows.ContentElement.PreviewStylusButtonUpEvent
  - System.Windows.ContentElement.PreviewStylusDown
  - System.Windows.ContentElement.PreviewStylusDownEvent
  - System.Windows.ContentElement.PreviewStylusInAirMove
  - System.Windows.ContentElement.PreviewStylusInAirMoveEvent
  - System.Windows.ContentElement.PreviewStylusInRange
  - System.Windows.ContentElement.PreviewStylusInRangeEvent
  - System.Windows.ContentElement.PreviewStylusMove
  - System.Windows.ContentElement.PreviewStylusMoveEvent
  - System.Windows.ContentElement.PreviewStylusOutOfRange
  - System.Windows.ContentElement.PreviewStylusOutOfRangeEvent
  - System.Windows.ContentElement.PreviewStylusSystemGesture
  - System.Windows.ContentElement.PreviewStylusSystemGestureEvent
  - System.Windows.ContentElement.PreviewStylusUp
  - System.Windows.ContentElement.PreviewStylusUpEvent
  - System.Windows.ContentElement.PreviewTextInput
  - System.Windows.ContentElement.PreviewTextInputEvent
  - System.Windows.ContentElement.PreviewTouchDown
  - System.Windows.ContentElement.PreviewTouchDownEvent
  - System.Windows.ContentElement.PreviewTouchMove
  - System.Windows.ContentElement.PreviewTouchMoveEvent
  - System.Windows.ContentElement.PreviewTouchUp
  - System.Windows.ContentElement.PreviewTouchUpEvent
  - System.Windows.ContentElement.QueryContinueDrag
  - System.Windows.ContentElement.QueryContinueDragEvent
  - System.Windows.ContentElement.QueryCursor
  - System.Windows.ContentElement.QueryCursorEvent
  - System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.ReleaseAllTouchCaptures
  - System.Windows.ContentElement.ReleaseMouseCapture
  - System.Windows.ContentElement.ReleaseStylusCapture
  - System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.ShouldSerializeCommandBindings
  - System.Windows.ContentElement.ShouldSerializeInputBindings
  - System.Windows.ContentElement.StylusButtonDown
  - System.Windows.ContentElement.StylusButtonDownEvent
  - System.Windows.ContentElement.StylusButtonUp
  - System.Windows.ContentElement.StylusButtonUpEvent
  - System.Windows.ContentElement.StylusDown
  - System.Windows.ContentElement.StylusDownEvent
  - System.Windows.ContentElement.StylusEnter
  - System.Windows.ContentElement.StylusEnterEvent
  - System.Windows.ContentElement.StylusInAirMove
  - System.Windows.ContentElement.StylusInAirMoveEvent
  - System.Windows.ContentElement.StylusInRange
  - System.Windows.ContentElement.StylusInRangeEvent
  - System.Windows.ContentElement.StylusLeave
  - System.Windows.ContentElement.StylusLeaveEvent
  - System.Windows.ContentElement.StylusMove
  - System.Windows.ContentElement.StylusMoveEvent
  - System.Windows.ContentElement.StylusOutOfRange
  - System.Windows.ContentElement.StylusOutOfRangeEvent
  - System.Windows.ContentElement.StylusSystemGesture
  - System.Windows.ContentElement.StylusSystemGestureEvent
  - System.Windows.ContentElement.StylusUp
  - System.Windows.ContentElement.StylusUpEvent
  - System.Windows.ContentElement.TextInput
  - System.Windows.ContentElement.TextInputEvent
  - System.Windows.ContentElement.TouchDown
  - System.Windows.ContentElement.TouchDownEvent
  - System.Windows.ContentElement.TouchEnter
  - System.Windows.ContentElement.TouchEnterEvent
  - System.Windows.ContentElement.TouchesCaptured
  - System.Windows.ContentElement.TouchesCapturedWithin
  - System.Windows.ContentElement.TouchesDirectlyOver
  - System.Windows.ContentElement.TouchesOver
  - System.Windows.ContentElement.TouchLeave
  - System.Windows.ContentElement.TouchLeaveEvent
  - System.Windows.ContentElement.TouchMove
  - System.Windows.ContentElement.TouchMoveEvent
  - System.Windows.ContentElement.TouchUp
  - System.Windows.ContentElement.TouchUpEvent
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FrameworkContentElement()
  nameWithType: FrameworkContentElement.FrameworkContentElement()
  fullName: System.Windows.FrameworkContentElement.FrameworkContentElement()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> klasse."
  syntax:
    content: public FrameworkContentElement ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  id: AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: AddLogicalChild(Object)
  nameWithType: FrameworkContentElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.AddLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Het opgegeven element wordt toegevoegd als een onderliggend element van dit element."
  remarks: "Deze methode kunt Veroorzaak een uitzondering als aangeroepen op een tijdstip waarop de logische structuur door een ander proces wordt wordt herhaald.       De meeste <xref:System.Windows.FrameworkContentElement>afgeleide klassen zichtbaar toegewezen verzamelingen die verantwoordelijk voor de containment zijn (bijvoorbeeld <xref:System.Windows.Documents.Span.Inlines%2A>op de klasse <xref:System.Windows.Documents.Span>; <xref:System.Windows.Documents.Section.Blocks%2A>op de <xref:System.Windows.Documents.Section>klasse).</xref:System.Windows.Documents.Section> </xref:System.Windows.Documents.Section.Blocks%2A> </xref:System.Windows.Documents.Span> </xref:System.Windows.Documents.Span.Inlines%2A> </xref:System.Windows.FrameworkContentElement> Doorgaans kunt u hoeft de logische structuur rechtstreeks bewerken als u deze klassen in plaats daarvan afgeleid voorkomen. Werken met de logische structuur voor inhoud elementen is een geavanceerd scenario dat mogelijk een gespecialiseerde parser of een gespecialiseerde <xref:System.Windows.FrameworkElement>die fungeert als de rendering van het bovenliggende element (inhoud host).</xref:System.Windows.FrameworkElement>       Voor meer informatie over het gebruik van <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>en AddLogicalChild, Zie [structuren in WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>"
  syntax:
    content: protected void AddLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "Het onderliggende element moet worden toegevoegd."
  overload: System.Windows.FrameworkContentElement.AddLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginInit
  id: BeginInit
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginInit()
  nameWithType: FrameworkContentElement.BeginInit()
  fullName: System.Windows.FrameworkContentElement.BeginInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wordt aangeroepen voordat een element is geïnitialiseerd."
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "De volgorde van de acties die zijn opgenomen in het opgegeven storyboard begint."
  remarks: "Voor de handtekeningen die geen gebruikmaken van de `isControllable`, parameter of als deze parameter wordt opgegeven `false`, de tijdlijn klokken die zijn gekoppeld aan de animatie worden verwijderd zodra de &quot;Opvulling&quot;-periode is bereikt. Daarom de animatie niet opnieuw starten na één keer wordt uitgevoerd. Houd er rekening mee dat voor het beheren van een animatie ook is vereist dat het storyboard benoemde of toegankelijk is als een exemplaar in de code."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "De storyboard om te beginnen."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "De volgorde van de acties die zijn opgenomen in het opgegeven storyboard met opties opgegeven voor wat er gebeuren moet als de eigenschap al wordt geanimeerd begint."
  remarks: "Voor de handtekeningen die geen gebruikmaken van de `isControllable`, parameter of als deze parameter wordt opgegeven `false`, de tijdlijn klokken die zijn gekoppeld aan de animatie worden verwijderd zodra de &quot;Opvulling&quot;-periode is bereikt. Daarom de animatie niet opnieuw starten na één keer wordt uitgevoerd. Houd er rekening mee dat voor het beheren van een animatie ook is vereist dat het storyboard benoemde of toegankelijk is als een exemplaar in de code.      ## Met het opstellen HandoffBehavior wanneer u een <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, of <xref:System.Windows.Media.Animation.AnimationClock>aan een eigenschap met behulp van de <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>, een <xref:System.Windows.Media.Animation.Clock>objecten die eerder is gekoppeld aan die eigenschap blijven systeembronnen; de klokken wordt niet automatisch verwijderd door het systeem timing.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Om prestatieproblemen te voorkomen wanneer u een groot aantal klokken met behulp van toepassen <xref:System.Windows.Media.Animation.HandoffBehavior>, moet u samenstellen klokken verwijderen uit de animatie eigenschap nadat ze hebt voltooid.</xref:System.Windows.Media.Animation.HandoffBehavior> Er zijn verschillende manieren om te verwijderen van een klok: - als u wilt alle klokken verwijderen uit een eigenschap, gebruikt de <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>of <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>methode van het object met animatie.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Geef de eigenschap die wordt geanimeerd als de eerste parameter en `null` als de tweede. Hiermee verwijdert u alle animatie klokken van de eigenschap.      -Naar een specifieke <xref:System.Windows.Media.Animation.AnimationClock>uit een lijst met klokken, gebruikt u de <xref:System.Windows.Media.Animation.Clock.Controller%2A>eigenschap van het <xref:System.Windows.Media.Animation.AnimationClock>ophalen van een <xref:System.Windows.Media.Animation.ClockController>roept u vervolgens de <xref:System.Windows.Media.Animation.ClockController.Remove%2A>methode van de <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> verwijderen Dit gebeurt meestal de <xref:System.Windows.Media.Animation.Clock.Completed>gebeurtenis-handler voor een clock.</xref:System.Windows.Media.Animation.Clock.Completed> Houd er rekening mee dat alleen hoofdmap klokken kunnen worden beheerd door een <xref:System.Windows.Media.Animation.ClockController>; de <xref:System.Windows.Media.Animation.Clock.Controller%2A>eigenschap van een onderliggende klok retourneert `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> U ziet ook dat de <xref:System.Windows.Media.Animation.Clock.Completed>treedt een gebeurtenis is niet op als de effectieve duur van de klok permanent is.</xref:System.Windows.Media.Animation.Clock.Completed>  In dat geval wordt moet de gebruiker het aanroepen van <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A> bepalen       Dit is vooral een probleem voor animaties in objecten die een lange levensduur hebben.  Wanneer een object is de garbage collector zijn verzameld, worden ook de klokken verbroken en garbage collector zijn verzameld.       Zie voor meer informatie over klok objecten [animatie en Timing Systeemoverzicht](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "De storyboard om te beginnen."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Een waarde van de inventarisatie die gedrag moet worden gebruikt als een eigenschap die wordt beschreven in het storyboard al wordt geanimeerd beschrijft."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Begint de volgorde van de acties die zijn opgenomen in het opgegeven storyboard, met de opgegeven status voor het beheer van de animatie nadat deze is gestart."
  remarks: "Voor de handtekeningen die geen gebruikmaken van de `isControllable`, parameter of als deze parameter wordt opgegeven `false`, de tijdlijn klokken die zijn gekoppeld aan de animatie worden verwijderd zodra de &quot;Opvulling&quot;-periode is bereikt. Daarom de animatie niet opnieuw starten na één keer wordt uitgevoerd. Houd er rekening mee dat voor het beheren van een animatie ook is vereist dat het storyboard benoemde of toegankelijk is als een exemplaar in de code.      ## Met het opstellen HandoffBehavior wanneer u een <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, of <xref:System.Windows.Media.Animation.AnimationClock>aan een eigenschap met behulp van de <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>, een <xref:System.Windows.Media.Animation.Clock>objecten die eerder is gekoppeld aan die eigenschap blijven systeembronnen; het systeem timing van de klokken niet automatisch verwijderd.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Om prestatieproblemen te voorkomen wanneer u een groot aantal klokken met behulp van toepassen <xref:System.Windows.Media.Animation.HandoffBehavior>, moet u samenstellen klokken verwijderen uit de animatie eigenschap nadat ze hebt voltooid.</xref:System.Windows.Media.Animation.HandoffBehavior> Er zijn verschillende manieren om te verwijderen van een klok: - als u wilt alle klokken verwijderen uit een eigenschap, gebruikt de <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>of <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>methode van het object met animatie.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Geef de eigenschap die wordt geanimeerd als de eerste parameter en `null` als de tweede. Hiermee verwijdert u alle animatie klokken van de eigenschap.      -Naar een specifieke <xref:System.Windows.Media.Animation.AnimationClock>uit een lijst met klokken, gebruikt u de <xref:System.Windows.Media.Animation.Clock.Controller%2A>eigenschap van het <xref:System.Windows.Media.Animation.AnimationClock>ophalen van een <xref:System.Windows.Media.Animation.ClockController>roept u vervolgens de <xref:System.Windows.Media.Animation.ClockController.Remove%2A>methode van de <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> verwijderen Dit gebeurt meestal de <xref:System.Windows.Media.Animation.Clock.Completed>gebeurtenis-handler voor een clock.</xref:System.Windows.Media.Animation.Clock.Completed> Houd er rekening mee dat alleen hoofdmap klokken kunnen worden beheerd door een <xref:System.Windows.Media.Animation.ClockController>; de <xref:System.Windows.Media.Animation.Clock.Controller%2A>eigenschap van een onderliggende klok retourneert `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> U ziet ook dat de <xref:System.Windows.Media.Animation.Clock.Completed>treedt een gebeurtenis is niet op als de effectieve duur van de klok permanent is.</xref:System.Windows.Media.Animation.Clock.Completed>  In dat geval wordt moet de gebruiker het aanroepen van <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A> bepalen       Dit is vooral een probleem voor animaties in objecten die een lange levensduur hebben.  Wanneer een object is de garbage collector zijn verzameld, worden ook de klokken verbroken en garbage collector zijn verzameld.       Zie voor meer informatie over klok objecten [animatie en Timing Systeemoverzicht](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "De storyboard om te beginnen."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Een waarde van de inventarisatie die gedrag moet worden gebruikt als een eigenschap die wordt beschreven in het storyboard al wordt geanimeerd beschrijft."
    - id: isControllable
      type: System.Boolean
      description: "Wordt aangegeven of de animatie bestuurd wordt (kan worden onderbroken) nadat deze is gestart."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BindingGroup
  id: BindingGroup
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
  fullName: System.Windows.FrameworkContentElement.BindingGroup
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld de <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> die wordt gebruikt voor het element."
  remarks: "Een <xref:System.Windows.Data.BindingGroup>kan worden gebruikt voor het valideren van de waarden van meerdere eigenschappen van een object.</xref:System.Windows.Data.BindingGroup> Stel dat een toepassing vraagt de gebruiker een adres op te geven en vult vervolgens een object van type `Address`, die de eigenschappen heeft `Street`, `City`, `ZipCode`, en `Country`, met de waarden die de gebruiker opgegeven. De toepassing heeft een paneel met vier <xref:System.Windows.Controls.TextBox>besturingselementen, die is gebonden aan een van de eigenschappen van het object.</xref:System.Windows.Controls.TextBox> U kunt een <xref:System.Windows.Controls.ValidationRule>in een <xref:System.Windows.Data.BindingGroup>valideren van de `Address` object.</xref:System.Windows.Data.BindingGroup> </xref:System.Windows.Controls.ValidationRule> Bijvoorbeeld, de <xref:System.Windows.Controls.ValidationRule>kunt ervoor zorgen dat de postcode die geldig voor het land van het adres is.</xref:System.Windows.Controls.ValidationRule>       Onderliggende elementen overnemen de <xref:System.Windows.Data.BindingGroup>van hun bovenliggende elementen, net zoals bij andere overneembare eigenschap.</xref:System.Windows.Data.BindingGroup>      <a name=&quot;dependencyPropertyInfo_BindingGroup&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|   | Eigenschappen van metagegevens is ingesteld op **true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.BindingGroupProperty>"
  syntax:
    content: public System.Windows.Data.BindingGroup BindingGroup { get; set; }
    return:
      type: System.Windows.Data.BindingGroup
      description: "De <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> die wordt gebruikt voor het element."
  overload: System.Windows.FrameworkContentElement.BindingGroup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BindingGroupProperty
  id: BindingGroupProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BindingGroupProperty
  nameWithType: FrameworkContentElement.BindingGroupProperty
  fullName: System.Windows.FrameworkContentElement.BindingGroupProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.BindingGroup*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.BindingGroup*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BindingGroupProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BringIntoView
  id: BringIntoView
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BringIntoView()
  nameWithType: FrameworkContentElement.BringIntoView()
  fullName: System.Windows.FrameworkContentElement.BringIntoView()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pogingen om te zorgen dat dit element in de weergave binnen deze zich bevindt binnen schuifbare gedeelten."
  remarks: "Door deze methode aanroept, effectief roept u <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>op een bovenliggende schuifbare gebied dat het element bevat (het bovenliggende item is zeer goed mogelijk een <xref:System.Windows.FrameworkElement>, niet een <xref:System.Windows.FrameworkContentElement>).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkElement> </xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> Als dit element niet in een schuifbare gebied opgenomen is, nog steeds door de gebeurtenis wordt geactiveerd, maar er zijn geen effect."
  syntax:
    content: public void BringIntoView ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenu
  id: ContextMenu
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
  fullName: System.Windows.FrameworkContentElement.ContextMenu
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van het element in de context menu die moet worden weergegeven wanneer het contextmenu is aangevraagd [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] uit binnen dit element."
  remarks: "<a name=&quot;dependencyPropertyInfo_ContextMenu&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`| Geen |</xref:System.Windows.FrameworkContentElement.ContextMenuProperty>"
  example:
  - "The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.  \n  \n [!code-xml[ContentElementsSmorgasbord#ContextMenu](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page1.xaml#contextmenu)]"
  syntax:
    content: public System.Windows.Controls.ContextMenu ContextMenu { get; set; }
    return:
      type: System.Windows.Controls.ContextMenu
      description: "Het snelmenu dat gebruikmaakt van dit element."
  overload: System.Windows.FrameworkContentElement.ContextMenu*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuClosing
  id: ContextMenuClosing
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuClosing
  nameWithType: FrameworkContentElement.ContextMenuClosing
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Deze gebeurtenis treedt op vlak voordat een contextmenu in het element is gesloten."
  remarks: "Als u wilt onderdrukken sluiten moeten contextmenu&quot;s, handlers van de gebeurtenis gemarkeerd als verwerkt.       Gebruik deze gebeurtenis als een <xref:System.Windows.EventTrigger>in een stijl, moet u verwijzen naar de onderliggende service gebeurtenis-id: [!code-xml [CorePseudocode #FEContextMenuClosing](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuclosing) ] (dit gebruik is vereist omdat de implementatie van de gebeurtenis op <xref:System.Windows.FrameworkContentElement>dat zichtbaar gemaakt de onderliggende service gebeurtenis is niet correct toegewezen ContextMenuClosing-id voor gebruik in activeert).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_ContextMenuClosing&quot;></a>## Gerouteerd gebeurtenisgegevens |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|   | Routingstrategie | Vastleg |   | Gemachtigde | <xref:System.Windows.Controls.ContextMenuEventHandler>|</xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>"
  example:
  - "The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown). The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  id: ContextMenuClosingEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuClosingEvent
  nameWithType: FrameworkContentElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuClosing&quot;> </xref> [gerouteerd gebeurtenissen overzicht](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Gebeurtenis-id-objecten worden gemaakt wanneer gerouteerde gebeurtenissen worden geregistreerd (Zie <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) en kan vervolgens worden gebruikt voor de klasse-handlers toevoegen (Zie <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objecten bevatten een unieke naam, eigenaarstype handler-type, routingstrategie en een methode hulpprogramma voor eigenaars voor de gebeurtenis toe te voegen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuOpening
  id: ContextMenuOpening
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuOpening
  nameWithType: FrameworkContentElement.ContextMenuOpening
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Deze gebeurtenis treedt op wanneer een contextmenu in het element wordt geopend."
  remarks: "Handlers van de gebeurtenissen moeten handmatig te openen snelmenu&quot;s, niet de relevante gebeurtenis markeren als verwerkt. Anders wordt de bestaande waarde van de <xref:System.Windows.FrameworkContentElement.ContextMenu%2A>eigenschap wordt gebruikt om automatisch een contextmenu te openen.</xref:System.Windows.FrameworkContentElement.ContextMenu%2A> Markering van de gebeurtenis verwerkt de standaardactie effectief wordt geannuleerd en kan een kans om de waarde van de <xref:System.Windows.FrameworkContentElement.ContextMenu%2A>eigenschap en open vervolgens de nieuwe <xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkContentElement.ContextMenu%2A> opnieuw instellen Er is echter een timingprobleem die u houden moet rekening. Om volledig vervangen door het contextmenu via een handler ContextMenuOpening, mag de initiële contextmenu geen null of leeg. U kunt ook mogelijk moet u de gebeurtenis verwerken en opent u een nieuwe contextmenu handmatig. Zie voor meer informatie [hoe: de gebeurtenis ContextMenuOpening](~/add/includes/ajax-current-ext-md.md).       Gebruik deze gebeurtenis als een <xref:System.Windows.EventTrigger>in een stijl, moet u verwijzen naar de onderliggende service gebeurtenis-id: [!code-xml [CorePseudocode #FEContextMenuOpening](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuopening) ] (dit gebruik is vereist omdat de implementatie van de gebeurtenis op <xref:System.Windows.FrameworkContentElement>dat zichtbaar gemaakt de onderliggende service gebeurtenis is niet correct toegewezen ContextMenuOpening-id voor gebruik in activeert).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_ContextMenuOpening&quot;></a>## Gerouteerd gebeurtenisgegevens |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|   | Routingstrategie | Vastleg |   | Gemachtigde | <xref:System.Windows.Controls.ContextMenuEventHandler>|</xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  id: ContextMenuOpeningEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkContentElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuOpening&quot;> </xref> [gerouteerd gebeurtenissen overzicht](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Gebeurtenis-id-objecten worden gemaakt wanneer gerouteerde gebeurtenissen worden geregistreerd (Zie <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) en kan vervolgens worden gebruikt voor de klasse-handlers toevoegen (Zie <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objecten bevatten een unieke naam, eigenaarstype handler-type, routingstrategie en een methode hulpprogramma voor eigenaars voor de gebeurtenis toe te voegen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuProperty
  id: ContextMenuProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuProperty
  nameWithType: FrameworkContentElement.ContextMenuProperty
  fullName: System.Windows.FrameworkContentElement.ContextMenuProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.ContextMenu*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.ContextMenu*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ContextMenuProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Cursor
  id: Cursor
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
  fullName: System.Windows.FrameworkContentElement.Cursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van de cursor die wordt weergegeven wanneer de muisaanwijzer zich boven dit element."
  remarks: "Bij het instellen van deze eigenschap in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], wordt de [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] processor is afhankelijk van de typeconversie van het voor de <xref:System.Windows.Input.Cursor>klasse om te evalueren van de tekenreeks.</xref:System.Windows.Input.Cursor> De opgegeven tekenreeks moet worden geëvalueerd tot een <xref:System.Windows.Input.CursorType>waarde.</xref:System.Windows.Input.CursorType> Zie <xref:System.Windows.Input.Cursor>voor meer informatie.</xref:System.Windows.Input.Cursor>       De cursor die door deze eigenschap wordt of worden niet weergegeven wanneer de muisaanwijzer zich boven dit element is ook afhankelijk van de waarde van de <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>eigenschap.</xref:System.Windows.FrameworkContentElement.ForceCursor%2A> Ook gebeurtenissen gerelateerde overwegingen, zoals een actieve slepen, muisvastlegging, tekstbewerking modi binnen besturingselementen, enzovoort, ook van invloed op de cursor met hogere prioriteit dan de waarde die u in deze eigenschap opgeeft.       Als u het gedrag van deze eigenschap instelt op het uiteindelijke standaard, ingesteld op `null` opnieuw.       De `null` standaard echt houdt in dat de vaststelling van de waarde praktische cursor hier is uitgesteld en moet worden opgehaald uit elders. Als u krijgt geen programmatische waarden van elke bron, de standaardcursor via een [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] toepassing is een pijl.       Elke verplaatsing van de muis boven een [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] toepassing verhoogt een <xref:System.Windows.ContentElement.QueryCursor>gebeurtenis.</xref:System.Windows.ContentElement.QueryCursor> De gebeurtenis bellen en een element op de route heeft de mogelijkheid om de gebeurtenis te verwerken en de waarde van de cursor via de argumenten van deze gebeurtenis. Als dit gebeurt, het feit dat de gebeurtenis wordt verwerkt en een gewijzigde waarde in de argumenten heeft heeft voorrang op de waarde van de eigenschap Cursor op elk niveau tenzij <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>is ingesteld.</xref:System.Windows.FrameworkContentElement.ForceCursor%2A>       Als u een aangepaste cursor niet worden gemaakt, doorgaans instellen u deze eigenschap op een statische eigenschapswaarde van de <xref:System.Windows.Input.Cursors>klasse.</xref:System.Windows.Input.Cursors>       Instellen van de <xref:System.Windows.Input.Cursor>op een aangepaste waarde is niet ingeschakeld in gedeeltelijk vertrouwen.</xref:System.Windows.Input.Cursor> Zie voor meer informatie over aangepaste cursors [invoer overzicht](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_Cursor&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.CursorProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`| Geen |</xref:System.Windows.FrameworkContentElement.CursorProperty>"
  example:
  - "The following example sets the cursor to a custom value.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public System.Windows.Input.Cursor Cursor { get; set; }
    return:
      type: System.Windows.Input.Cursor
      description: "De cursor om weer te geven. De standaardwaarde is gedefinieerd als <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> per deze afhankelijkheidseigenschap. De standaardwaarde praktische tijdens runtime, echter zijn afkomstig van een verscheidenheid aan factoren."
  overload: System.Windows.FrameworkContentElement.Cursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.CursorProperty
  id: CursorProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: CursorProperty
  nameWithType: FrameworkContentElement.CursorProperty
  fullName: System.Windows.FrameworkContentElement.CursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.Cursor*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.Cursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty CursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContext
  id: DataContext
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
  fullName: System.Windows.FrameworkContentElement.DataContext
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van de gegevenscontext van de voor een element wanneer deze deel van de gegevensbinding uitmaakt."
  remarks: "*De gegevenscontext* een concept waarmee elementen overnemen van informatie van hun bovenliggende elementen over de bron van de binding die wordt gebruikt voor binding, evenals andere kenmerken van de binding zoals het pad.       De gegevenscontext rechtstreeks naar kan worden ingesteld een [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] object met de bindingen naar eigenschappen van dat object evalueren. U kunt ook de gegevenscontext instellen op een <xref:System.Windows.Data.DataSourceProvider>object.</xref:System.Windows.Data.DataSourceProvider>       Deze afhankelijkheidseigenschap overgenomen eigenschapswaarden. Als er geen andere waarde voor het tot stand gebracht via lokale waarden of stijlen DataContext onderliggende elementen, wordt het systeem eigenschap de waarde moet de waarde van het dichtstbijzijnde bovenliggende element van de DataContext met deze waarde toegewezen worden ingesteld.       U kunt ook kunt u een van de volgende eigenschappen van de <xref:System.Windows.Data.Binding>klasse expliciet opgeven van de binding-bron: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, of <xref:System.Windows.Data.Binding.RelativeSource%2A>.</xref:System.Windows.Data.Binding.RelativeSource%2A> </xref:System.Windows.Data.Binding.Source%2A> </xref:System.Windows.Data.Binding.ElementName%2A> </xref:System.Windows.Data.Binding> Zie voor meer informatie [hoe: Geef de bron Binding](~/add/includes/ajax-current-ext-md.md).       In [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], DataContext is meestal ingesteld als een <xref:System.Windows.Data.Binding>declaratie.</xref:System.Windows.Data.Binding> U kunt de syntaxis van de eigenschap element of kenmerk syntaxis gebruiken. De syntaxis kenmerk wordt weergegeven in het voorbeeld op deze pagina. U kunt ook DataContext instellen in de code.      <a name=&quot;xamlPropertyElementUsage_DataContext&quot;></a>## XAML eigenschap elementgebruik ```   <object>     <object.DataContext>       <dataContextObject />     </object.DataContext>   </object>   ``` <a name=&quot;xamlAttributeUsage_DataContext&quot;> </a> ## XAML Kenmerkgebruik ```   <object DataContext=&quot;bindingUsage&quot;/>   - or -   <object DataContext=&quot;{resourceExtension contextResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_DataContext&quot;> </a> ## XAML waarden *dataContextObject* een rechtstreeks ingesloten object die als de gegevenscontext van de voor alle bindingen binnen het bovenliggende element fungeert.             Dit object is meestal een <xref:System.Windows.Data.Binding>of een andere <xref:System.Windows.Data.BindingBase>subklasse.</xref:System.Windows.Data.BindingBase> </xref:System.Windows.Data.Binding> U kunt ook onbewerkte gegevens van een [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] objecttype die bestemd zijn voor binding met de werkelijke bindingen gedefinieerd later hier kan worden geplaatst.       *bindingUsage* binding gebruiksrechten die in een context van de juiste gegevens resulteert. Zie voor meer informatie [Opmaakextensie Binding](~/add/includes/ajax-current-ext-md.md).       *resourceExtension* een van de volgende: `StaticResource`, of `DynamicResource`. Dit gebruik wordt gebruikt bij het verwijzen naar de onbewerkte gegevens die zijn gedefinieerd als een object in de resources. Zie [XAML Resources](~/add/includes/ajax-current-ext-md.md).       *contextResourceKey* de sleutel-id voor het object wordt aangevraagd bij binnen een <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      <a name=&quot;dependencyPropertyInfo_DataContext&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.DataContextProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.DataContextProperty>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as DataContext, and setting the binding path to a property within it.  \n  \n [!code-cs[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#datacontext)]\n [!code-vb[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#datacontext)]"
  syntax:
    content: public object DataContext { get; set; }
    return:
      type: System.Object
      description: "Het object dat moet worden gebruikt als de gegevenscontext."
  overload: System.Windows.FrameworkContentElement.DataContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContextChanged
  id: DataContextChanged
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContextChanged
  nameWithType: FrameworkContentElement.DataContextChanged
  fullName: System.Windows.FrameworkContentElement.DataContextChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Deze gebeurtenis treedt op wanneer de gegevenscontext dit element wordt gewijzigd."
  remarks: "Zie voor een uitleg van gegevenscontexten en gegevensbinding [Binding overzicht](~/add/includes/ajax-current-ext-md.md).      > [!IMPORTANT] > Wanneer van een element <xref:System.Windows.FrameworkContentElement.DataContext%2A>alle gegevensgebonden eigenschappen voor dit element wijzigingen mogelijk zijn beïnvloed.</xref:System.Windows.FrameworkContentElement.DataContext%2A> Dit geldt voor alle elementen die onderliggende elementen van het huidige element die in de gegevenscontext worden overgenomen, en ook het huidige element zelf. Alle dergelijke bindingen interpreteren opnieuw de nieuwe <xref:System.Windows.FrameworkContentElement.DataContext%2A>in overeenstemming met de nieuwe waarde in de bindingen.</xref:System.Windows.FrameworkContentElement.DataContext%2A> Er is geen garantie dat over de volgorde van deze wijzigingen ten opzichte van het verhogen van de gebeurtenis DataContextChanged aangebracht.  De wijzigingen kunnen optreden voordat de gebeurtenis na de gebeurtenis of in elke combinatie."
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContextProperty
  id: DataContextProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContextProperty
  nameWithType: FrameworkContentElement.DataContextProperty
  fullName: System.Windows.FrameworkContentElement.DataContextProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.DataContext*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.DataContext*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty DataContextProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey
  id: DefaultStyleKey
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van de sleutel voor het vinden van de stijlsjabloon voor dit besturingselement in thema&quot;s."
  remarks: "Deze eigenschap is doorgaans niet via een van de directe setters ingesteld. In plaats daarvan, overschrijven de typespecifieke metagegevens van deze afhankelijkheidseigenschap telkens wanneer u een nieuwe subklasse maken. Wanneer u subklasse, belt de <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>methode op basis van de <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>-id en binnen de statische constructor van het besturingselement subklasse.</xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> </xref:System.Windows.DependencyProperty.OverrideMetadata%2A>       Bijvoorbeeld, een inline-klasse, zoals <xref:System.Windows.Documents.Bold>daadwerkelijk heeft weinig implementatie buiten de DefaultStyleKey metagegevens in de statische constructor te overschrijven en blootstellen van verschillende constructors-instantie.</xref:System.Windows.Documents.Bold> Het feit dat de elementen omgeven door de <xref:System.Windows.Documents.Bold>winst tag een <xref:System.Windows.Documents.TextElement.FontWeight%2A>eigenschap van <xref:System.Windows.FontWeights.Bold%2A>is geïmplementeerd binnen de stijl van het thema waarnaar wordt verwezen door de standaardwaarde van DefaultStyleKey naar `typeof(Bold)`.</xref:System.Windows.FontWeights.Bold%2A> </xref:System.Windows.Documents.TextElement.FontWeight%2A> </xref:System.Windows.Documents.Bold>       Als u wilt dat uw element of het besturingselement themastijlen opzettelijk niet te gebruiken, stelt u de <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>eigenschap `true`.</xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>      <a name=&quot;dependencyPropertyInfo_DefaultStyleKey&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>"
  syntax:
    content: protected object DefaultStyleKey { get; set; }
    return:
      type: System.Object
      description: "De stijl-sleutel. Functioneert als onderdeel van het thema-style-lookup, deze waarde wordt verwacht de <xref:System.Type>van het element wordt opgemaakt.</xref:System.Type> <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>is een toegestane waarde voor een bepaalde aanvraag; Zie de opmerkingen."
  overload: System.Windows.FrameworkContentElement.DefaultStyleKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  id: DefaultStyleKeyProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkContentElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.DefaultStyleKey*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.DefaultStyleKey*>"
  syntax:
    content: protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.EndInit
  id: EndInit
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: EndInit()
  nameWithType: FrameworkContentElement.EndInit()
  fullName: System.Windows.FrameworkContentElement.EndInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Aangeroepen onmiddellijk nadat een element is geïnitialiseerd."
  remarks: "Implementeer deze methode om speciale verwerking die moeten worden uitgevoerd wanneer uw element tijdens het laadproces element wordt geïnitialiseerd.       Uw implementatie moet de basisimplementatie niet aanroepen omdat sommige interne vlaggen voor het bijhouden van de initialisatie van de base (standaard)-implementatie instellen.       Als <xref:System.Windows.FrameworkContentElement.BeginInit%2A>is eerder aangeroepen, de base implementatie verhoogt de <xref:System.Windows.FrameworkContentElement.Initialized>gebeurtenis.</xref:System.Windows.FrameworkContentElement.Initialized> </xref:System.Windows.FrameworkContentElement.BeginInit%2A> Anders, als <xref:System.Windows.FrameworkContentElement.BeginInit%2A>is niet aangeroepen of deze kan niet worden bepaald of <xref:System.Windows.FrameworkContentElement.BeginInit%2A>is aangeroepen, de gebeurtenis is niet geactiveerd.</xref:System.Windows.FrameworkContentElement.BeginInit%2A> </xref:System.Windows.FrameworkContentElement.BeginInit%2A>"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FindName(System.String)
  id: FindName(System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FindName(String)
  nameWithType: FrameworkContentElement.FindName(String)
  fullName: System.Windows.FrameworkContentElement.FindName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Zoeken naar een element dat de opgegeven id-naam heeft."
  remarks: "Als dit element heeft de onderliggende elementen, worden deze onderliggende elementen alle gezochte recursief voor de aangevraagde element met de naam."
  example:
  - "The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.  \n  \n [!code-cs[ContentElementsSmorgasbord#FindName](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#findname)]\n [!code-vb[ContentElementsSmorgasbord#FindName](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#findname)]"
  syntax:
    content: public object FindName (string name);
    parameters:
    - id: name
      type: System.String
      description: "De naam van het element om naar te zoeken."
    return:
      type: System.Object
      description: "Het gevraagde element. Mogelijk <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er geen overeenkomend element is gevonden."
  overload: System.Windows.FrameworkContentElement.FindName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: FrameworkContentElement.FindResource(Object)
  fullName: System.Windows.FrameworkContentElement.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Zoekt naar een resource met de opgegeven sleutel en wordt Veroorzaak een uitzondering als de aangevraagde bron is niet gevonden."
  remarks: "> [!IMPORTANT]> Als u deze methode niet voor een sleutel die niet is gevonden aanroepen, wordt een uitzondering opgetreden. Als u niet uitzonderingen voor deze aanvraag te verwerken wilt, moet u in plaats daarvan <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</xref:System.Windows.FrameworkContentElement.TryFindResource%2A> aanroepen <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>retourneert `null` wanneer er geen bron is gevonden en heeft een uitzondering niet genereren.</xref:System.Windows.FrameworkContentElement.TryFindResource%2A>       Als de bron is niet gevonden in het element aanroepen, de structuur van de bovenliggende wordt gezocht met behulp van de logische structuur, op dezelfde manier die de structuur van de gezochte als een resource zijn aangevraagd door de sleutel tijdens runtime.       U zou de retourwaarde naar het type van de eigenschap die u hebt geprobeerd om in te stellen met de resourcewaarde van de geretourneerde doorgaans onmiddellijk geconverteerd."
  example:
  - "The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.  \n  \n [!code-cs[ContentElementsSmorgasbord#FindResource](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#findresource)]\n [!code-vb[ContentElementsSmorgasbord#FindResource](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#findresource)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "Sleutel-id van de resource die u wilt zoeken."
    return:
      type: System.Object
      description: "De resource gevonden, of <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als er geen overeenkomende resource gevonden (maar ook een uitzondering genereert als <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>)."
  overload: System.Windows.FrameworkContentElement.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "De sleutel van de aangevraagde bron is niet gevonden."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceKey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle
  id: FocusVisualStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van een object waarmee de aanpassing van het uiterlijk, effecten of andere stijlkenmerken die wordt toegepast op dit element wanneer deze toetsenbordfocus vastgelegd."
  remarks: "Bij het instellen van deze eigenschap in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]stijlen bijna altijd worden gedefinieerd als een resource in plaats van door inline als een element en die bron meestal naar wordt verwezen als een <xref:System.Windows.StaticResourceExtension>.</xref:System.Windows.StaticResourceExtension>       Houd er rekening mee dat deze eigenschap is van invloed op uiterlijk maar dus niet gerapporteerd in de metagegevens. Dit is omdat de wijziging uiterlijk gebeurtenisafhankelijke en mogelijk niet altijd van toepassing, en dus niet in het algemeen visual of lay-out informatie in de metagegevens rapporteren mag.       Conceptueel gezien moet het visual gedrag van de focus toegepast op een besturingselement samenhangende element element. De aangewezen manier af te dwingen samenhang is de focus visuele stijl alleen wijzigen als u een hele thema samenstelt. Deze eigenschap instelt op afzonderlijke stijlen en niet als onderdeel van een thema is niet het beoogde gebruik van deze eigenschap, omdat dit ertoe dat een verwarrend gebruikerservaring met betrekking tot de toetsenbordfocus leiden kan. Als u de element-specifieke gedrag dat opzettelijk niet samenhangende via een thema zijn wilde, is een veel betere benadering gebruiken triggers in stijlen voor afzonderlijke invoer status eigenschappen, zoals <xref:System.Windows.UIElement.IsFocused%2A>of <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, en om dit te doen op een manier die visueel niet van invloed op een bestaande focus visuele stijl.</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> </xref:System.Windows.UIElement.IsFocused%2A> Zie voor meer informatie over het ontwerp voornemen FocusVisualStyle en alternatieve focus eigenschappen [opmaak voor Focus in besturingselementen en FocusVisualStyle](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_FocusVisualStyle&quot;></a>## XAML Kenmerkgebruik ```   <object FocusVisualStyle=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_FocusVisualStyle&quot;> </a> ## elementgebruik XAML-eigenschap <a name=&quot;xamlValues_FocusVisualStyle&quot;> </a> ## XAML waarden *resourceExtension* een van de volgende:, of.       Zie [XAML Resources](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* de sleutel waarmee de stijl die wordt aangevraagd. De sleutel verwijst naar een bestaande resource in een <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      > [!NOTE] > Eigenschapselementsyntaxis is technisch mogelijk is, maar niet aanbevolen. Zie [inlinestijlen en sjablonen](~/add/includes/ajax-current-ext-md.md).  Een binding verwijzing met of <xref:System.Windows.Data.Binding>is ook mogelijk, maar ongewoon.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_FocusVisualStyle&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`| Geen |</xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>"
  syntax:
    content: public System.Windows.Style FocusVisualStyle { get; set; }
    return:
      type: System.Windows.Style
      description: "De gewenste stijl toepassen op de focus. De standaardwaarde zoals gedefinieerd in de afhankelijkheidseigenschap is een leeg static <xref href=&quot;System.Windows.Style&quot;> </xref>. De effectieve waarde tijdens de uitvoering is echter vaak (maar niet altijd) een stijl die wordt geleverd door ondersteuning voor besturingselementen van thema&quot;s."
  overload: System.Windows.FrameworkContentElement.FocusVisualStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  id: FocusVisualStyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FocusVisualStyleProperty
  nameWithType: FrameworkContentElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.FocusVisualStyle*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.FocusVisualStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ForceCursor
  id: ForceCursor
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
  fullName: System.Windows.FrameworkContentElement.ForceCursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld met een waarde die aangeeft of dit <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> moet dwingen de [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] voor het weergeven van de cursor zoals opgegeven door dit exemplaar <xref:System.Windows.FrameworkContentElement.Cursor*>eigenschap.</xref:System.Windows.FrameworkContentElement.Cursor*>"
  remarks: "Deze eigenschap instelt op `true` overschrijft de cursor voorkeuren tot stand gebracht met onderliggende elementen. Dus in het algemeen een toepassing doen [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] verwarrend kan zijn voor de gebruiker, met name als onderliggende elementen probeert op te geven van cursors. Instelling <xref:System.Windows.FrameworkElement.ForceCursor%2A>is geschikt voor scenario&quot;s voor toegangsbeheer subclassificering of samenstellen.</xref:System.Windows.FrameworkElement.ForceCursor%2A>      <a name=&quot;dependencyPropertyInfo_ForceCursor&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`| Geen |</xref:System.Windows.FrameworkContentElement.ForceCursorProperty>"
  example:
  - "The following example forces the cursor while over the element.  \n  \n [!code-xml[ForceCursor#ForceCursor](~/add/codesnippet/xaml/forcecursor/default.xaml#forcecursor)]"
  syntax:
    content: public bool ForceCursor { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als u wilt afdwingen cursor presentatie terwijl via dit element kunt u dit exemplaar gebruiken-instelling voor de cursor (inclusief op alle onderliggende elementen). anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. De standaardwaarde is <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.ForceCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ForceCursorProperty
  id: ForceCursorProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ForceCursorProperty
  nameWithType: FrameworkContentElement.ForceCursorProperty
  fullName: System.Windows.FrameworkContentElement.ForceCursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.ForceCursor*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.ForceCursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ForceCursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  id: GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkContentElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkContentElement.GetBindingExpression(DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Haalt de <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> voor de opgegeven eigenschap binding."
  remarks: ''
  example:
  - "The following example retrieves a binding by querying a property.  \n  \n [!code-cs[ContentElementsSmorgasbord#GetBindingExpression](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#getbindingexpression)]\n [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#getbindingexpression)]"
  syntax:
    content: public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Het doel <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> van waaruit de binding ophalen."
    return:
      type: System.Windows.Data.BindingExpression
      description: "Retourneert een <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> als het doel gegevensgebonden is; anders <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.GetBindingExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: FrameworkContentElement.GetUIParentCore()
  fullName: System.Windows.FrameworkContentElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retourneert een alternatieve logisch bovenliggend voor dit element als er geen bovenliggende visual is. In dit geval een <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> bovenliggende is altijd dezelfde waarde als de <xref:System.Windows.FrameworkContentElement.Parent*>eigenschap.</xref:System.Windows.FrameworkContentElement.Parent*>"
  remarks: "De standaardimplementatie retourneert het verwachte bovenliggende voor één visual. Aangepaste implementaties mogelijk alternatieve bovenliggende relaties retourneren."
  syntax:
    content: protected override System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "Retourneert iets anders dan <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> wanneer een implementatie van de framework-niveau WPF van deze methode heeft een niet-visueel bovenliggend-verbinding."
  overload: System.Windows.FrameworkContentElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Initialized
  id: Initialized
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Initialized
  nameWithType: FrameworkContentElement.Initialized
  fullName: System.Windows.FrameworkContentElement.Initialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Deze gebeurtenis treedt op wanneer dit <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> is geïnitialiseerd. Dit valt samen met gevallen waar de waarde van de <xref:System.Windows.FrameworkContentElement.IsInitialized*>eigenschap wordt gewijzigd van <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (of niet-gedefinieerde) naar <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.IsInitialized*>"
  remarks: "Deze gebeurtenis treedt op wanneer de <xref:System.Windows.FrameworkContentElement.EndInit%2A>of <xref:System.Windows.FrameworkContentElement.OnInitialized%2A>methoden worden aangeroepen.</xref:System.Windows.FrameworkContentElement.OnInitialized%2A> </xref:System.Windows.FrameworkContentElement.EndInit%2A> Aanroepen naar deze methoden kunnen zijn aangebracht door opzettelijk code of door de [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] laadproces."
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.InputScope
  id: InputScope
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
  fullName: System.Windows.FrameworkContentElement.InputScope
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van de context voor invoer die wordt gebruikt door dit <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref>."
  remarks: "Deze afhankelijkheidseigenschap overgenomen eigenschapswaarden. Als er geen andere waarde voor onderliggende elementen zijn <xref:System.Windows.FrameworkElement.InputScope%2A>tot stand gebracht via lokale waarden of stijlen, het systeem eigenschap stelt u de waarde moet de <xref:System.Windows.FrameworkElement.InputScope%2A>waarde van het dichtstbijzijnde bovenliggende element met deze waarde toegewezen.</xref:System.Windows.FrameworkElement.InputScope%2A> </xref:System.Windows.FrameworkElement.InputScope%2A>       Hoewel een [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntaxis gebruik wordt vermeld en de syntaxis is toegestaan, deze instelling [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] wordt meestal niet.      <a name=&quot;dependencyPropertyInfo_InputScope&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.InputScopeProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.InputScopeProperty>"
  syntax:
    content: public System.Windows.Input.InputScope InputScope { get; set; }
    return:
      type: System.Windows.Input.InputScope
      description: "De invoer-scope wijzigt hoe invoer van alternatieve methoden voor invoer wordt geïnterpreteerd. De standaardwaarde is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> (wat resulteert in een standaard de verwerking van opdrachten)."
  overload: System.Windows.FrameworkContentElement.InputScope*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.InputScopeProperty
  id: InputScopeProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: InputScopeProperty
  nameWithType: FrameworkContentElement.InputScopeProperty
  fullName: System.Windows.FrameworkContentElement.InputScopeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.InputScope*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.InputScope*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty InputScopeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.IsInitialized
  id: IsInitialized
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
  fullName: System.Windows.FrameworkContentElement.IsInitialized
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hiermee wordt een waarde die aangeeft of dit element is geïnitialiseerd, ofwel door wordt geladen als [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)], of doordat de expliciet de <xref:System.Windows.FrameworkContentElement.EndInit*>methode aangeroepen.</xref:System.Windows.FrameworkContentElement.EndInit*>"
  remarks: "Deze eigenschap kan ook worden `true` als dit element is verplaatst binnen de element-structuur zo dat er een nieuw bovenliggend element, en daarom opnieuw wordt geladen."
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het element is geïnitialiseerd per de hiervoor genoemde laden of methode aanroepen; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.IsLoaded
  id: IsLoaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
  fullName: System.Windows.FrameworkContentElement.IsLoaded
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Haalt een waarde die aangeeft of dit element is geladen voor presentatie."
  remarks: "Deze eigenschap wordt van een nieuw geconstrueerde exemplaar gestart uit `false`, en blijft `true` zodra deze is ingesteld op `true`, zelfs als daarna zijn verwijderd door de code."
  example:
  - "The following example code uses IsLoaded as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler. That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.  \n  \n [!code-cs[ContentElementsSmorgasbord#IsLoaded](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#isloaded)]\n [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#isloaded)]"
  syntax:
    content: public bool IsLoaded { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als het huidige element is gekoppeld aan een element-structuur en is weergegeven; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> als het element nooit is gekoppeld aan een geladen element-structuur."
  overload: System.Windows.FrameworkContentElement.IsLoaded*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Language
  id: Language
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Language
  nameWithType: FrameworkContentElement.Language
  fullName: System.Windows.FrameworkContentElement.Language
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van lokalisatie/globalisatie taalgegevens met betrekking tot een afzonderlijk element."
  remarks: "De tekenreeks volgen de standaard RFC 3066. Bijvoorbeeld, VS Engels is &quot;en-US&quot;. Zie <xref:System.Windows.Markup.XmlLanguage>voor meer informatie over de waarden en -indeling.</xref:System.Windows.Markup.XmlLanguage>       Deze afhankelijkheidseigenschap overgenomen eigenschapswaarden. Als er geen andere waarde voor onderliggende elementen zijn <xref:System.Windows.FrameworkElement.Language%2A>tot stand gebracht via lokale waarden of stijlen, het systeem eigenschap stelt u de waarde moet de <xref:System.Windows.FrameworkElement.Language%2A>waarde van het dichtstbijzijnde bovenliggende element met deze waarde toegewezen.</xref:System.Windows.FrameworkElement.Language%2A> </xref:System.Windows.FrameworkElement.Language%2A>      <a name=&quot;dependencyPropertyInfo_CultureInfo&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.LanguageProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.LanguageProperty>"
  syntax:
    content: public System.Windows.Markup.XmlLanguage Language { get; set; }
    return:
      type: System.Windows.Markup.XmlLanguage
      description: "De cultuur-informatie voor dit element. De standaardwaarde is een <xref href=&quot;System.Windows.Markup.XmlLanguage&quot;> </xref> exemplaar met de <xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>waarde ingesteld op de tekenreeks &quot;en-US&quot;.</xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>"
  overload: System.Windows.FrameworkContentElement.Language*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LanguageProperty
  id: LanguageProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LanguageProperty
  nameWithType: FrameworkContentElement.LanguageProperty
  fullName: System.Windows.FrameworkContentElement.LanguageProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.Language*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.Language*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LanguageProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Loaded
  id: Loaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Loaded
  nameWithType: FrameworkContentElement.Loaded
  fullName: System.Windows.FrameworkContentElement.Loaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Deze gebeurtenis treedt op wanneer het element is ingedeeld gerenderde en gereed voor interactie."
  remarks: "Directe gerouteerde gebeurtenissen een route niet uitvoert, zijn ze alleen verwerkt binnen hetzelfde element waarop ze worden gegenereerd. Directe gerouteerde gebeurtenissen bieden ondersteuning voor andere gedrag gerouteerde gebeurtenis: ondersteuning voor een verzameling toegankelijk handlers en ze kunnen worden gebruikt als een <xref:System.Windows.EventTrigger>in een style.</xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_Loaded&quot;></a>## Gerouteerd gebeurtenisgegevens |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.LoadedEvent>|   | Routingstrategie | Directe |   | Gemachtigde | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkContentElement.LoadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Loaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LoadedEvent
  id: LoadedEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LoadedEvent
  nameWithType: FrameworkContentElement.LoadedEvent
  fullName: System.Windows.FrameworkContentElement.LoadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref href=&quot;System.Windows.FrameworkContentElement.Loaded&quot;> </xref> [gerouteerd gebeurtenissen overzicht](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Gebeurtenis-id-objecten worden gemaakt wanneer gerouteerde gebeurtenissen worden geregistreerd (Zie <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) en kan vervolgens worden gebruikt voor de klasse-handlers toevoegen (Zie <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objecten bevatten een unieke naam, eigenaarstype handler-type, routingstrategie en een methode hulpprogramma voor eigenaars voor de gebeurtenis toe te voegen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent LoadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
  fullName: System.Windows.FrameworkContentElement.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hiermee wordt een enumerator voor het logische onderliggende elementen van dit element."
  remarks: "Voor meer informatie over het gebruik van LogicalChildren en <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, Zie [structuren in WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>"
  syntax:
    content: protected virtual System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "De enumerator voor logische onderliggende elementen van dit element."
  overload: System.Windows.FrameworkContentElement.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkContentElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "De toetsenbordfocus verplaatst van dit element naar een ander element."
  syntax:
    content: public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "De richting waarin de focus is het als een waarde van de inventarisatie worden verplaatst."
    return:
      type: System.Boolean
      description: "Retourneert <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> als focus is verplaatst; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> als het doelelement in richting als opgegeven bestaat niet."
  overload: System.Windows.FrameworkContentElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Name
  id: Name
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Name
  nameWithType: FrameworkContentElement.Name
  fullName: System.Windows.FrameworkContentElement.Name
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van de unieke naam van het element. De naam bevat een verwijzing naar het exemplaar zodat programmatische code-behind, zoals gebeurtenis-handlercode, naar een element verwijzen kan zodra deze wordt samengesteld tijdens het parseren van [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  remarks: "De meest voorkomende gebruik van deze eigenschap is bij het opgeven van een [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] elementnaam opgemaakt.       Met deze eigenschap wordt in wezen een eigenschap van de framework-niveau gemak WPF om in te stellen de [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] [x: Name richtlijn](~/add/includes/ajax-current-ext-md.md).       Een naam ophalen uit code wordt meestal niet, omdat als u de juiste verwijzing in de code al hebt, u alleen methoden aanroept kunt en eigenschappen voor het element verwijzen naar en niet in het algemeen moet de naam. Een uitzondering hierop is als de tekenreeks enkele overbelaste wil zeggen heeft, bijvoorbeeld als dit is handig om weer te geven die naam aanwezig in [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]. Een naam via code instellen als de oorspronkelijke naam was ingesteld vanuit de opmaak wordt ook niet aanbevolen en wijzigen van de eigenschap heeft geen invloed op de objectverwijzing. Dergelijke objectverwijzingen worden alleen gemaakt wanneer de onderliggende namescopes expliciet worden gemaakt tijdens het [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] laden.       U moet specifiek aanroepen <xref:System.Windows.FrameworkContentElement.RegisterName%2A>een effectieve wijziging aanbrengen op de eigenschap Name van een element al geladen.</xref:System.Windows.FrameworkContentElement.RegisterName%2A>       Een opmerkelijke geval waarin de naam van instelling vanuit code belangrijk wordt is voor de naamgeving van elementen die storyboards wordt uitgevoerd. Voordat u een naam registreren kunt, wellicht ook om te instantiëren en wijs een <xref:System.Windows.NameScope>exemplaar.</xref:System.Windows.NameScope> Zie de sectie Voorbeeld of [Storyboards overzicht](~/add/includes/ajax-current-ext-md.md).       Naam instelling vanuit code beperkte toepassingen, maar meer algemene, met name als u die gebruikmaakt van een navigatie-model waarbij pagina&quot;s opnieuw laden in de toepassing en de runtime-code niet per se de code-behind van de desbetreffende pagina opzoeken van een element met de naam is. De methode hulpprogramma <xref:System.Windows.FrameworkContentElement.FindName%2A>, die beschikbaar zijn vanaf elke is <xref:System.Windows.FrameworkContentElement>, vindt een element met de naam in van het element logische structuur recursief.</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkContentElement.FindName%2A> Of u kunt de <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>statische methode van <xref:System.Windows.LogicalTreeHelper>, wat ook de naam als een argument duurt.</xref:System.Windows.LogicalTreeHelper> </xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>       Gebruikte hoofdelementen (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page>bijvoorbeeld) implementeert de interface <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.Controls.Page> </xref:System.Windows.Window> Implementaties van deze interface worden om af te dwingen dat de namen zijn niet-ambigue binnen hun bereik verwacht.      <a name=&quot;dependencyPropertyInfo_Name&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.NameProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> </xref:System.Windows.FrameworkContentElement.NameProperty>"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "De naam van het element."
  overload: System.Windows.FrameworkContentElement.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.NameProperty
  id: NameProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: NameProperty
  nameWithType: FrameworkContentElement.NameProperty
  fullName: System.Windows.FrameworkContentElement.NameProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.Name*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.Name*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty NameProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Aangeroepen wanneer de <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuClosing&quot;> </xref> gerouteerde gebeurtenis bereikt deze klasse in de route. Implementeer deze methode om toe te voegen klasse verwerking voor deze gebeurtenis."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers. Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "Biedt gegevens over de gebeurtenis."
  overload: System.Windows.FrameworkContentElement.OnContextMenuClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Aangeroepen wanneer de <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuOpening&quot;> </xref> gerouteerde gebeurtenis bereikt deze klasse in de route. Implementeer deze methode om toe te voegen klasse verwerking voor deze gebeurtenis."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "Gebeurtenisgegevens voor de gebeurtenis."
  overload: System.Windows.FrameworkContentElement.OnContextMenuOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Klasse-handler voor de <xref href=&quot;System.Windows.ContentElement.GotFocus&quot;> </xref> gebeurtenis."
  remarks: "Deze klasse-handler stelt juiste focus gedrag in voor dit element als de gebeurtenis afkomstig van dit element is. Als de bron van de gebeurtenis is een ander element in de structuur, wordt de handler gebeurt er niets.       Deze methode overschrijven om deze standaardinstelling gedrag concentreren op uw element wijzigen."
  syntax:
    content: protected override void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "Gebeurtenisgegevens voor de gebeurtenis."
  overload: System.Windows.FrameworkContentElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  id: OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkContentElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkContentElement.OnInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Geeft de <xref href=&quot;System.Windows.FrameworkContentElement.Initialized&quot;> </xref> gebeurtenis. Deze methode wordt aangeroepen wanneer <xref:System.Windows.FrameworkContentElement.IsInitialized*>is ingesteld op <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.IsInitialized*>"
  remarks: "De standaardimplementatie van deze virtuele methode activeert de gebeurtenis, zoals eerder in dit onderwerp beschreven. Onderdrukkingen moeten aanroepen base() dit probleem moet worden bewaard.       Houd er rekening mee dat de <xref:System.Windows.FrameworkContentElement.IsInitialized%2A>eigenschap is alleen-lezen.</xref:System.Windows.FrameworkContentElement.IsInitialized%2A> Daarom instellen u deze niet om af te dwingen initialisatie gedrag op die manier. Initialisatie-instelling is bedoeld om te worden uitgevoerd door alleen de [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] framework."
  syntax:
    content: protected virtual void OnInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "Gebeurtenisgegevens voor de gebeurtenis."
  overload: System.Windows.FrameworkContentElement.OnInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Aangeroepen wanneer de effectieve waarde van de afhankelijkheidseigenschap van een op deze <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> is bijgewerkt. De specifieke afhankelijkheidseigenschap die gewijzigd wordt in de parameter argumenten gerapporteerd. Onderdrukkingen <xref:System.Windows.DependencyObject.OnPropertyChanged*>.</xref:System.Windows.DependencyObject.OnPropertyChanged*>"
  remarks: "Deze methode is niet bedoeld om te detecteren in het algemeen eigenschapswijzigingen of invalidations. Het is in plaats daarvan bedoeld om de wijzigingen van het patroon algemene ongeldig maken als bepaalde gegevens over wide classificaties van eigenschappen bekend is.       Deze methode is mogelijk meerdere keren aangeroepen tijdens de levensduur van een object. Daarom kunt u betere prestaties bereiken wanneer u de metagegevens van specifieke eigenschappen overschrijft en koppel vervolgens <xref:System.Windows.CoerceValueCallback>of <xref:System.Windows.PropertyChangedCallback>functies voor afzonderlijke eigenschappen.</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback> U zou deze methode echter gebruiken als een <xref:System.Windows.FrameworkContentElement>bevat een groot aantal afhankelijkheidseigenschappen waarde-aan elkaar gerelateerd, of als deze logica bevat, zoals de rendering van gedrag die moet opnieuw worden uitgevoerd voor verschillende gevallen van eigenschap invalidations gerelateerde.</xref:System.Windows.FrameworkContentElement>       Houd er rekening mee dat er een exact dezelfde naam `OnPropertyChanged` methode met een andere handtekening (het parametertype is <xref:System.ComponentModel.PropertyChangedEventArgs>) die op een aantal klassen kunnen worden weergegeven.</xref:System.ComponentModel.PropertyChangedEventArgs> Dat `OnPropertyChanged` wordt gebruikt voor gegevens object meldingen en maakt deel uit van het contract voor <xref:System.ComponentModel.INotifyPropertyChanged>.</xref:System.ComponentModel.INotifyPropertyChanged>"
  syntax:
    content: protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "De gebeurtenisgegevens die worden beschreven van de eigenschap die is gewijzigd, met inbegrip van de oude en nieuwe waarden."
  overload: System.Windows.FrameworkContentElement.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  id: OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkContentElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkContentElement.OnStyleChanged(Style,Style)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Aangeroepen als de stijl die wordt gebruikt op de wijzigingen van dit element."
  remarks: "Deze methode heeft een standaardimplementatie die stelt u een interne vlag Zoek ook de voorwaarde van de stijl die wordt gewijzigd."
  syntax:
    content: protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);
    parameters:
    - id: oldStyle
      type: System.Windows.Style
      description: "De oude stijl."
    - id: newStyle
      type: System.Windows.Style
      description: "De nieuwe stijl."
  overload: System.Windows.FrameworkContentElement.OnStyleChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Aangeroepen wanneer de <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipClosing&quot;> </xref> gerouteerde gebeurtenis bereikt deze klasse in de route. Implementeer deze methode om toe te voegen klasse verwerking voor deze gebeurtenis."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Biedt gegevens over de gebeurtenis."
  overload: System.Windows.FrameworkContentElement.OnToolTipClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Aangeroepen wanneer de <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipOpening&quot;> </xref> gerouteerde gebeurtenis bereikt deze klasse in de route. Implementeer deze methode om toe te voegen klasse verwerking voor deze gebeurtenis."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Biedt gegevens over de gebeurtenis."
  overload: System.Windows.FrameworkContentElement.OnToolTipOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  id: OverridesDefaultStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van een waarde die aangeeft of dit element stijleigenschappen van themastijlen opgenomen."
  remarks: "Het meest voorkomende gebruik van deze eigenschap is een indirecte gebruik binnen de setter-methode van een stijl die een stijl, thema levert.      <a name=&quot;dependencyPropertyInfo_OverridesDefaultStyle&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>"
  syntax:
    content: public bool OverridesDefaultStyle { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als dit element geen thema stijleigenschappen gebruikt; alle eigenschappen die afkomstig zijn van een stijl afkomstig zijn van lokale toepassingen stijlen en thema-style-eigenschappen zijn niet van toepassing. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Als toepassing stijlen eerst toepassen themastijlen toepassen voor eigenschappen die niet specifiek in de stijlen van toepassing zijn ingesteld."
  overload: System.Windows.FrameworkContentElement.OverridesDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  id: OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkContentElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Parent
  id: Parent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Parent
  nameWithType: FrameworkContentElement.Parent
  fullName: System.Windows.FrameworkContentElement.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hiermee haalt de bovenliggende in de logische structuur voor dit element."
  remarks: "Houd er rekening mee dat de logisch bovenliggend element van een element, afhankelijk van de toepassingsfunctionaliteit van uw wijzigen kan en houden de waarde van deze eigenschap wordt niet aangepast. Normaal gesproken krijgt u de waarde vlak voordat u deze nodig hebt.       Zie [structuren in WPF](~/add/includes/ajax-current-ext-md.md) voor meer informatie over het doorlopen van logische structuren en de scenario&quot;s waar deze aanpak naar element detectie geschikt is.       De eigenschap systeem wordt mogelijk opnieuw berekend alle waarden in de eigenschappen van een element wanneer deze nieuw bovenliggend element krijgt is, omdat bepaalde eigenschappen waarden door de logische structuur overneemt. De <xref:System.Windows.FrameworkContentElement.DataContext%2A>die van toepassing is voor bindingen kunnen ook worden gewijzigd wanneer de elementen zijn nieuw bovenliggend element krijgt.</xref:System.Windows.FrameworkContentElement.DataContext%2A>       Wijzigen van een element bovenliggende gewoonlijk alleen wordt uitgevoerd via het manipuleren van verzamelingen, met behulp van specifieke toevoegen of verwijderen methoden, of door het instellen van eigenschappen van de inhoud van elementen.       De meest voorkomende scenario voor het gebruik van de eigenschap Parent is een verwijzing verkrijgen en vervolgens verschillende <xref:System.Windows.FrameworkContentElement>eigenschapswaarden van het bovenliggende object.</xref:System.Windows.FrameworkContentElement> Voor sjablonen, het bovenliggende lid van de sjabloon uiteindelijk worden `null`. Hoe krijg ik dit punt en uitbreiden van de logische structuur waarin de sjabloon daadwerkelijk is toegepast, gebruikt u <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>"
  example:
  - "The following example checks to see whether the Parent of a <xref:System.Windows.Documents.TextPointer> is of a particular type.  \n  \n [!code-cs[TextPointer_snippets#FCEParent](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#fceparent)]\n [!code-vb[TextPointer_snippets#FCEParent](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#fceparent)]"
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "De logische bovenliggende voor dit element."
  overload: System.Windows.FrameworkContentElement.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hiermee bepaalt u het volgende element dat focus ten opzichte van dit element de richting van verkeer opgegeven focus krijgt, maar de focus niet daadwerkelijk wordt verplaatst. Deze methode is verzegeld en kan niet worden overschreven."
  remarks: "<xref:System.Windows.FrameworkContentElement.MoveFocus%2A>is de bijbehorende methode die daadwerkelijk focus verplaatsen.</xref:System.Windows.FrameworkContentElement.MoveFocus%2A>"
  syntax:
    content: public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "De richting waarvoor een potentiële focus wijziging moet worden bepaald."
    return:
      type: System.Windows.DependencyObject
      description: "Het volgende element die specifiek zijn gericht zou worden verplaatst naar als focus daadwerkelijk zijn doorkruist. Kan retourneren <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> als focus voor de opgegeven richting ten opzichte van dit element kan niet worden verplaatst."
  overload: System.Windows.FrameworkContentElement.PredictFocus*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: 'Specified one of the following directions in the <xref href=&quot;System.Windows.Input.TraversalRequest&quot;></xref>: <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>. Deze instructies zijn niet geldig voor PredictFocus (maar ze zijn geldig voor <xref:System.Windows.FrameworkContentElement.MoveFocus*>).</xref:System.Windows.FrameworkContentElement.MoveFocus*>'
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  id: RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: RegisterName(String,Object)
  nameWithType: FrameworkContentElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkContentElement.RegisterName(String,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Biedt een accessor die vereenvoudigt de toegang tot de <xref:System.Windows.NameScope>registratiemethode.</xref:System.Windows.NameScope>"
  remarks: "Dit is een methode gemak voor het aanroepen van <xref:System.Windows.NameScope.RegisterName%2A>.</xref:System.Windows.NameScope.RegisterName%2A> De implementatie van de wordt opeenvolgende bovenliggende elementen gecontroleerd, totdat de toepasselijke <xref:System.Windows.NameScope>implementatie, die worden gevonden door het vinden van een element dat <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> implementeert</xref:System.Windows.NameScope> is gevonden Zie voor meer informatie over namescopes [WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md).       Het aanroepen van RegisterName is nodig om te koppelen correct animatie storyboards voor toepassingen wanneer gemaakt in de code. Dit is omdat een van de sleutel storyboard-eigenschappen, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, lookup voor een runtime-naam in plaats van een verwijzing naar een target-element kunnen worden gebruikt.</xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> Dit geldt ook als dat element toegankelijk is op basis van de code. Zie voor meer informatie over waarom u nodig hebt om namen voor storyboard doelen te registreren, [Storyboards overzicht](~/add/includes/ajax-current-ext-md.md). Animaties voor inhoud elementen zijn minder gangbaar dan animaties besturingselementen op de [Storyboards overzicht](../Topic/Storyboards%20Overview.md) richt zich op scenario&quot;s."
  syntax:
    content: public void RegisterName (string name, object scopedElement);
    parameters:
    - id: name
      type: System.String
      description: "De naam moet worden gebruikt voor de opgegeven naam-object-toewijzing."
    - id: scopedElement
      type: System.Object
      description: "Object voor de toewijzing."
  overload: System.Windows.FrameworkContentElement.RegisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  id: RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkContentElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.RemoveLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Verwijdert het opgegeven element van de logische structuur voor dit element."
  remarks: "Dit [!INCLUDE[TLA#tla_api](~/add/includes/tlasharptla-api-md.md)] is vooral relevant zijn voor de klasse scenario&quot;s, die bij het toevoegen van ondersteuning voor onderliggende collecties.       De meeste <xref:System.Windows.FrameworkContentElement>afgeleide klassen zichtbaar toegewezen verzamelingen die verantwoordelijk voor de containment zijn (bijvoorbeeld <xref:System.Windows.Documents.Span.Inlines%2A>op de klasse <xref:System.Windows.Documents.Span>; <xref:System.Windows.Documents.Section.Blocks%2A>op de <xref:System.Windows.Documents.Section>klasse).</xref:System.Windows.Documents.Section> </xref:System.Windows.Documents.Section.Blocks%2A> </xref:System.Windows.Documents.Span> </xref:System.Windows.Documents.Span.Inlines%2A> </xref:System.Windows.FrameworkContentElement> Doorgaans die zijn afgeleid van dergelijke klassen kunt hoeft te manipuleren van de logische structuur rechtstreeks voorkomen."
  syntax:
    content: protected void RemoveLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "Het element te verwijderen."
  overload: System.Windows.FrameworkContentElement.RemoveLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Resources
  id: Resources
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Resources
  nameWithType: FrameworkContentElement.Resources
  fullName: System.Windows.FrameworkContentElement.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van de huidige bron lokaal gedefinieerde woordenlijst."
  remarks: "Bronwoordenboeken die volledig of gedeeltelijk in kunnen worden gedefinieerd [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] gewoonlijk worden gemaakt als een eigenschapselement en zijn doorgaans op het hoofdelement voor elke afzonderlijke pagina of voor de toepassing. De resource-woordenlijst plaatsen op dit niveau, kunt gemakkelijker afzonderlijke onderliggende elementen op de pagina (of andere pagina&quot;s in het geval van toepassing) niet vinden. In de meeste gevallen van toepassing, wordt aangeraden dat stijlen worden gedefinieerd als object-elementen in een woordenlijst resource of worden gedefinieerd als externe bronnen, zodat de gehele stijl resource zelfstandig (deze benadering helpt designer verantwoordelijkheden van de verantwoordelijkheden van de ontwikkelaar worden gescheiden door het scheiden van de fysieke bestanden die moeten worden bewerkt).       Houd er rekening mee dat deze eigenschap retourneert alleen de resource-woordenlijst die rechtstreeks in dat element. Dit is anders dan de werkelijke resource lookup-proces waarbij een onderliggend element toegang heeft tot de bronnen die zijn gedefinieerd in elke bovenliggende element omhoog recursief zoeken.       Resources kunnen ook worden verwezen met de code uit binnen de verzameling, maar houd er rekening mee dat resources gemaakt in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] zeker niet toegankelijk zijn pas na <xref:System.Windows.FrameworkContentElement.Loaded>is gemeld door het element dat het woordenboek declareert.</xref:System.Windows.FrameworkContentElement.Loaded> In feite resources asynchroon worden geparseerd en zelfs als deze niet de <xref:System.Windows.FrameworkContentElement.Loaded>gebeurtenis is een zekerheid dat u kunt verwijzen naar een [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] resource gedefinieerd.</xref:System.Windows.FrameworkContentElement.Loaded> Om deze reden u moet over het algemeen alleen toegang tot [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] resources gedefinieerd als onderdeel van de runtime-code of via andere [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] technieken zoals stijlen of resource-uitbreiding verwijzingen voor kenmerkwaarden. Wanneer u via programmacode toegang bronnen tot, het is in wezen gelijk is aan een verwijzing van [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)].       De onderliggende <xref:System.Windows.ResourceDictionary>ondersteunt de methoden die zijn vereist voor het toevoegen, verwijderen of query uitvoeren op resources uit binnen de verzameling met code.</xref:System.Windows.ResourceDictionary> De eigenschap Resources kan worden ingesteld voor de ondersteuning van het scenario van de verzameling bronnen van een element moet een nieuwe volledig te vervangen of andere <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>       U ziet dat de [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntaxis weergegeven bevat geen element voor de <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> Dit is een voorbeeld van de syntaxis van de impliciete verzameling; een label voor het verzamelingselement kan worden weggelaten. De elementen die zijn toegevoegd als items in de verzameling in plaats daarvan worden opgegeven. Voor meer informatie over impliciete verzamelingen en [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], Zie [XAML syntaxis In Detail](~/add/includes/ajax-current-ext-md.md). Een case indien een <xref:System.Windows.ResourceDictionary>is nog steeds opgegeven expliciet als een element is als u een samengevoegde woordenboek worden geïntroduceerd in dat geval moeten er zijn meestal geen onderliggende elementen voor die <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary> Zie voor meer informatie [Bronwoordenboeken samengevoegd](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlPropertyElementUsage_Resources&quot;></a>## XAML eigenschap elementgebruik ```   <object>     <object.Resources>       oneOrMoreResourceElements     </object.Resources>   </object>   ``` <a name=&quot;xamlValues_Resources&quot;> </a> ## XAML waarden *oneOrMoreResourceElements* een of meer object elementen, elk met een resource definieert.       Elk element in de resource-eigenschap binnen elke <xref:System.Windows.ResourceDictionary>moet een unieke waarde hebben voor de [x: sleutel richtlijn](~/add/includes/ajax-current-ext-md.md), die fungeert als de unieke sleutel als waarden worden opgehaald uit de <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary>"
  example:
  - "The following example establishes a Resources collection on a <xref:System.Windows.Documents.FlowDocument> root element. <xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.  \n  \n [!code-xml[ContentElementsSmorgasbord#FCEResources](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page2.xaml#fceresources)]"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "De huidige lokaal gedefinieerde bronnen. Dit is een dictionary van resources, waar resources binnen het woordenboek worden gebruikt door de sleutel."
  overload: System.Windows.FrameworkContentElement.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  id: SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Een binding koppelt aan dit element, op basis van de opgegeven naam van de eigenschap als een kwalificatie voor pad naar de gegevensbron."
  remarks: "Dit is een methode gemak voor aanroepen <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, die wordt doorgegeven als het huidige exemplaar van de <xref:System.Windows.DependencyObject>, en maakt u een nieuwe <xref:System.Windows.Data.Binding>op basis van de opgegeven `path` parameter.</xref:System.Windows.Data.Binding> </xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName> Deze handtekening is eenvoudiger als u een eenvoudige standaard binding tot stand brengt. Als u wilt bindingeigenschappen opgeven voor niet-standaard voorwaarden of wilt gebruiken een <xref:System.Windows.Data.MultiBinding>of <xref:System.Windows.Data.PriorityBinding>, moet u de <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>handtekening.</xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> </xref:System.Windows.Data.PriorityBinding> </xref:System.Windows.Data.MultiBinding>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.  \n  \n [!code-cs[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#datacontext)]\n [!code-vb[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#datacontext)]"
  syntax:
    content: public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Identificeert de eigenschap gebonden."
    - id: path
      type: System.String
      description: "De naam van de bron-eigenschap of het pad naar de eigenschap die wordt gebruikt voor de binding."
    return:
      type: System.Windows.Data.BindingExpression
      description: "Registreert de voorwaarden van de binding. Deze waarde is handig voor foutcontrole."
  overload: System.Windows.FrameworkContentElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  id: SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Een binding koppelt aan dit element, op basis van de opgegeven bindingsobject."
  remarks: "Dit is een methode gemak om aan te roepen <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, die wordt doorgegeven met het huidige exemplaar als de <xref:System.Windows.DependencyObject>.</xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.  \n  \n [!code-cs[ContentElementsSmorgasbord#SetBinding](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#setbinding)]\n [!code-vb[ContentElementsSmorgasbord#SetBinding](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#setbinding)]"
  syntax:
    content: public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Identificeert de eigenschap gebonden."
    - id: binding
      type: System.Windows.Data.BindingBase
      description: "Vertegenwoordigt een gegevensbinding."
    return:
      type: System.Windows.Data.BindingExpressionBase
      description: "Registreert de voorwaarden van de binding. Deze waarde is handig voor foutcontrole."
  overload: System.Windows.FrameworkContentElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  id: SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Zoekt naar een resource met de opgegeven naam en een resourceverwijzing naar deze van de voor de opgegeven eigenschap heeft ingesteld."
  remarks: "Een resourceverwijzing is vergelijkbaar met het gebruik van een [DynamicResource Opmaakextensie](~/add/includes/ajax-current-ext-md.md) opgemaakt. De resourceverwijzing maakt een interne expressie die de waarde van de opgegeven eigenschap runtime-uitgestelde op basis van een levert. De expressie wordt opnieuw worden geëvalueerd als de resource-woordenlijst verwijst naar een gewijzigde waarde via interne gebeurtenissen op, of als het huidige element is nieuw bovenliggend element krijgt (een wijziging in de bovenliggende wijzigen het woordenboek lookup-pad)."
  syntax:
    content: public void SetResourceReference (System.Windows.DependencyProperty dp, object name);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "De eigenschap waaraan de resource is gebonden."
    - id: name
      type: System.Object
      description: "De naam van de resource."
  overload: System.Windows.FrameworkContentElement.SetResourceReference*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources
  id: ShouldSerializeResources
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ShouldSerializeResources()
  nameWithType: FrameworkContentElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeResources()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retourneert of serialisatie processen serialisatie toepassen op de inhoud van de <xref:System.Windows.FrameworkContentElement.Resources*>eigenschap op instanties van deze klasse moeten.</xref:System.Windows.FrameworkContentElement.Resources*>"
  remarks: "Hiermee herstelt u `true` zolang er ten minste één versleutelde bron van de lokale <xref:System.Windows.FrameworkContentElement.Resources%2A>.</xref:System.Windows.FrameworkContentElement.Resources%2A> is"
  syntax:
    content: public bool ShouldSerializeResources ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de <xref:System.Windows.FrameworkContentElement.Resources*>eigenschapswaarde moet geserialiseerde; anders wordt <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.Resources*>"
  overload: System.Windows.FrameworkContentElement.ShouldSerializeResources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle
  id: ShouldSerializeStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ShouldSerializeStyle()
  nameWithType: FrameworkContentElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Retourneert of serialisatie processen serialisatie toepassen op de inhoud van de <xref:System.Windows.FrameworkContentElement.Style*>eigenschap op instanties van deze klasse moeten.</xref:System.Windows.FrameworkContentElement.Style*>"
  remarks: "Hiermee herstelt u `true` als de <xref:System.Windows.Style>lokaal is ingesteld.</xref:System.Windows.Style>"
  syntax:
    content: public bool ShouldSerializeStyle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de <xref:System.Windows.FrameworkContentElement.Style*>eigenschapswaarde moet geserialiseerde; anders wordt <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.Style*>"
  overload: System.Windows.FrameworkContentElement.ShouldSerializeStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SourceUpdated
  id: SourceUpdated
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SourceUpdated
  nameWithType: FrameworkContentElement.SourceUpdated
  fullName: System.Windows.FrameworkContentElement.SourceUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Treedt op wanneer alle gekoppelde gegevensbron die deel uitmaken van een binding van de wijzigingen van dit element."
  remarks: "Deze gebeurtenis komt de <xref:System.Windows.Data.Binding.SourceUpdated>gebeurtenis die wordt gegenereerd door een <xref:System.Windows.Data.Binding>die zijn gekoppeld aan dit element.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.SourceUpdated>      <a name=&quot;xamlAttributeUsage_SourceUpdated&quot;></a>## Gebruik XAML-kenmerk```   <object SourceUpdated=&quot;EventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> SourceUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Style
  id: Style
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Style
  nameWithType: FrameworkContentElement.Style
  fullName: System.Windows.FrameworkContentElement.Style
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van de stijl die moet worden gebruikt door dit element."
  remarks: "De huidige stijl is vaak geleverd door een standaardstijl van thema&quot;s, of van stijlen die in het algemeen worden toegepast op objecten van dat type door resources op pagina- of toepassingsniveau (een impliciete stijl). Deze eigenschap geen standaard niet ingesteld of geretourneerd (themastijlen), maar wel de impliciete opmaakprofiel of een expliciete. In het geval van impliciet of expliciet stijlen, het maakt niet uit of de stijl is toegankelijk als een resource of lokaal worden gedefinieerd.       De stijlen heeft enkele beperkingen. U kunt de volledige stijleigenschap opnieuw instellen naar een nieuwe <xref:System.Windows.Style>op elk gewenst moment waarop een lay-out recomposition forceert.</xref:System.Windows.Style> Echter, zodra deze stijl wordt geplaatst in gebruik door een element geladen de <xref:System.Windows.Style>rekening verzegeld.</xref:System.Windows.Style> Poging een wijziging aanbrengt aan een afzonderlijke eigenschap van een stijl in gebruik (zoals alles binnen de verzameling van <xref:System.Windows.Style.Setters%2A>) veroorzaakt een uitzondering gegenereerd.</xref:System.Windows.Style.Setters%2A> Wordt beschouwd als een stijl die is gedefinieerd in de opmaak worden gebruikt als u deze van een woordenboek resource (voor resources genoemd) is geladen, of de pagina die deze zich bevindt binnen wordt geladen (voor inline-profielen).       Stijl is een afhankelijkheidseigenschap met speciale prioriteit. De ingestelde lokaal stijl werkt doorgaans op de hoogste prioriteit in het systeem eigenschap. Als de stijl die wordt op dit moment null is, tijdens het laden van de eigenschap systeemcontroles voor impliciete stijlen als gedefinieerde resources die dat type opgeven. Als de stijl die na deze stap nog steeds null is, klikt u vervolgens de stijl die afkomstig is van de standaardstijl (thema), maar de standaardstijl die wordt niet geretourneerd als de waarde voor de eigenschap Style. Zie [afhankelijkheid eigenschap waarde prioriteit](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_Style&quot;></a>## XAML Kenmerkgebruik ```   <object Style=&quot;{resourceExtension StyleResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_Style&quot;> </a> ## XAML waarden *resourceExtension* een van de volgende:, of.       Zie [XAML Resources](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* de sleutel waarmee de stijl die wordt aangevraagd. De sleutel verwijst naar een bestaande resource in een <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      > [!NOTE] > Eigenschapselementsyntaxis is technisch mogelijk is, maar niet aanbevolen. Zie [inlinestijlen en sjablonen](~/add/includes/ajax-current-ext-md.md).  Een binding verwijzing met of <xref:System.Windows.Data.Binding>is ook mogelijk, maar ongewoon.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_Style&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.StyleProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.StyleProperty>"
  example:
  - "The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.  \n  \n [!code-xml[ContentElementsSmorgasbord#FCEResources](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page2.xaml#fceresources)]"
  syntax:
    content: public System.Windows.Style Style { get; set; }
    return:
      type: System.Windows.Style
      description: "De toegepaste, niet-stijl voor het element, indien aanwezig. Anders <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>. De standaardwaarde voor een standaard samengesteld <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.Style*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.StyleProperty
  id: StyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: StyleProperty
  nameWithType: FrameworkContentElement.StyleProperty
  fullName: System.Windows.FrameworkContentElement.StyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.Style*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.Style*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty StyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Zie voor een beschrijving van dit lid, de <xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>methode.</xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>"
  remarks: "Dit lid is een expliciete interface lid-implementatie. Het kan worden gebruikt alleen wanneer de <xref:System.Windows.FrameworkContentElement>exemplaar is geconverteerd naar een <xref:System.Windows.Markup.IQueryAmbient>interface.</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.FrameworkContentElement>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "De naam van de gevraagde ambient eigenschap."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als <code> propertyName </code> is beschikbaar, anders, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Tag
  id: Tag
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Tag
  nameWithType: FrameworkContentElement.Tag
  fullName: System.Windows.FrameworkContentElement.Tag
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van een willekeurige objectwaarde die kan worden gebruikt voor het opslaan van aangepaste gegevens over dit element."
  remarks: "Deze eigenschap is vergelijkbaar met de eigenschappen van de Tag in andere [!INCLUDE[TLA#tla_ms](~/add/includes/tlasharptla-ms-md.md)] modellen, zoals programming [!INCLUDE[TLA#tla_vba](~/add/includes/ajax-current-ext-md.md)] of [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)]. Het is bedoeld om een bestaande plaats voor het opslaan van aangepaste basisinformatie over elk element zonder subklasse ontwikkelaars van toepassingen.      <a name=&quot;xamlValues_Tag&quot;></a>## XAML waarden omdat deze eigenschap wordt een object, moet u het gebruik van de eigenschap element gebruiken om het instellen van de eigenschap Tag in [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] naar iets anders dan een object met een bekende en ingebouwde typeconversieprogramma, zoals een string. Objecten die worden gebruikt op deze manier zijn meestal niet binnen de standaard [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] naamruimten en wellicht naamruimtetoewijzing aan de externe naamruimte om te worden opgenomen als [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] elementen.      <a name=&quot;dependencyPropertyInfo_Tag&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.TagProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`| Geen |</xref:System.Windows.FrameworkContentElement.TagProperty>"
  syntax:
    content: public object Tag { get; set; }
    return:
      type: System.Object
      description: "De beoogde waarde. Deze eigenschap heeft geen standaardwaarde."
  overload: System.Windows.FrameworkContentElement.Tag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TagProperty
  id: TagProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TagProperty
  nameWithType: FrameworkContentElement.TagProperty
  fullName: System.Windows.FrameworkContentElement.TagProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.Tag*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.Tag*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TagProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TargetUpdated
  id: TargetUpdated
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TargetUpdated
  nameWithType: FrameworkContentElement.TargetUpdated
  fullName: System.Windows.FrameworkContentElement.TargetUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Treedt op wanneer een eigenschap target die deel uitmaken van een binding van dit element wijzigingen die zijn gekoppeld."
  remarks: "Deze gebeurtenis komt de <xref:System.Windows.Data.Binding.TargetUpdated>gebeurtenis die wordt gegenereerd door een <xref:System.Windows.Data.Binding>die zijn gekoppeld aan dit element.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.TargetUpdated> Dit betekent meestal dat de betreffende binding een binding in twee richtingen is en dat de afhankelijke afhankelijkheidseigenschap een ongeldig maken van de vorige eigenschapswaarde per validatie of opslaan in cache schema die ondersteuning biedt voor de eigenschap bevestigt.       De gebeurtenisargumenten van deze gebeurtenis laat u die eigenschap gebonden is gewijzigd.      <a name=&quot;xamlAttributeUsage_TargetUpdated&quot;></a>## Gebruik XAML-kenmerk```   <object TargetUpdated=&quot;EventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> TargetUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TemplatedParent
  id: TemplatedParent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
  fullName: System.Windows.FrameworkContentElement.TemplatedParent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Hiermee haalt u een verwijzing naar de bovenliggende sjabloon van dit element. Deze eigenschap is niet relevant als het element niet via een sjabloon gemaakt is."
  remarks: "Sjablonen zijn daadwerkelijk gedeelde objecten, waar de inhoud van de sjabloon slechts één keer worden gemaakt. Dus als u een objectverwijzing naar een element dat afkomstig van een sjabloon krijgt is, merkt u de logische structuur van de zichtbare komt niet in de hoofdmap van de pagina. Om te kunnen verbinding maken met een sjabloon verwezen naar de logische structuur van de pagina, moet u de waarde TemplatedParent verkrijgen en doorgaan om te navigeren naar wens element structuur.       TemplatedParent worden vaak `null` voor algemene objecten, omdat als u een verwijzing naar een object buiten een pagina hebt verkregen in uw toepassing via de gebruikelijke manier, dat element waarschijnlijk niet is gemaakt vanuit een sjabloon. Gevallen waarin TemplatedParent niet mogelijk `null` omvat bewerkingen zoals hit testen gebeurtenis verwerking voor bepaalde op laag niveau invoervelden en werken met enumerators die mogelijk geretourneerd elementen die afkomstig zijn van sjablonen."
  syntax:
    content: public System.Windows.DependencyObject TemplatedParent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "Het element waarvan <xref href=&quot;System.Windows.FrameworkTemplate&quot;> </xref> <xref:System.Windows.FrameworkTemplate.VisualTree*>veroorzaakt dit element moet worden gemaakt.</xref:System.Windows.FrameworkTemplate.VisualTree*> Deze waarde is vaak <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; Zie de opmerkingen."
  overload: System.Windows.FrameworkContentElement.TemplatedParent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTip
  id: ToolTip
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
  fullName: System.Windows.FrameworkContentElement.ToolTip
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opgehaald of ingesteld van de knopinfo object dat wordt weergegeven voor dit element in de [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]."
  remarks: "Als de waarde van deze eigenschap van het type is <xref:System.Windows.Controls.ToolTip>, die wordt de knopinfo die wordt gebruikt in de [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Controls.ToolTip>  Als de waarde van een ander type, wordt die waarde wordt gebruikt als de *inhoud* voor een <xref:System.Windows.Controls.ToolTip>opgegeven (samengesteld) door het systeem.</xref:System.Windows.Controls.ToolTip> Zie voor meer informatie <xref:System.Windows.Controls.ToolTipService>.</xref:System.Windows.Controls.ToolTipService> De serviceklasse biedt de bijgevoegde eigenschappen die kunnen worden gebruikt voor het verder aanpassen van de knopinfo.      <a name=&quot;xamlAttributeUsage_ToolTip&quot;></a>## XAML Kenmerkgebruik ```   <object ToolTip=&quot;toolTipContent&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_ToolTip&quot;> </a> ## elementgebruik XAML-eigenschap ```   <object>     <object.ToolTip>       <ToolTip .../>     </object.ToolTip>   </object>   - or -   <object>     <object.ToolTip>       toolTipObjectContent     </object.ToolTip>   </object>   ``` <a name=&quot;xamlValues_ToolTip&quot;> </a> ## XAML waarden *toolTipContent* een tekenreeks die de tekst weergeven voor de ToolTip wordt.                   *toolTipObjectContent* sommige object, dat is opgegeven in object-element formulier, dat moet worden gebruikt als de inhoud voor de <xref:System.Windows.FrameworkContentElement>.</xref:System.Windows.FrameworkContentElement> Doorgaans is dit een <xref:System.Windows.FrameworkElement>of een ander element waarmee samenstellen lay-out voor de knopinfo, die de tekst uiteindelijk bevat inhoud binnen het samenstellen.</xref:System.Windows.FrameworkElement> In dit gebruik de <xref:System.Windows.Controls.ToolTip>element is gemaakt impliciet van de geparseerde [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], en de *toolTipObjectContent* inhoud is ingesteld als de <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName>eigenschap.</xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName> </xref:System.Windows.Controls.ToolTip>       `ToolTip`.../>    See <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;dependencyPropertyInfo_ToolTip&quot;></a>## Gegevens van afhankelijkheidseigenschap |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.ToolTipProperty>|   | Eigenschappen van metagegevens is ingesteld op `true`| Geen |</xref:System.Windows.FrameworkContentElement.ToolTipProperty>"
  example:
  - "The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.  \n  \n [!code-cs[TableSnippets2#_Table_RowGroups_ManipRows](~/add/codesnippet/csharp/TableSnippets2/Window1.xaml.cs#_table_rowgroups_maniprows)]\n [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/add/codesnippet/visualbasic/tablesnippets2/window1.xaml.vb#_table_rowgroups_maniprows)]"
  syntax:
    content: public object ToolTip { get; set; }
    return:
      type: System.Object
      description: "Het tooltip-object. Zie opmerkingen hieronder voor meer informatie over waarom deze parameter niet sterk getypeerd is."
  overload: System.Windows.FrameworkContentElement.ToolTip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipClosing
  id: ToolTipClosing
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipClosing
  nameWithType: FrameworkContentElement.ToolTipClosing
  fullName: System.Windows.FrameworkContentElement.ToolTipClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Deze gebeurtenis treedt op vlak voordat een tooltip voor het element is gesloten."
  remarks: "Om het sluiten van de knopinfo, moeten handlers van de gebeurtenis gemarkeerd als verwerkt.       Deze gebeurtenis kan niet een <xref:System.Windows.EventTrigger>in een style.</xref:System.Windows.EventTrigger> Dit is omdat het veld id van deze gebeurtenis wordt opnieuw gebruikt voor een implementatie van een service die wordt methoden toevoegen of verwijderen van de gebeurtenis niet beschikbaar.      <a name=&quot;routedEventInfo_ToolTipClosing&quot;></a>## Gerouteerd gebeurtenisgegevens |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|   | Routingstrategie | Directe |   | Gemachtigde | <xref:System.Windows.Controls.ToolTipEventHandler>|</xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  id: ToolTipClosingEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipClosingEvent
  nameWithType: FrameworkContentElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipClosing&quot;> </xref> [gerouteerd gebeurtenissen overzicht](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Gebeurtenis-id-objecten worden gemaakt wanneer gerouteerde gebeurtenissen worden geregistreerd (Zie <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) en kan vervolgens worden gebruikt voor de klasse-handlers toevoegen (Zie <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objecten bevatten een unieke naam, eigenaarstype handler-type, routingstrategie en een methode hulpprogramma voor eigenaars voor de gebeurtenis toe te voegen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipOpening
  id: ToolTipOpening
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipOpening
  nameWithType: FrameworkContentElement.ToolTipOpening
  fullName: System.Windows.FrameworkContentElement.ToolTipOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Deze gebeurtenis treedt op wanneer een tooltip voor het element wordt geopend."
  remarks: "Handlers van de gebeurtenissen moeten handmatig te openen knopinfo, niet de relevante gebeurtenis markeren als verwerkt. Anders wordt de waarde van de <xref:System.Windows.FrameworkContentElement.ToolTip%2A>eigenschap wordt gebruikt om automatisch een contextmenu te openen.</xref:System.Windows.FrameworkContentElement.ToolTip%2A> Markering van de gebeurtenis verwerkt de standaardactie effectief wordt geannuleerd en kan een kans om de waarde van de <xref:System.Windows.FrameworkContentElement.ToolTip%2A>eigenschap en open vervolgens de nieuwe <xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkContentElement.ToolTip%2A> opnieuw instellen Houd er rekening mee dat deze gebeurtenis niet worden verhoogd als <xref:System.Windows.FrameworkContentElement.ToolTip%2A>is een null-verwijzing of anderszins.</xref:System.Windows.FrameworkContentElement.ToolTip%2A>       Deze gebeurtenis kan niet een <xref:System.Windows.EventTrigger>in een style.</xref:System.Windows.EventTrigger> Dit is omdat het veld id van deze gebeurtenis wordt opnieuw gebruikt voor een implementatie van een service die wordt methoden toevoegen of verwijderen van de gebeurtenis niet beschikbaar.      <a name=&quot;routedEventInfo_ToolTipOpening&quot;></a>## Gerouteerd gebeurtenisgegevens |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|   | Routingstrategie | Directe |   | Gemachtigde | <xref:System.Windows.Controls.ToolTipEventHandler>|</xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  id: ToolTipOpeningEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipOpeningEvent
  nameWithType: FrameworkContentElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipOpening&quot;> </xref> [gerouteerd gebeurtenissen overzicht](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Gebeurtenis-id-objecten worden gemaakt wanneer gerouteerde gebeurtenissen worden geregistreerd (Zie <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) en kan vervolgens worden gebruikt voor de klasse-handlers toevoegen (Zie <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objecten bevatten een unieke naam, eigenaarstype handler-type, routingstrategie en een methode hulpprogramma voor eigenaars voor de gebeurtenis toe te voegen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipProperty
  id: ToolTipProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipProperty
  nameWithType: FrameworkContentElement.ToolTipProperty
  fullName: System.Windows.FrameworkContentElement.ToolTipProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref:System.Windows.FrameworkContentElement.ToolTip*>afhankelijkheidseigenschap.</xref:System.Windows.FrameworkContentElement.ToolTip*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ToolTipProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: FrameworkContentElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkContentElement.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Zoekt naar een resource met de opgegeven sleutel is en retourneert die bron als gevonden."
  remarks: "Als de bron niet in het element aanroepen gevonden is, de structuur van de bovenliggende doorzocht op dezelfde manier die de boomstructuur met behulp van de logische structuur doorzocht als een verwijzing dynamische bron zijn aangevraagd door de sleutel tijdens runtime.       U zou de retourwaarde naar het type van de eigenschap die u hebt geprobeerd om in te stellen met de resourcewaarde van de geretourneerde doorgaans onmiddellijk geconverteerd.       De <xref:System.Windows.FrameworkContentElement.FindResource%2A>methode heeft een soortgelijk gedrag vertonen, behalve dat er een uitzondering opgetreden in het geval van een resource niet vinden met de opgegeven sleutel genereert.</xref:System.Windows.FrameworkContentElement.FindResource%2A>"
  example:
  - "The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.  \n  \n [!code-cs[ContentElementsSmorgasbord#TryFindResource](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#tryfindresource)]\n [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#tryfindresource)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "Sleutel-id van de resource die u wilt zoeken."
    return:
      type: System.Object
      description: "De resource gevonden. Als geen resource gevonden, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> wordt geretourneerd."
  overload: System.Windows.FrameworkContentElement.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Unloaded
  id: Unloaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Unloaded
  nameWithType: FrameworkContentElement.Unloaded
  fullName: System.Windows.FrameworkContentElement.Unloaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Deze gebeurtenis treedt op wanneer het element wordt verwijderd uit de structuur van een element van geladen elementen."
  remarks: "Directe gerouteerde gebeurtenissen een route niet uitvoert, zijn ze alleen verwerkt binnen hetzelfde element waarop ze worden gegenereerd. Directe gerouteerde gebeurtenissen bieden ondersteuning voor andere gedrag gerouteerde gebeurtenis: ondersteuning voor een verzameling toegankelijk handlers en ze kunnen worden gebruikt als een <xref:System.Windows.EventTrigger>in een style.</xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_Unloaded&quot;></a>## Gerouteerd gebeurtenisgegevens |||   |-|-|   | Id-veld | <xref:System.Windows.FrameworkContentElement.UnloadedEvent>|   | Routingstrategie | Directe |   | Gemachtigde | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkContentElement.UnloadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Unloaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UnloadedEvent
  id: UnloadedEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UnloadedEvent
  nameWithType: FrameworkContentElement.UnloadedEvent
  fullName: System.Windows.FrameworkContentElement.UnloadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identificeert de <xref href=&quot;System.Windows.FrameworkContentElement.Unloaded&quot;> </xref> [gerouteerd gebeurtenissen overzicht](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Gebeurtenis-id-objecten worden gemaakt wanneer gerouteerde gebeurtenissen worden geregistreerd (Zie <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) en kan vervolgens worden gebruikt voor de klasse-handlers toevoegen (Zie <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> ID-objecten bevatten een unieke naam, eigenaarstype handler-type, routingstrategie en een methode hulpprogramma voor eigenaars voor de gebeurtenis toe te voegen."
  syntax:
    content: public static readonly System.Windows.RoutedEvent UnloadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UnregisterName(System.String)
  id: UnregisterName(System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UnregisterName(String)
  nameWithType: FrameworkContentElement.UnregisterName(String)
  fullName: System.Windows.FrameworkContentElement.UnregisterName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Vereenvoudigt de toegang tot de <xref:System.Windows.NameScope>deactivering registratie methode.</xref:System.Windows.NameScope>"
  remarks: "Alleen moet u de namen van de registratie ongedaan maken als u van plan bent een ander element met dezelfde naam opnieuw te registreren."
  syntax:
    content: public void UnregisterName (string name);
    parameters:
    - id: name
      type: System.String
      description: "Naam van de combinatie van naam-object verwijderen uit het huidige bereik."
  overload: System.Windows.FrameworkContentElement.UnregisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle
  id: UpdateDefaultStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UpdateDefaultStyle()
  nameWithType: FrameworkContentElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkContentElement.UpdateDefaultStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "De standaardstijl die wordt opnieuw toegepast op de huidige <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref>."
  syntax:
    content: public void UpdateDefaultStyle ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.UpdateDefaultStyle*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.ContentElement
  isExternal: false
  name: System.Windows.ContentElement
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Windows.FrameworkContentElement.#ctor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FrameworkContentElement()
  nameWithType: FrameworkContentElement.FrameworkContentElement()
  fullName: System.Windows.FrameworkContentElement.FrameworkContentElement()
- uid: System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: AddLogicalChild(Object)
  nameWithType: FrameworkContentElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.AddLogicalChild(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkContentElement.BeginInit
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginInit()
  nameWithType: FrameworkContentElement.BeginInit()
  fullName: System.Windows.FrameworkContentElement.BeginInit()
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard)
- uid: System.Windows.Media.Animation.Storyboard
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Storyboard
  nameWithType: Storyboard
  fullName: System.Windows.Media.Animation.Storyboard
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkContentElement.BindingGroup
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
  fullName: System.Windows.FrameworkContentElement.BindingGroup
- uid: System.Windows.Data.BindingGroup
  parent: System.Windows.Data
  isExternal: false
  name: BindingGroup
  nameWithType: BindingGroup
  fullName: System.Windows.Data.BindingGroup
- uid: System.Windows.FrameworkContentElement.BindingGroupProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroupProperty
  nameWithType: FrameworkContentElement.BindingGroupProperty
  fullName: System.Windows.FrameworkContentElement.BindingGroupProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkContentElement.BringIntoView
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BringIntoView()
  nameWithType: FrameworkContentElement.BringIntoView()
  fullName: System.Windows.FrameworkContentElement.BringIntoView()
- uid: System.Windows.FrameworkContentElement.ContextMenu
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
  fullName: System.Windows.FrameworkContentElement.ContextMenu
- uid: System.Windows.Controls.ContextMenu
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenu
  nameWithType: ContextMenu
  fullName: System.Windows.Controls.ContextMenu
- uid: System.Windows.FrameworkContentElement.ContextMenuClosing
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuClosing
  nameWithType: FrameworkContentElement.ContextMenuClosing
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosing
- uid: System.Windows.Controls.ContextMenuEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventHandler
  nameWithType: ContextMenuEventHandler
  fullName: System.Windows.Controls.ContextMenuEventHandler
- uid: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuClosingEvent
  nameWithType: FrameworkContentElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.FrameworkContentElement.ContextMenuOpening
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuOpening
  nameWithType: FrameworkContentElement.ContextMenuOpening
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpening
- uid: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkContentElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
- uid: System.Windows.FrameworkContentElement.ContextMenuProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuProperty
  nameWithType: FrameworkContentElement.ContextMenuProperty
  fullName: System.Windows.FrameworkContentElement.ContextMenuProperty
- uid: System.Windows.FrameworkContentElement.Cursor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
  fullName: System.Windows.FrameworkContentElement.Cursor
- uid: System.Windows.Input.Cursor
  parent: System.Windows.Input
  isExternal: false
  name: Cursor
  nameWithType: Cursor
  fullName: System.Windows.Input.Cursor
- uid: System.Windows.FrameworkContentElement.CursorProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: CursorProperty
  nameWithType: FrameworkContentElement.CursorProperty
  fullName: System.Windows.FrameworkContentElement.CursorProperty
- uid: System.Windows.FrameworkContentElement.DataContext
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
  fullName: System.Windows.FrameworkContentElement.DataContext
- uid: System.Windows.FrameworkContentElement.DataContextChanged
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContextChanged
  nameWithType: FrameworkContentElement.DataContextChanged
  fullName: System.Windows.FrameworkContentElement.DataContextChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.FrameworkContentElement.DataContextProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContextProperty
  nameWithType: FrameworkContentElement.DataContextProperty
  fullName: System.Windows.FrameworkContentElement.DataContextProperty
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKey
- uid: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkContentElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
- uid: System.Windows.FrameworkContentElement.EndInit
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: EndInit()
  nameWithType: FrameworkContentElement.EndInit()
  fullName: System.Windows.FrameworkContentElement.EndInit()
- uid: System.Windows.FrameworkContentElement.FindName(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindName(String)
  nameWithType: FrameworkContentElement.FindName(String)
  fullName: System.Windows.FrameworkContentElement.FindName(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.FrameworkContentElement.FindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindResource(Object)
  nameWithType: FrameworkContentElement.FindResource(Object)
  fullName: System.Windows.FrameworkContentElement.FindResource(Object)
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyle
- uid: System.Windows.Style
  parent: System.Windows
  isExternal: false
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
- uid: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyleProperty
  nameWithType: FrameworkContentElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
- uid: System.Windows.FrameworkContentElement.ForceCursor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
  fullName: System.Windows.FrameworkContentElement.ForceCursor
- uid: System.Windows.FrameworkContentElement.ForceCursorProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursorProperty
  nameWithType: FrameworkContentElement.ForceCursorProperty
  fullName: System.Windows.FrameworkContentElement.ForceCursorProperty
- uid: System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkContentElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkContentElement.GetBindingExpression(DependencyProperty)
- uid: System.Windows.Data.BindingExpression
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpression
  nameWithType: BindingExpression
  fullName: System.Windows.Data.BindingExpression
- uid: System.Windows.FrameworkContentElement.GetUIParentCore
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: FrameworkContentElement.GetUIParentCore()
  fullName: System.Windows.FrameworkContentElement.GetUIParentCore()
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.FrameworkContentElement.Initialized
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Initialized
  nameWithType: FrameworkContentElement.Initialized
  fullName: System.Windows.FrameworkContentElement.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.FrameworkContentElement.InputScope
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
  fullName: System.Windows.FrameworkContentElement.InputScope
- uid: System.Windows.Input.InputScope
  parent: System.Windows.Input
  isExternal: false
  name: InputScope
  nameWithType: InputScope
  fullName: System.Windows.Input.InputScope
- uid: System.Windows.FrameworkContentElement.InputScopeProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScopeProperty
  nameWithType: FrameworkContentElement.InputScopeProperty
  fullName: System.Windows.FrameworkContentElement.InputScopeProperty
- uid: System.Windows.FrameworkContentElement.IsInitialized
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
  fullName: System.Windows.FrameworkContentElement.IsInitialized
- uid: System.Windows.FrameworkContentElement.IsLoaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
  fullName: System.Windows.FrameworkContentElement.IsLoaded
- uid: System.Windows.FrameworkContentElement.Language
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Language
  nameWithType: FrameworkContentElement.Language
  fullName: System.Windows.FrameworkContentElement.Language
- uid: System.Windows.Markup.XmlLanguage
  parent: System.Windows.Markup
  isExternal: false
  name: XmlLanguage
  nameWithType: XmlLanguage
  fullName: System.Windows.Markup.XmlLanguage
- uid: System.Windows.FrameworkContentElement.LanguageProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LanguageProperty
  nameWithType: FrameworkContentElement.LanguageProperty
  fullName: System.Windows.FrameworkContentElement.LanguageProperty
- uid: System.Windows.FrameworkContentElement.Loaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Loaded
  nameWithType: FrameworkContentElement.Loaded
  fullName: System.Windows.FrameworkContentElement.Loaded
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.FrameworkContentElement.LoadedEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LoadedEvent
  nameWithType: FrameworkContentElement.LoadedEvent
  fullName: System.Windows.FrameworkContentElement.LoadedEvent
- uid: System.Windows.FrameworkContentElement.LogicalChildren
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
  fullName: System.Windows.FrameworkContentElement.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkContentElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.FrameworkContentElement.Name
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Name
  nameWithType: FrameworkContentElement.Name
  fullName: System.Windows.FrameworkContentElement.Name
- uid: System.Windows.FrameworkContentElement.NameProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: NameProperty
  nameWithType: FrameworkContentElement.NameProperty
  fullName: System.Windows.FrameworkContentElement.NameProperty
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
- uid: System.Windows.Controls.ContextMenuEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventArgs
  nameWithType: ContextMenuEventArgs
  fullName: System.Windows.Controls.ContextMenuEventArgs
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
- uid: System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkContentElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkContentElement.OnInitialized(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkContentElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkContentElement.OnStyleChanged(Style,Style)
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
- uid: System.Windows.Controls.ToolTipEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventArgs
  nameWithType: ToolTipEventArgs
  fullName: System.Windows.Controls.ToolTipEventArgs
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkContentElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
- uid: System.Windows.FrameworkContentElement.Parent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkContentElement.Parent
  fullName: System.Windows.FrameworkContentElement.Parent
- uid: System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkContentElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RegisterName(String,Object)
  nameWithType: FrameworkContentElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkContentElement.RegisterName(String,Object)
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkContentElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.RemoveLogicalChild(Object)
- uid: System.Windows.FrameworkContentElement.Resources
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkContentElement.Resources
  fullName: System.Windows.FrameworkContentElement.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,String)
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
- uid: System.Windows.Data.BindingExpressionBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpressionBase
  nameWithType: BindingExpressionBase
  fullName: System.Windows.Data.BindingExpressionBase
- uid: System.Windows.Data.BindingBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingBase
  nameWithType: BindingBase
  fullName: System.Windows.Data.BindingBase
- uid: System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeResources()
  nameWithType: FrameworkContentElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeResources()
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeStyle()
  nameWithType: FrameworkContentElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeStyle()
- uid: System.Windows.FrameworkContentElement.SourceUpdated
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SourceUpdated
  nameWithType: FrameworkContentElement.SourceUpdated
  fullName: System.Windows.FrameworkContentElement.SourceUpdated
- uid: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<DataTransferEventArgs>
  nameWithType: EventHandler<DataTransferEventArgs>
  fullName: System.EventHandler<System.Windows.Data.DataTransferEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Data.DataTransferEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Data.DataTransferEventArgs
    name: DataTransferEventArgs
    nameWithType: DataTransferEventArgs
    fullName: DataTransferEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.FrameworkContentElement.Style
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Style
  nameWithType: FrameworkContentElement.Style
  fullName: System.Windows.FrameworkContentElement.Style
- uid: System.Windows.FrameworkContentElement.StyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: StyleProperty
  nameWithType: FrameworkContentElement.StyleProperty
  fullName: System.Windows.FrameworkContentElement.StyleProperty
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Windows.FrameworkContentElement.Tag
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkContentElement.Tag
  fullName: System.Windows.FrameworkContentElement.Tag
- uid: System.Windows.FrameworkContentElement.TagProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TagProperty
  nameWithType: FrameworkContentElement.TagProperty
  fullName: System.Windows.FrameworkContentElement.TagProperty
- uid: System.Windows.FrameworkContentElement.TargetUpdated
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TargetUpdated
  nameWithType: FrameworkContentElement.TargetUpdated
  fullName: System.Windows.FrameworkContentElement.TargetUpdated
- uid: System.Windows.FrameworkContentElement.TemplatedParent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
  fullName: System.Windows.FrameworkContentElement.TemplatedParent
- uid: System.Windows.FrameworkContentElement.ToolTip
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
  fullName: System.Windows.FrameworkContentElement.ToolTip
- uid: System.Windows.FrameworkContentElement.ToolTipClosing
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipClosing
  nameWithType: FrameworkContentElement.ToolTipClosing
  fullName: System.Windows.FrameworkContentElement.ToolTipClosing
- uid: System.Windows.Controls.ToolTipEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventHandler
  nameWithType: ToolTipEventHandler
  fullName: System.Windows.Controls.ToolTipEventHandler
- uid: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipClosingEvent
  nameWithType: FrameworkContentElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipClosingEvent
- uid: System.Windows.FrameworkContentElement.ToolTipOpening
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipOpening
  nameWithType: FrameworkContentElement.ToolTipOpening
  fullName: System.Windows.FrameworkContentElement.ToolTipOpening
- uid: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipOpeningEvent
  nameWithType: FrameworkContentElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
- uid: System.Windows.FrameworkContentElement.ToolTipProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipProperty
  nameWithType: FrameworkContentElement.ToolTipProperty
  fullName: System.Windows.FrameworkContentElement.ToolTipProperty
- uid: System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: FrameworkContentElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkContentElement.TryFindResource(Object)
- uid: System.Windows.FrameworkContentElement.Unloaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Unloaded
  nameWithType: FrameworkContentElement.Unloaded
  fullName: System.Windows.FrameworkContentElement.Unloaded
- uid: System.Windows.FrameworkContentElement.UnloadedEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnloadedEvent
  nameWithType: FrameworkContentElement.UnloadedEvent
  fullName: System.Windows.FrameworkContentElement.UnloadedEvent
- uid: System.Windows.FrameworkContentElement.UnregisterName(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnregisterName(String)
  nameWithType: FrameworkContentElement.UnregisterName(String)
  fullName: System.Windows.FrameworkContentElement.UnregisterName(String)
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UpdateDefaultStyle()
  nameWithType: FrameworkContentElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkContentElement.UpdateDefaultStyle()
- uid: System.Windows.FrameworkContentElement.#ctor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FrameworkContentElement
  nameWithType: FrameworkContentElement.FrameworkContentElement
- uid: System.Windows.FrameworkContentElement.AddLogicalChild*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: AddLogicalChild
  nameWithType: FrameworkContentElement.AddLogicalChild
- uid: System.Windows.FrameworkContentElement.BeginInit*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginInit
  nameWithType: FrameworkContentElement.BeginInit
- uid: System.Windows.FrameworkContentElement.BeginStoryboard*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard
  nameWithType: FrameworkContentElement.BeginStoryboard
- uid: System.Windows.FrameworkContentElement.BindingGroup*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
- uid: System.Windows.FrameworkContentElement.BringIntoView*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BringIntoView
  nameWithType: FrameworkContentElement.BringIntoView
- uid: System.Windows.FrameworkContentElement.ContextMenu*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
- uid: System.Windows.FrameworkContentElement.Cursor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
- uid: System.Windows.FrameworkContentElement.DataContext*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
- uid: System.Windows.FrameworkContentElement.EndInit*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: EndInit
  nameWithType: FrameworkContentElement.EndInit
- uid: System.Windows.FrameworkContentElement.FindName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindName
  nameWithType: FrameworkContentElement.FindName
- uid: System.Windows.FrameworkContentElement.FindResource*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindResource
  nameWithType: FrameworkContentElement.FindResource
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
- uid: System.Windows.FrameworkContentElement.ForceCursor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
- uid: System.Windows.FrameworkContentElement.GetBindingExpression*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetBindingExpression
  nameWithType: FrameworkContentElement.GetBindingExpression
- uid: System.Windows.FrameworkContentElement.GetUIParentCore*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: FrameworkContentElement.GetUIParentCore
- uid: System.Windows.FrameworkContentElement.InputScope*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
- uid: System.Windows.FrameworkContentElement.IsInitialized*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
- uid: System.Windows.FrameworkContentElement.IsLoaded*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
- uid: System.Windows.FrameworkContentElement.Language*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Language
  nameWithType: FrameworkContentElement.Language
- uid: System.Windows.FrameworkContentElement.LogicalChildren*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
- uid: System.Windows.FrameworkContentElement.MoveFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: MoveFocus
  nameWithType: FrameworkContentElement.MoveFocus
- uid: System.Windows.FrameworkContentElement.Name*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Name
  nameWithType: FrameworkContentElement.Name
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuClosing
  nameWithType: FrameworkContentElement.OnContextMenuClosing
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuOpening
  nameWithType: FrameworkContentElement.OnContextMenuOpening
- uid: System.Windows.FrameworkContentElement.OnGotFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnGotFocus
  nameWithType: FrameworkContentElement.OnGotFocus
- uid: System.Windows.FrameworkContentElement.OnInitialized*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnInitialized
  nameWithType: FrameworkContentElement.OnInitialized
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnPropertyChanged
  nameWithType: FrameworkContentElement.OnPropertyChanged
- uid: System.Windows.FrameworkContentElement.OnStyleChanged*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnStyleChanged
  nameWithType: FrameworkContentElement.OnStyleChanged
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipClosing
  nameWithType: FrameworkContentElement.OnToolTipClosing
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipOpening
  nameWithType: FrameworkContentElement.OnToolTipOpening
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkContentElement.Parent*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkContentElement.Parent
- uid: System.Windows.FrameworkContentElement.PredictFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: PredictFocus
  nameWithType: FrameworkContentElement.PredictFocus
- uid: System.Windows.FrameworkContentElement.RegisterName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RegisterName
  nameWithType: FrameworkContentElement.RegisterName
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RemoveLogicalChild
  nameWithType: FrameworkContentElement.RemoveLogicalChild
- uid: System.Windows.FrameworkContentElement.Resources*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkContentElement.Resources
- uid: System.Windows.FrameworkContentElement.SetBinding*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding
  nameWithType: FrameworkContentElement.SetBinding
- uid: System.Windows.FrameworkContentElement.SetResourceReference*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetResourceReference
  nameWithType: FrameworkContentElement.SetResourceReference
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeResources
  nameWithType: FrameworkContentElement.ShouldSerializeResources
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeStyle
  nameWithType: FrameworkContentElement.ShouldSerializeStyle
- uid: System.Windows.FrameworkContentElement.Style*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Style
  nameWithType: FrameworkContentElement.Style
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.FrameworkContentElement.Tag*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkContentElement.Tag
- uid: System.Windows.FrameworkContentElement.TemplatedParent*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
- uid: System.Windows.FrameworkContentElement.ToolTip*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
- uid: System.Windows.FrameworkContentElement.TryFindResource*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TryFindResource
  nameWithType: FrameworkContentElement.TryFindResource
- uid: System.Windows.FrameworkContentElement.UnregisterName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnregisterName
  nameWithType: FrameworkContentElement.UnregisterName
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UpdateDefaultStyle
  nameWithType: FrameworkContentElement.UpdateDefaultStyle
