### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.NetworkStream
  id: NetworkStream
  children:
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  - System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.CanRead
  - System.Net.Sockets.NetworkStream.CanSeek
  - System.Net.Sockets.NetworkStream.CanTimeout
  - System.Net.Sockets.NetworkStream.CanWrite
  - System.Net.Sockets.NetworkStream.Close(System.Int32)
  - System.Net.Sockets.NetworkStream.DataAvailable
  - System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  - System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.Finalize
  - System.Net.Sockets.NetworkStream.Flush
  - System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  - System.Net.Sockets.NetworkStream.Length
  - System.Net.Sockets.NetworkStream.Position
  - System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Readable
  - System.Net.Sockets.NetworkStream.ReadTimeout
  - System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  - System.Net.Sockets.NetworkStream.Socket
  - System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Writeable
  - System.Net.Sockets.NetworkStream.WriteTimeout
  langs:
  - csharp
  name: NetworkStream
  nameWithType: NetworkStream
  fullName: System.Net.Sockets.NetworkStream
  type: Class
  summary: "Biedt de onderliggende stroom van gegevens voor toegang tot het netwerk."
  remarks: "De NetworkStream klasse biedt methoden voor het verzenden en ontvangen van gegevens via <xref:System.Net.Sockets.SocketType>sockets in de modus blokkerende.</xref:System.Net.Sockets.SocketType> Voor meer informatie over het blokkeren van nonblocking <xref:System.Net.Sockets.Socket>s, Zie [met behulp van een asynchrone Socket voor Client](~/add/includes/ajax-current-ext-md.md).</xref:System.Net.Sockets.Socket> U kunt de klasse NetworkStream gebruiken voor beide synchrone en asynchrone gegevensoverdracht. Zie voor meer informatie over synchrone en asynchrone communicatie [Sockets](~/add/includes/ajax-current-ext-md.md).       Als u wilt een NetworkStream maken, moet u een verbonden <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> opgeven U kunt ook opgeven welke <xref:System.IO.FileAccess>machtigingen de NetworkStream heeft via de opgegeven <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.IO.FileAccess> Standaard sluit sluit de NetworkStream niet de opgegeven <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> Als u wilt dat de NetworkStream toestemming om te sluiten van de opgegeven <xref:System.Net.Sockets.Socket>, moet u `true` voor de waarde van de `ownsSocket` parameter.</xref:System.Net.Sockets.Socket>       Gebruik de <xref:System.Net.Sockets.NetworkStream.Write%2A>en <xref:System.Net.Sockets.NetworkStream.Read%2A>methoden voor het eenvoudig single thread synchrone blokkerende i/o.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream.Write%2A> Als u wilt laten verwerken van uw i/o met afzonderlijke threads, overweeg dan de <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>en <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>methoden, of de <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>en <xref:System.Net.Sockets.NetworkStream.EndRead%2A>methoden voor communicatie.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       De NetworkStream biedt geen ondersteuning voor willekeurige toegang tot de gegevensstroom van het netwerk. De waarde van de <xref:System.Net.Sockets.NetworkStream.CanSeek%2A>eigenschap waarmee wordt aangegeven of de stroom ondersteunt zoekbewerkingen, is altijd `false`; lezen van de <xref:System.Net.Sockets.NetworkStream.Position%2A>eigenschap lezen van de <xref:System.Net.Sockets.NetworkStream.Length%2A>eigenschap, of het aanroepen van de <xref:System.Net.Sockets.NetworkStream.Seek%2A>methode genereert een <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Net.Sockets.NetworkStream.Seek%2A> </xref:System.Net.Sockets.NetworkStream.Length%2A> </xref:System.Net.Sockets.NetworkStream.Position%2A> </xref:System.Net.Sockets.NetworkStream.CanSeek%2A>       Lezen en schrijven bewerkingen kunnen tegelijkertijd worden uitgevoerd op een exemplaar van de klasse NetworkStream zonder de noodzaak voor synchronisatie. Zolang er een unieke thread voor de schrijfbewerkingen en één unieke thread voor de leesbewerkingen is, zal er geen cross-storing tussen lezen en schrijven threads en er geen synchronisatie is vereist."
  example:
  - "The following code example demonstrates how to create a NetworkStream from a connected <xref:System.Net.Sockets.SocketType><xref:System.Net.Sockets.Socket> and perform basic synchronous blocking I/O.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/t-system.net.sockets.net_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/t-system.net.sockets.net_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/t-system.net.sockets.net_1.cs)]"
  syntax:
    content: 'public class NetworkStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  id: '#ctor(System.Net.Sockets.Socket)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Maakt een nieuw exemplaar van de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klasse voor de opgegeven <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "Het <xref:System.Net.Sockets.NetworkStream>is gemaakt met lees-/ schrijftoegang tot de opgegeven <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Het <xref:System.Net.Sockets.NetworkStream>is geen eigenaar van de onderliggende <xref:System.Net.Sockets.Socket>dus de <xref:System.Net.Sockets.NetworkStream.Close%2A>methode sluit de <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> niet</xref:System.Net.Sockets.NetworkStream.Close%2A> aanroepen</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example illustrates how to create a <xref:System.Net.Sockets.NetworkStream> with a <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/m-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/m-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/m-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "De <xref:System.Net.Sockets.Socket>die de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> wordt gebruikt om te verzenden en ontvangen van gegevens.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De <code> socket </code> parameter niet is verbonden.       - of - de <xref:System.Net.Sockets.Socket.SocketType*>eigenschap van de <code> socket </code> parameter is niet &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - of - de <code> socket </code> parameter heeft een nonblocking status."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klasse voor het opgegeven <xref:System.Net.Sockets.Socket>met de opgegeven <xref:System.Net.Sockets.Socket>eigendom.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "Het <xref:System.Net.Sockets.NetworkStream>is gemaakt met lees-/ schrijftoegang tot de opgegeven <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Als de waarde van `ownsSocket` parameter `true`, wordt de <xref:System.Net.Sockets.NetworkStream>wordt eigenaar van de onderliggende <xref:System.Net.Sockets.Socket>, en het aanroepen van de <xref:System.Net.Sockets.NetworkStream.Close%2A>methode sluit ook de onderliggende <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with ownership of the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/59c93a1c-9c9b-46b2-a872-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/59c93a1c-9c9b-46b2-a872-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/59c93a1c-9c9b-46b2-a872-_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "De <xref:System.Net.Sockets.Socket>die de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> wordt gebruikt om te verzenden en ontvangen van gegevens.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Ingesteld op <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> aangeeft dat de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> eigenaar van de <xref:System.Net.Sockets.Socket>; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De <code> socket </code> parameter niet is verbonden.       - of - de waarde van de <xref:System.Net.Sockets.Socket.SocketType*>eigenschap van de <code> socket </code> parameter is niet &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - of - de <code> socket </code> parameter heeft een nonblocking status."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Maakt een nieuw exemplaar van de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klasse voor het opgegeven <xref:System.Net.Sockets.Socket>met de opgegeven toegangsrechten.</xref:System.Net.Sockets.Socket>"
  remarks: "Het <xref:System.Net.Sockets.NetworkStream>is gemaakt met de opgegeven toegang tot de opgegeven <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Met deze constructor, het <xref:System.Net.Sockets.NetworkStream>is geen eigenaar van de onderliggende <xref:System.Net.Sockets.Socket>dus het aanroepen van de <xref:System.Net.Sockets.NetworkStream.Close%2A>methode wordt niet de onderliggende <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> gesloten</xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       De `access` parameter stelt de <xref:System.Net.Sockets.NetworkStream.CanRead%2A> <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Eigenschappen van de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> en</xref:System.Net.Sockets.NetworkStream.CanRead%2A> Als u opgeeft <xref:System.IO.FileAccess>, wordt de <xref:System.Net.Sockets.NetworkStream>kunt aanroepen naar de <xref:System.Net.Sockets.NetworkStream.Write%2A>methode.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Als u opgeeft <xref:System.IO.FileAccess>, wordt de <xref:System.Net.Sockets.NetworkStream>kunt aanroepen naar de <xref:System.Net.Sockets.NetworkStream.Read%2A>methode.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Als u opgeeft <xref:System.IO.FileAccess>, beide methodeaanroepen zijn toegestaan.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/586c6962-cd9c-4b70-aa3e-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/586c6962-cd9c-4b70-aa3e-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/586c6962-cd9c-4b70-aa3e-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "De <xref:System.Net.Sockets.Socket>die de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> wordt gebruikt om te verzenden en ontvangen van gegevens.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "Een bitsgewijze combinatie van de <xref href=&quot;System.IO.FileAccess&quot;> </xref> waarde die welk type toegang krijgen opgeeft tot de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> via de opgegeven <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De <code> socket </code> parameter niet is verbonden.       - of - de <xref:System.Net.Sockets.Socket.SocketType*>eigenschap van de <code> socket </code> parameter is niet &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - of - de <code> socket </code> parameter heeft een nonblocking status."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Maakt een nieuw exemplaar van de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klasse voor het opgegeven <xref:System.Net.Sockets.Socket>met de opgegeven toegangsrechten en de opgegeven <xref:System.Net.Sockets.Socket>eigendom.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "Het <xref:System.Net.Sockets.NetworkStream>is gemaakt met lees-/ schrijftoegang tot de opgegeven <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Als de waarde van de `ownsSocket` parameter `true`, wordt de <xref:System.Net.Sockets.NetworkStream>wordt eigenaar van de onderliggende <xref:System.Net.Sockets.Socket>, en het aanroepen van de <xref:System.Net.Sockets.NetworkStream.Close%2A>methode sluit ook de onderliggende <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       De `access` parameter stelt de <xref:System.Net.Sockets.NetworkStream.CanRead%2A> <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Eigenschappen van de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> en</xref:System.Net.Sockets.NetworkStream.CanRead%2A> Als u opgeeft <xref:System.IO.FileAccess>, wordt de <xref:System.Net.Sockets.NetworkStream>kunt aanroepen naar de <xref:System.Net.Sockets.NetworkStream.Write%2A>methode.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Als u opgeeft <xref:System.IO.FileAccess>, wordt de <xref:System.Net.Sockets.NetworkStream>kunt aanroepen naar de <xref:System.Net.Sockets.NetworkStream.Read%2A>methode.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Als u opgeeft <xref:System.IO.FileAccess>, beide methodeaanroepen zijn toegestaan.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>. Ownership of the <xref:System.Net.Sockets.Socket> is given to this <xref:System.Net.Sockets.NetworkStream> by specifying `true` for the `ownsSocket` parameter.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/db34d484-28c0-47ef-b5ca-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/db34d484-28c0-47ef-b5ca-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/db34d484-28c0-47ef-b5ca-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "De <xref:System.Net.Sockets.Socket>die de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> wordt gebruikt om te verzenden en ontvangen van gegevens.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "Een bitsgewijze combinatie van de <xref href=&quot;System.IO.FileAccess&quot;> </xref> waarden die aangeeft welk type toegang krijgen tot de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> boven de opgegeven <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Ingesteld op <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> aangeeft dat de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> eigenaar van de <xref:System.Net.Sockets.Socket>; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De <code> socket </code> parameter niet is verbonden.       - of - de <xref:System.Net.Sockets.Socket.SocketType*>eigenschap van de <code> socket </code> parameter is niet &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - of - de <code> socket </code> parameter heeft een nonblocking status."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Een asynchrone leesbewerking vanuit begint de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "De methode BeginRead begint het asynchroon lezen van gegevens van de binnenkomende netwerkbuffers. Aanroepen van de methode BeginRead biedt u de mogelijkheid voor het ontvangen van gegevens binnen een afzonderlijke uitvoeringsthread.       U moet een retouraanroepmethode maken die worden geïmplementeerd de <xref:System.AsyncCallback>delegeren en om de naam aan de methode BeginRead doorgeven.</xref:System.AsyncCallback> Bij zeer minimale uw `state` parameter moet de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> bevatten Omdat u de ontvangen gegevens binnen uw retouraanroepmethode verkrijgen wilt, moet u een kleine klasse of de structuur voor het opslaan van een leesbuffer en andere nuttige informatie maken. De structuur of klasse-exemplaar doorgeven aan de methode BeginRead via de `state` parameter.       De callback-methode moet aanroepen de <xref:System.Net.Sockets.NetworkStream.EndRead%2A>methode.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> Wanneer uw toepassing BeginRead aanroept, het systeem moet wachten totdat het ontvangen van gegevens of een fout optreedt en vervolgens het systeem een afzonderlijke thread gebruiken om uit te voeren van de opgegeven retouraanroepmethode en blokken op <xref:System.Net.Sockets.NetworkStream.EndRead%2A>tot en met de opgegeven <xref:System.Net.Sockets.NetworkStream>leest de gegevens of er een uitzondering gegenereerd.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndRead%2A> Als u wilt dat de oorspronkelijke thread worden geblokkeerd nadat u de BeginRead-methode aanroept, gebruikt u de <xref:System.Threading.WaitHandle.WaitOne%2A>methode.</xref:System.Threading.WaitHandle.WaitOne%2A> Roep <xref:System.Threading.EventWaitHandle.Set%2A>in de retouraanroepmethode als u wilt dat de oorspronkelijke thread om door te gaan uitvoeren.</xref:System.Threading.EventWaitHandle.Set%2A> Zie voor meer informatie over het schrijven van de callback-methoden, [marshallen van een gemachtigde als een retouraanroepmethode](~/add/includes/ajax-current-ext-md.md).       De methode BeginRead leest zoveel gegevens als beschikbaar is, tot maximaal het aantal bytes dat is opgegeven door de `size` parameter.      > [!NOTE] > Als u een <xref:System.IO.IOException>controleert u de <xref:System.Exception.InnerException%2A>eigenschap om te bepalen of dit wordt veroorzaakt door een <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> krijgt</xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Als dit het geval is, gebruiken de <xref:System.Net.Sockets.SocketException.ErrorCode%2A>eigenschap verkrijgen van de specifieke foutcode en Raadpleeg de Windows Sockets versie 2 API fout code documentatie in MSDN voor een gedetailleerde beschrijving van de fout.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Lezen en schrijven bewerkingen kunnen tegelijkertijd worden uitgevoerd op een exemplaar van de <xref:System.Net.Sockets.NetworkStream>klasse zonder de noodzaak van synchronisatie.</xref:System.Net.Sockets.NetworkStream> Zolang er een unieke thread voor de schrijfbewerkingen en één unieke thread voor de leesbewerkingen is, zal er geen cross-storing tussen lezen en schrijven threads en er geen synchronisatie is vereist."
  example:
  - "The following code example uses BeginRead to read data asynchronously from the network stream. The `myReadCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginRead returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/visualbasic/b2716ae9-7520-4d87-8b97-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/csharp/b2716ae9-7520-4d87-8b97-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/cpp/b2716ae9-7520-4d87-8b97-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Een matrix van het type <xref:System.Byte>is de locatie in het geheugen voor het opslaan van gegevens lezen uit de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "De locatie in `buffer` om te beginnen met de gegevens op te slaan."
    - id: size
      type: System.Int32
      description: "Het aantal bytes lezen uit de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "De <xref:System.AsyncCallback>gemachtigde die wordt uitgevoerd wanneer BeginRead is voltooid.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Een object dat elke extra door de gebruiker gedefinieerde gegevens bevat."
    return:
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>die staat voor de asynchrone aanroep.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De <code> offset </code> parameter kleiner is dan 0.       - of - de <code> offset </code> parameter is groter dan de lengte van de <code> buffer </code> parameter.       - of - de <code> size </code> is kleiner dan 0.       - of - de <code> size </code> groter is dan de lengte van <code> buffer </code> minus de waarde van de <code> offset </code> parameter."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De onderliggende <xref:System.Net.Sockets.Socket>is gesloten.</xref:System.Net.Sockets.Socket>       - of - er is een fout opgetreden tijdens het lezen van het netwerk.       - of - er is een fout opgetreden bij het openen van de socket. Zie de sectie met opmerkingen voor meer informatie."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> is gesloten."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Een asynchrone schrijfbewerking naar een stream begint."
  remarks: "De methode BeginWrite is een asynchrone verzending gestart met de externe host. Aanroepen van de methode BeginWrite biedt u de mogelijkheid om gegevens in een afzonderlijke uitvoeringsthread te verzenden.       U moet een retouraanroepmethode maken die worden geïmplementeerd de <xref:System.AsyncCallback>delegeren en om de naam aan de methode BeginWrite doorgeven.</xref:System.AsyncCallback> Bij zeer minimale uw `state` parameter moet de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> bevatten Als de retouraanroep meer informatie nodig heeft, kunt u een kleine klasse of de structuur voor het opslaan van de <xref:System.Net.Sockets.NetworkStream>en de vereiste gegevens.</xref:System.Net.Sockets.NetworkStream> De structuur of klasse-exemplaar doorgeven aan de methode BeginWrite via de `state` parameter.       De retouraanroepmethode moet implementeren, de <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>methode.</xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Wanneer uw toepassing BeginWrite aanroept, het systeem een afzonderlijke thread gebruikt voor het uitvoeren van de opgegeven retouraanroepmethode en blokkeert op <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>totdat de <xref:System.Net.Sockets.NetworkStream>het gevraagde aantal bytes worden verzonden of er een uitzondering gegenereerd.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Als u wilt dat de oorspronkelijke thread worden geblokkeerd nadat u de BeginWrite-methode aanroept, gebruikt u de <xref:System.Threading.WaitHandle.WaitOne%2A>methode.</xref:System.Threading.WaitHandle.WaitOne%2A> Roep <xref:System.Threading.EventWaitHandle.Set%2A>in de retouraanroepmethode als u wilt dat de oorspronkelijke thread om door te gaan uitvoeren.</xref:System.Threading.EventWaitHandle.Set%2A> Zie voor meer informatie over het schrijven van de callback-methoden, [marshallen van een gemachtigde als een retouraanroepmethode](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Als u een <xref:System.IO.IOException>controleert u de <xref:System.Exception.InnerException%2A>eigenschap om te bepalen of dit wordt veroorzaakt door een <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> krijgt</xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Als dit het geval is, gebruiken de <xref:System.Net.Sockets.SocketException.ErrorCode%2A>eigenschap verkrijgen van de specifieke foutcode en Raadpleeg de Windows Sockets versie 2 API fout code documentatie in MSDN voor een gedetailleerde beschrijving van de fout.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Lezen en schrijven bewerkingen kunnen tegelijkertijd worden uitgevoerd op een exemplaar van de <xref:System.Net.Sockets.NetworkStream>klasse zonder de noodzaak van synchronisatie.</xref:System.Net.Sockets.NetworkStream> Zolang er een unieke thread voor de schrijfbewerkingen en één unieke thread voor de leesbewerkingen is, zal er geen cross-storing tussen lezen en schrijven threads en er geen synchronisatie is vereist."
  example:
  - "The following code example uses BeginWrite to write data asynchronously to a network stream. The `myWriteCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginWrite returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/visualbasic/d3b03755-0183-42fc-98c1-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/csharp/d3b03755-0183-42fc-98c1-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/cpp/d3b03755-0183-42fc-98c1-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Een matrix van het type <xref:System.Byte>waarin de gegevens te schrijven naar de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "De locatie in `buffer` om te beginnen met de gegevens te verzenden."
    - id: size
      type: System.Int32
      description: "Het aantal bytes schrijven naar de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "De <xref:System.AsyncCallback>gemachtigde die wordt uitgevoerd wanneer BeginWrite is voltooid.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Een object dat elke extra door de gebruiker gedefinieerde gegevens bevat."
    return:
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>die staat voor de asynchrone aanroep.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De <code> offset </code> parameter kleiner is dan 0.       - of - de <code> offset </code> parameter is groter dan de lengte van <code> buffer </code>.       - of - de <code> size </code> parameter kleiner is dan 0.       - of - de <code> size </code> parameter is groter dan de lengte van <code> buffer </code> minus de waarde van de <code> offset </code> parameter."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De onderliggende <xref:System.Net.Sockets.Socket>is gesloten.</xref:System.Net.Sockets.Socket>       - of - er is een fout opgetreden tijdens het schrijven naar het netwerk.       - of - er is een fout opgetreden bij het openen van de socket. Zie de sectie met opmerkingen voor meer informatie."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> is gesloten."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanRead
  id: CanRead
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hiermee wordt een waarde die aangeeft of de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> biedt ondersteuning voor lezen."
  remarks: "Als canread `true`, <xref:System.Net.Sockets.NetworkStream>kunt aanroepen naar de <xref:System.Net.Sockets.NetworkStream.Read%2A>methode.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Geef de juiste <xref:System.IO.FileAccess>waarde in de constructor voor het instellen van de leesbaarheid en writability van de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> opgesomd</xref:System.IO.FileAccess> De CanRead-eigenschap wordt ingesteld wanneer de <xref:System.Net.Sockets.NetworkStream>is geïnitialiseerd.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanRead to verify that the <xref:System.Net.Sockets.NetworkStream> is readable. It then performs a read operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_6_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_6_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_6_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als u gegevens kunnen worden gelezen uit de stroom; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. De standaardwaarde is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanSeek
  id: CanSeek
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Haalt een waarde die aangeeft of de stroom zoekbewerkingen ondersteunt. Deze eigenschap wordt momenteel niet ondersteund. Deze eigenschap retourneert altijd <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>in alle gevallen aan te geven dat <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> een specifieke locatie in de stroom kan niet zoeken."
  overload: System.Net.Sockets.NetworkStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hiermee wordt aangegeven of eigenschappen van de time-out kan worden gebruikt voor <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Deze eigenschap is ingesteld, omdat deze is overgenomen van <xref:System.IO.Stream>.</xref:System.IO.Stream>"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>in alle gevallen."
  overload: System.Net.Sockets.NetworkStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanWrite
  id: CanWrite
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hiermee wordt een waarde die aangeeft of de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> biedt ondersteuning voor schrijven."
  remarks: "Als CanWrite `true`, <xref:System.Net.Sockets.NetworkStream>kunt aanroepen naar de <xref:System.Net.Sockets.NetworkStream.Write%2A>methode.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Geef de juiste <xref:System.IO.FileAccess>waarde in de constructor voor het instellen van de leesbaarheid en writability van de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> opgesomd</xref:System.IO.FileAccess> De CanWrite-eigenschap wordt ingesteld wanneer de <xref:System.Net.Sockets.NetworkStream>is geïnitialiseerd.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanWrite to verify that the <xref:System.Net.Sockets.NetworkStream> is writable. It then performs a write operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/p-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/p-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/p-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als u gegevens kunnen worden geschreven naar de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. De standaardwaarde is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  id: Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hiermee sluit u de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> na een wachttijd van de opgegeven tijd zodat gegevens kunnen worden verzonden."
  remarks: "De methode Close maakt zowel beheerde als onbeheerde resources die zijn gekoppeld aan de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Als de <xref:System.Net.Sockets.NetworkStream>eigenaar is van de onderliggende <xref:System.Net.Sockets.Socket>, evenals is gesloten.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Als er een <xref:System.Net.Sockets.NetworkStream>is gekoppeld aan een <xref:System.Net.Sockets.TcpClient>de methode Close wordt gesloten, de TCP-verbinding, maar niet verwijderen van de bijbehorende <xref:System.Net.Sockets.TcpClient>.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream>"
  syntax:
    content: public void Close (int timeout);
    parameters:
    - id: timeout
      type: System.Int32
      description: "Een 32-bits geheel getal met teken waarmee het aantal milliseconden wachttijd voor het verzenden van de resterende gegevens voordat u afsluit."
  overload: System.Net.Sockets.NetworkStream.Close*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De <code> timeout </code> -parameter is kleiner dan -1."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  id: DataAvailable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hiermee wordt een waarde die aangeeft of de gegevens is beschikbaar op de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> om te lezen."
  remarks: "Gebruik de eigenschap DataAvailable om te bepalen of gegevens gereed om te lezen. Als DataAvailable `true`, een aanroep van <xref:System.Net.Sockets.NetworkStream.Read%2A>wordt onmiddellijk geretourneerd.</xref:System.Net.Sockets.NetworkStream.Read%2A> Als de externe host afgesloten of de verbinding wordt gesloten, kunnen DataAvailable een <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> genereren"
  example:
  - "The following code example reads from the <xref:System.Net.Sockets.NetworkStream> as long as data is available.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_2_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_2_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_2_1.cs)]"
  syntax:
    content: public virtual bool DataAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de gegevens zijn beschikbaar op de stroom te lezen. anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.DataAvailable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> is gesloten."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De onderliggende <xref:System.Net.Sockets.Socket>is gesloten.</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Gebruik de &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; eigenschap verkrijgen van de specifieke foutcode en Raadpleeg de Windows Sockets versie 2 API fout code documentatie in MSDN voor een gedetailleerde beschrijving van de fout."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Heft de niet-beheerde bronnen worden gebruikt door de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> en eventueel de beheerde bronnen vrij."
  remarks: "Deze methode wordt aangeroepen door het publiek `Dispose` methode en de <xref:System.Object.Finalize%2A>methode.</xref:System.Object.Finalize%2A> `Dispose`Hiermee wordt de beveiligde `Dispose(Boolean)` methode met de `disposing` parameter ingesteld op `true`. <xref:System.Object.Finalize%2A>roept `Dispose` met `disposing` ingesteld op `false`.</xref:System.Object.Finalize%2A>       Wanneer de `disposing` parameter `true`, deze methode worden alle resources die beheerde objecten waarover vrijgegeven dat dit <xref:System.Net.Sockets.NetworkStream>verwijzingen.</xref:System.Net.Sockets.NetworkStream> Deze methode roept de `Dispose` methode van elk object waarnaar wordt verwezen."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>voor het vrijgeven van zowel beheerde als onbeheerde hulpbronnen; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> om alleen niet-beheerde bronnen vrij te geven."
  overload: System.Net.Sockets.NetworkStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Het einde van een asynchrone leesbewerking verwerkt."
  remarks: "De methode EndRead is voltooid voor de asynchrone leesbewerking gestart in de <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>methode.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>       Voordat u <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, moet u een retouraanroepmethode maken die worden geïmplementeerd de <xref:System.AsyncCallback>delegeren.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Deze retouraanroepmethode in een afzonderlijke thread wordt uitgevoerd en wordt aangeroepen door het systeem na <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>retourneert.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> De retouraanroepmethode moet akkoord gaan met de <xref:System.IAsyncResult>geretourneerd door de <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>methode als parameter.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult>       Binnen de callback-methode aanroepen de <xref:System.IAsyncResult.AsyncState%2A>eigenschap van de <xref:System.IAsyncResult>om op te halen van de statusobject doorgegeven aan de <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>methode.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A> Pak de ontvangende <xref:System.Net.Sockets.NetworkStream>van dit object staat.</xref:System.Net.Sockets.NetworkStream> Na het verkrijgen van de <xref:System.Net.Sockets.NetworkStream>, roept de methode EndRead om met succes voltooid de leesbewerking en retourneert het aantal bytes dat is gelezen.</xref:System.Net.Sockets.NetworkStream>       De EndRead methodeblokken totdat gegevens beschikbaar is. De methode EndRead leest zoveel gegevens als beschikbaar tot maximaal het aantal bytes dat is opgegeven de `size` parameter van de <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>methode.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Als de externe host wordt afgesloten de <xref:System.Net.Sockets.Socket>verbinding en alle beschikbare gegevens heeft ontvangen, de methode EndRead onmiddellijk is voltooid en geeft nul bytes.</xref:System.Net.Sockets.Socket>       Aanroepen voor het verkrijgen van de ontvangen gegevens, de <xref:System.IAsyncResult.AsyncState%2A>eigenschap van de <xref:System.IAsyncResult>, en uitpakken van de buffer die is opgenomen in het resulterende statusobject.</xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A>      > [!NOTE] > Als u een <xref:System.IO.IOException>controleert u de <xref:System.Exception.InnerException%2A>eigenschap om te bepalen of dit wordt veroorzaakt door een <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> krijgt</xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Als dit het geval is, gebruiken de <xref:System.Net.Sockets.SocketException.ErrorCode%2A>eigenschap verkrijgen van de specifieke foutcode en Raadpleeg de Windows Sockets versie 2 API fout code documentatie in MSDN voor een gedetailleerde beschrijving van de fout.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myReadCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> as the callback method. EndRead is implemented in `myReadCallback` to complete the asynchronous read call started by <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/visualbasic/m-system.net.sockets.net_2_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/csharp/m-system.net.sockets.net_2_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/cpp/m-system.net.sockets.net_2_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Een <xref:System.IAsyncResult>die staat voor een asynchrone aanroep.</xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "Het aantal bytes lezen uit de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.EndRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De onderliggende <xref:System.Net.Sockets.Socket>is gesloten.</xref:System.Net.Sockets.Socket>       - of - er is een fout opgetreden bij het openen van de socket. Zie de sectie met opmerkingen voor meer informatie."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> is gesloten."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Het einde van een asynchrone schrijfbewerking verwerkt."
  remarks: "EndWrite is voltooid voor de asynchrone verzendbewerking in <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> gestart       Voordat u <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, moet u een retouraanroepmethode maken die worden geïmplementeerd de <xref:System.AsyncCallback>delegeren.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Deze retouraanroepmethode in een afzonderlijke thread wordt uitgevoerd en wordt aangeroepen door het systeem na <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>retourneert.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> De retouraanroepmethode moet akkoord gaan met de <xref:System.IAsyncResult>geretourneerd door de <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>methode als parameter.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> </xref:System.IAsyncResult>       Binnen de callback-methode aanroepen de <xref:System.IAsyncResult.AsyncState%2A>eigenschap van de `IAsyncResult` parameter om op te halen van de <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IAsyncResult.AsyncState%2A> Na het verkrijgen van de <xref:System.Net.Sockets.NetworkStream>, u kunt de EndWrite methode aanroepen om met succes voltooid de verzendbewerking en retourneert het aantal bytes dat is verzonden.</xref:System.Net.Sockets.NetworkStream>       De blokken EndWrite methode tot het gevraagde aantal bytes worden verzonden.      > [!NOTE] > Als u een <xref:System.IO.IOException>controleert u de <xref:System.Exception.InnerException%2A>eigenschap om te bepalen of dit wordt veroorzaakt door een <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> krijgt</xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Als dit het geval is, gebruiken de <xref:System.Net.Sockets.SocketException.ErrorCode%2A>eigenschap verkrijgen van de specifieke foutcode en Raadpleeg de Windows Sockets versie 2 API fout code documentatie in MSDN voor een gedetailleerde beschrijving van de fout.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myWriteCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> as the callback method. EndWrite is implemented in `myWriteCallback` to complete the asynchronous write call started by <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_3_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_3_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_3_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "De <xref:System.IAsyncResult>die staat voor de asynchrone aanroep.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De onderliggende <xref:System.Net.Sockets.Socket>is gesloten.</xref:System.Net.Sockets.Socket>       - of - er is een fout opgetreden tijdens het schrijven naar het netwerk.       - of - er is een fout opgetreden bij het openen van de socket. Zie de sectie met opmerkingen voor meer informatie."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> is gesloten."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Finalize
  id: Finalize
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Versies van alle resources die worden gebruikt door de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Deze methode overschrijft <xref:System.Object.Finalize%2A?displayProperty=fullName>.</xref:System.Object.Finalize%2A?displayProperty=fullName> Toepassingscode moet niet aanroepen voor deze methode; een object <xref:System.Object.Finalize%2A>methode wordt automatisch geactiveerd tijdens garbagecollection, tenzij voltooiing door de garbage collector is uitgeschakeld door een aanroep naar de <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>methode.</xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> </xref:System.Object.Finalize%2A>       Zie voor meer informatie over het gebruik van de methode Finalize [methoden voltooien en Destructors](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [onbeheerde hulpbronnen reinigen](~/add/includes/ajax-current-ext-md.md), en [vervangt de methode voltooien](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~NetworkStream ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Flush
  id: Flush
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Leegmaakacties van de gegevens uit de stroom. Deze methode is gereserveerd voor toekomstig gebruik."
  remarks: "De methode Flush implementeert de <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>methode, maar omdat <xref:System.Net.Sockets.NetworkStream>is niet gebufferd, heeft geen invloed op Netwerkstromen.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.Stream.Flush%2A?displayProperty=fullName> Het aanroepen van de methode Flush Veroorzaak een uitzondering niet."
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Gegevens uit de stroom leegmaakacties als een asynchrone bewerking."
  remarks: "Deze bewerking wordt niet geblokkeerd. De geretourneerde <xref:System.Threading.Tasks.Task>object voltooid nadat de gegevens is leeggemaakt uit de stroom voor de <xref:System.Net.Sockets.NetworkStream>exemplaar.</xref:System.Net.Sockets.NetworkStream> </xref:System.Threading.Tasks.Task>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Een annulering token gebruikt voor het doorgeven van de melding dat deze bewerking moet worden geannuleerd."
    return:
      type: System.Threading.Tasks.Task
      description: "Retourneert <xref:System.Threading.Tasks.Task>.</xref:System.Threading.Tasks.Task>       Het taakobject dat de asynchrone bewerking vertegenwoordigt."
  overload: System.Net.Sockets.NetworkStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Length
  id: Length
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hiermee haalt u de lengte van de gegevens die beschikbaar zijn op de stroom. Deze eigenschap wordt momenteel niet ondersteund en er altijd een <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "De lengte van de gegevens die beschikbaar zijn op de stroom."
  overload: System.Net.Sockets.NetworkStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Gebruik van deze eigenschap."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Position
  id: Position
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Opgehaald of ingesteld van de huidige positie in de stroom. Deze eigenschap wordt momenteel niet ondersteund en er altijd een <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "De huidige positie in de stroom."
  overload: System.Net.Sockets.NetworkStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Gebruik van deze eigenschap."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Gegevens leest uit de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Deze methode leest de gegevens in de `buffer` parameter en retourneert het aantal bytes is gelezen. Als gegevens niet beschikbaar voor lezen, betekent dit dat de methode Read 0 geretourneerd. De leesbewerking leest zoveel gegevens als beschikbaar is, tot maximaal het aantal bytes dat is opgegeven door de `size` parameter. Als de externe host wordt de verbinding afgesloten en alle beschikbare gegevens is ontvangen, wordt de methode Read wordt onmiddellijk worden voltooid en nul bytes geretourneerd.      > [!NOTE] > Controleert u of de <xref:System.Net.Sockets.NetworkStream>kan worden gelezen door het aanroepen van de <xref:System.Net.Sockets.NetworkStream.CanRead%2A>eigenschap.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream> Als u probeert te lezen uit een <xref:System.Net.Sockets.NetworkStream>die niet leesbaar is, krijgt u een <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream>      > [!NOTE] > Als u een <xref:System.IO.IOException>controleert u de <xref:System.Exception.InnerException%2A>eigenschap om te bepalen of dit wordt veroorzaakt door een <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> krijgt</xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Als dit het geval is, gebruiken de <xref:System.Net.Sockets.SocketException.ErrorCode%2A>eigenschap verkrijgen van de specifieke foutcode en Raadpleeg de Windows Sockets versie 2 API fout code documentatie in MSDN voor een gedetailleerde beschrijving van de fout.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "The following code example uses <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> to determine if data is available to be read. If data is available, it reads from the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_1_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Een matrix van het type <xref:System.Byte>is de locatie in het geheugen voor het opslaan van gegevens lezen uit de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "De locatie in `buffer` om te beginnen met de gegevens wilt opslaan."
    - id: size
      type: System.Int32
      description: "Het aantal bytes lezen uit de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    return:
      type: System.Int32
      description: "Het aantal bytes lezen uit de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De <code> offset </code> parameter kleiner is dan 0.       - of - de <code> offset </code> parameter is groter dan de lengte van <code> buffer </code>.       - of - de <code> size </code> parameter kleiner is dan 0.       - of - de <code> size </code> parameter is groter dan de lengte van <code> buffer </code> minus de waarde van de <code> offset </code> parameter.       - of - er is een fout opgetreden bij het openen van de socket. Zie de sectie met opmerkingen voor meer informatie."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "De onderliggende <xref:System.Net.Sockets.Socket>is gesloten.</xref:System.Net.Sockets.Socket>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> is gesloten.       - of - er is een fout opgetreden bij het lezen van het netwerk."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Readable
  id: Readable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Opgehaald of ingesteld van een waarde die aangeeft of de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> kunnen worden gelezen."
  remarks: "U moet zijn afgeleid van de <xref:System.Net.Sockets.NetworkStream>klasse met de eigenschap kan worden gelezen.</xref:System.Net.Sockets.NetworkStream> Als Readable `true`, <xref:System.Net.Sockets.NetworkStream>kunt aanroepen naar de <xref:System.Net.Sockets.NetworkStream.Read%2A>methode.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> U kunt ook bepalen of een <xref:System.Net.Sockets.NetworkStream>kan worden gelezen door het controleren van openbaar toegankelijke <xref:System.Net.Sockets.NetworkStream.CanRead%2A>eigenschap.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream>       De leesbare eigenschap wordt ingesteld wanneer de <xref:System.Net.Sockets.NetworkStream>is geïnitialiseerd.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Readable property to determine if the <xref:System.Net.Sockets.NetworkStream> is readable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_7_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_7_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_7_1.vb)]"
  syntax:
    content: protected bool Readable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>om aan te geven die de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> kunnen worden gelezen, anders wordt <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. De standaardwaarde is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Readable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Opgehaald of ingesteld de hoeveelheid tijd die een leesbewerking blokken die wachten op gegevens."
  remarks: "Als de leesbewerking niet wordt voltooid binnen de tijd die is opgegeven door deze eigenschap, de leesbewerking genereert een <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Deze eigenschap is van invloed op alleen synchrone leesbewerkingen uitgevoerd door het aanroepen van de <xref:System.Net.Sockets.NetworkStream.Read%2A>methode.</xref:System.Net.Sockets.NetworkStream.Read%2A> Deze eigenschap heeft geen gevolgen voor asynchrone leesbewerkingen uitgevoerd door het aanroepen van de <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>methode.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>"
  example:
  - "The following code example sets the read time-out for a network stream to 10 milliseconds.  \n  \n [!code-cs[NCLTcpClientSync#2](~/add/codesnippet/csharp/p-system.net.sockets.net_4_1.cs)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "Een <xref:System.Int32>die Hiermee geeft u de tijdsduur in milliseconden, dat verstrijkt voordat een leesbewerking is mislukt.</xref:System.Int32> De standaardwaarde <xref:System.Threading.Timeout.Infinite>, geeft aan dat de leesbewerking geen time-out wordt.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.ReadTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De opgegeven waarde is kleiner dan of gelijk zijn aan nul en is niet <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hiermee stelt u de huidige positie van de stroom op de opgegeven waarde. Deze methode wordt momenteel niet ondersteund en er altijd een <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Deze parameter wordt niet gebruikt."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Deze parameter wordt niet gebruikt."
    return:
      type: System.Int64
      description: "De positie in de stroom."
  overload: System.Net.Sockets.NetworkStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Gebruik van deze eigenschap."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hiermee stelt u de lengte van de stroom. Deze methode genereert altijd een <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Deze parameter wordt niet gebruikt."
  overload: System.Net.Sockets.NetworkStream.SetLength*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Gebruik van deze eigenschap."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Socket
  id: Socket
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "De onderliggende <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> opgehaald"
  remarks: "Klassen die zijn afgeleid van <xref:System.Net.Sockets.NetworkStream>Deze eigenschap om de onderliggende <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Gebruik de onderliggende <xref:System.Net.Sockets.Socket>geretourneerd van de Socket-eigenschap als u toegang tot voorbij dat vereist dat <xref:System.Net.Sockets.NetworkStream>biedt.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.Socket>      > [!NOTE] > Deze eigenschap is uitsluitend toegankelijk via deze klasse of een afgeleide klasse."
  example:
  - "The following code example retrieves the underlying <xref:System.Net.Sockets.Socket> to verify an active connection.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_3_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_3_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_3_1.vb)]"
  syntax:
    content: protected System.Net.Sockets.Socket Socket { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "Een <xref:System.Net.Sockets.Socket>die staat voor de onderliggende netwerkverbinding.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.Socket*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Schrijft gegevens naar de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "De methode schrijven wordt gestart op de opgegeven `offset` en verzendt `size` bytes uit de inhoud van `buffer` met het netwerk. De methode Write geblokkeerd totdat het aangevraagde aantal bytes verzonden of een <xref:System.Net.Sockets.SocketException>gegenereerd.</xref:System.Net.Sockets.SocketException> Als u krijgt een <xref:System.Net.Sockets.SocketException>, gebruiken de <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>eigenschap verkrijgen van de specifieke foutcode en Raadpleeg de Windows Sockets versie 2 API fout code documentatie in MSDN voor een gedetailleerde beschrijving van de fout.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > Controleert u of de <xref:System.Net.Sockets.NetworkStream>alleen-lezenmap is door het openen van de <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>eigenschap.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream> Als u probeert te schrijven naar een <xref:System.Net.Sockets.NetworkStream>die niet schrijfbaar is, krijgt u een <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream> Als u een <xref:System.IO.IOException>controleert u de <xref:System.Exception.InnerException%2A>eigenschap om te bepalen of dit wordt veroorzaakt door een <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> krijgt</xref:System.Exception.InnerException%2A> </xref:System.IO.IOException>"
  example:
  - "The following code example checks to see whether the <xref:System.Net.Sockets.NetworkStream> is writable. If it is, then Write is used to write a small message.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/87c395a5-03ea-4324-8b05-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/87c395a5-03ea-4324-8b05-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/87c395a5-03ea-4324-8b05-_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Een matrix van het type <xref:System.Byte>waarin de gegevens te schrijven naar de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "De locatie in `buffer` uit waarop u wilt beginnen met het schrijven van gegevens."
    - id: size
      type: System.Int32
      description: "Het aantal bytes schrijven naar de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De <code> offset </code> parameter kleiner is dan 0.       - of - de <code> offset </code> parameter is groter dan de lengte van <code> buffer </code>.       - of - de <code> size </code> parameter kleiner is dan 0.       - of - de <code> size </code> parameter is groter dan de lengte van <code> buffer </code> minus de waarde van de <code> offset </code> parameter."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Er is een fout opgetreden tijdens het schrijven naar het netwerk.       - of - er is een fout opgetreden bij het openen van de socket. Zie de sectie met opmerkingen voor meer informatie."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "De <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> is gesloten.       - of - er is een fout opgetreden bij het lezen van het netwerk."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Writeable
  id: Writeable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Hiermee wordt een waarde die aangeeft of de <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> schrijfbaar is."
  remarks: "U moet zijn afgeleid van de <xref:System.Net.Sockets.NetworkStream>klasse moet worden gebruikt van de eigenschap Writeable.</xref:System.Net.Sockets.NetworkStream> Als Writeable `true`, <xref:System.Net.Sockets.NetworkStream>kunt aanroepen naar de <xref:System.Net.Sockets.NetworkStream.Write%2A>methode.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> U kunt ook bepalen of een <xref:System.Net.Sockets.NetworkStream>alleen-lezenmap is door het controleren van openbaar toegankelijke <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>eigenschap.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream>       De eigenschap Writeable wordt ingesteld wanneer de <xref:System.Net.Sockets.NetworkStream>is geïnitialiseerd.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Writeable property to determine if the <xref:System.Net.Sockets.NetworkStream> is writable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_5_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_5_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_5_1.vb)]"
  syntax:
    content: protected bool Writeable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als u gegevens kunnen worden geschreven naar de stroom; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. De standaardwaarde is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Writeable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Opgehaald of ingesteld de hoeveelheid tijd die een write-bewerking blokken wachten op gegevens."
  remarks: "Als de write-bewerking is niet voltooid binnen de tijd die is opgegeven door deze eigenschap, de schrijfbewerking genereert een <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Deze eigenschap is van invloed op alleen synchrone schrijfbewerkingen uitgevoerd door het aanroepen van de <xref:System.Net.Sockets.NetworkStream.Write%2A>methode.</xref:System.Net.Sockets.NetworkStream.Write%2A> Deze eigenschap heeft geen invloed op asynchrone schrijfbewerkingen uitgevoerd door het aanroepen van de <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>methode.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>"
  example:
  - "The following code example sets the write time-out for a network stream to 10 milliseconds.  \n  \n [!code-cpp[NCLTcpServerSync#0](~/add/codesnippet/cpp/p-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NCLTcpServerSync#0](~/add/codesnippet/csharp/p-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "Een <xref:System.Int32>die Hiermee geeft u de tijdsduur in milliseconden, dat verstrijkt voordat een schrijfbewerking is mislukt.</xref:System.Int32> De standaardwaarde <xref:System.Threading.Timeout.Infinite>, geeft aan dat de schrijfbewerking geen time-out wordt.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.WriteTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "De opgegeven waarde is kleiner dan of gelijk zijn aan nul en is niet <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Sockets.NetworkStream.CanRead
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.Finalize
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
- uid: System.Net.Sockets.NetworkStream.Flush
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Net.Sockets.NetworkStream.Length
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Sockets.NetworkStream.Position
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Readable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
- uid: System.Net.Sockets.NetworkStream.Socket
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Writeable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
- uid: System.Net.Sockets.NetworkStream.#ctor*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream
  nameWithType: NetworkStream.NetworkStream
- uid: System.Net.Sockets.NetworkStream.BeginRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead
  nameWithType: NetworkStream.BeginRead
- uid: System.Net.Sockets.NetworkStream.BeginWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite
  nameWithType: NetworkStream.BeginWrite
- uid: System.Net.Sockets.NetworkStream.CanRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close
  nameWithType: NetworkStream.Close
- uid: System.Net.Sockets.NetworkStream.DataAvailable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose
  nameWithType: NetworkStream.Dispose
- uid: System.Net.Sockets.NetworkStream.EndRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead
  nameWithType: NetworkStream.EndRead
- uid: System.Net.Sockets.NetworkStream.EndWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite
  nameWithType: NetworkStream.EndWrite
- uid: System.Net.Sockets.NetworkStream.Finalize*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize
  nameWithType: NetworkStream.Finalize
- uid: System.Net.Sockets.NetworkStream.Flush*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush
  nameWithType: NetworkStream.Flush
- uid: System.Net.Sockets.NetworkStream.FlushAsync*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync
  nameWithType: NetworkStream.FlushAsync
- uid: System.Net.Sockets.NetworkStream.Length*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
- uid: System.Net.Sockets.NetworkStream.Position*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read
  nameWithType: NetworkStream.Read
- uid: System.Net.Sockets.NetworkStream.Readable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek
  nameWithType: NetworkStream.Seek
- uid: System.Net.Sockets.NetworkStream.SetLength*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength
  nameWithType: NetworkStream.SetLength
- uid: System.Net.Sockets.NetworkStream.Socket*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write
  nameWithType: NetworkStream.Write
- uid: System.Net.Sockets.NetworkStream.Writeable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
