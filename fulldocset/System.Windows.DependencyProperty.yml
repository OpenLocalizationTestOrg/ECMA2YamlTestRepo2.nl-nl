### YamlMime:ManagedReference
items:
- uid: System.Windows.DependencyProperty
  id: DependencyProperty
  children:
  - System.Windows.DependencyProperty.AddOwner(System.Type)
  - System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.DefaultMetadata
  - System.Windows.DependencyProperty.GetHashCode
  - System.Windows.DependencyProperty.GetMetadata(System.Type)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  - System.Windows.DependencyProperty.GlobalIndex
  - System.Windows.DependencyProperty.IsValidType(System.Object)
  - System.Windows.DependencyProperty.IsValidValue(System.Object)
  - System.Windows.DependencyProperty.Name
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyProperty.OwnerType
  - System.Windows.DependencyProperty.PropertyType
  - System.Windows.DependencyProperty.ReadOnly
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.ToString
  - System.Windows.DependencyProperty.UnsetValue
  - System.Windows.DependencyProperty.ValidateValueCallback
  langs:
  - csharp
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
  type: Class
  summary: "Hiermee geeft u een eigenschap die kan worden ingesteld via de methoden zoals, stijlen gegevensbinding, animatie en overname."
  remarks: "Een DependencyProperty ondersteunt de volgende mogelijkheden in [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]:-de eigenschap kan worden ingesteld in een style. Zie voor meer informatie [stijlen en Templating](~/add/includes/ajax-current-ext-md.md).      -De eigenschap kan worden ingesteld via gegevensbinding. Zie voor meer informatie over de eigenschappen van gegevensbinding afhankelijkheid [hoe: de eigenschappen van twee besturingselementen binden](~/add/includes/ajax-current-ext-md.md).      -De eigenschap kan worden ingesteld met een verwijzing dynamische bron. Zie voor meer informatie [XAML Resources](~/add/includes/ajax-current-ext-md.md).      -De eigenschap kan de waarde ervan automatisch overnemen van een bovenliggend element in de structuur van element. Zie voor meer informatie [waarde Eigenschapsovername](~/add/includes/ajax-current-ext-md.md).      -De animatie van de eigenschap kan worden toegepast. Zie voor meer informatie [overzicht van animatie](~/add/includes/ajax-current-ext-md.md).      -De eigenschap kan rapporteren wanneer de vorige waarde van de eigenschap is gewijzigd en de waarde van eigenschap kan worden afgedwongen. Zie voor meer informatie [afhankelijkheid eigenschap retouraanroepen en validatie](~/add/includes/ajax-current-ext-md.md).      -De eigenschap rapporteert informatie [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], zoals of wijzigen van een eigenschapswaarde moet het systeem lay-out om opnieuw de visuele elementen voor een element.      -De eigenschap ontvangt ondersteuning voor de [!INCLUDE[wpfdesigner_current_long](~/add/includes/wpfdesigner-current-long-md.md)].  Bijvoorbeeld: de eigenschap kan worden bewerkt de **eigenschappen** venster.       Zie voor meer informatie over de afhankelijkheidseigenschappen van, [afhankelijkheid eigenschappen overzicht](~/add/includes/ajax-current-ext-md.md). Als u eigenschappen op uw aangepaste typen wilt ter ondersteuning van de mogelijkheden in de bovenstaande lijst, moet u een afhankelijkheidseigenschap maken.  Zie voor meer informatie over het maken van aangepaste afhankelijkheidseigenschappen, [aangepaste afhankelijkheidseigenschappen](~/add/includes/ajax-current-ext-md.md).       Een gekoppelde eigenschap is een eigenschap waarmee een object voor het rapporteren van gegevens naar het type dat de gekoppelde eigenschap definieert. In [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], type dat eigenschappen van overneemt <xref:System.Windows.DependencyObject>kunt gebruiken een gekoppelde eigenschap ongeacht of het type neemt over van het type dat de eigenschap definieert.</xref:System.Windows.DependencyObject> Een gekoppelde eigenschap is een functie van de [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] taal.  Een gekoppelde eigenschap instellen in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], gebruiken de *ownerType*.* propertyName* syntaxis. Een voorbeeld van een gekoppelde eigenschap is de <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>eigenschap.</xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName> Als u wilt maken van een eigenschap die kan worden gebruikt voor alle <xref:System.Windows.DependencyObject>typt, moet u een gekoppelde eigenschap maken.</xref:System.Windows.DependencyObject> Zie voor meer informatie over de bijgevoegde eigenschappen, waaronder het maken, [gekoppeld eigenschappen overzicht](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_DependencyProperty&quot;></a>## XAML Kenmerkgebruik ```   <object property=&quot;dependencyPropertyName&quot;/>   - or -   <object property=&quot;ownerType.dependencyPropertyName&quot;/>   - or -   <object property=&quot;attachedPropertyOwnerType.attachedPropertyName&quot;/>   ``` <a name=&quot;xamlValues_DependencyProperty&quot;> </a> ## XAML waarden `dependencyPropertyName` een tekenreeks waarmee de <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>van de gewenste afhankelijkheidseigenschap.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>       Dit kan worden voorafgegaan door een XML-naamruimtevoorvoegsel als de eigenschap niet de standaard XML-naamruimte is (Zie voor meer informatie [XAML-naamruimten en Namespace toe te wijzen voor WPF XAML](~/add/includes/ajax-current-ext-md.md).)       `ownerType`.`dependencyPropertyName`    Een tekenreeks die een Eigenaartype van een afhankelijkheidseigenschap, een punt (.) en vervolgens de <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName> `ownerType`kan ook worden voorafgegaan door een XML-naamruimtevoorvoegsel. Dit gebruik is ingesteld voor een laatgebonden stijlen en sjablonen, waarbij de eigenaar van de afhankelijkheidseigenschap moet worden opgegeven voor het parseren van de context omdat de `TargetType` nog niet bekend. Zie voor meer informatie [stijlen en Templating](../Topic/Styling%20and%20Templating.md).       `attachedPropertyOwnerType` *.* `attachedPropertyName`Een tekenreeks die de eigenaar van een gekoppelde eigenschap, een punt (.) en vervolgens de naam van de gekoppelde eigenschap opgeeft. `attachedPropertyOwnerType`kan ook worden voorafgegaan door een XML-naamruimtevoorvoegsel."
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))]

      public sealed class DependencyProperty
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  id: AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Voegt een ander type als eigenaar van een afhankelijkheidseigenschap die is al geregistreerd."
  remarks: "Deze methode kunt het systeem eigenschap voor het herkennen van een afhankelijkheidseigenschap op een type dat is dat bepaalde afhankelijkheidseigenschap niet in eerste instantie geregistreerd.       AddOwner wordt normaal gesproken gebruikt om toe te voegen afhankelijkheidseigenschappen voor klassen die niet al deze afhankelijkheidseigenschap via beheerde klassenovername blootstellen (klassenovername ervoor zou zorgen dat de wrapper-eigenschappen worden overgenomen door de afgeleide klasse en daarom zou tabel algemene leden toegang bieden tot de afhankelijkheidseigenschap al). AddOwner zorgt voor de eigenschap-systeem voor het herkennen van een afhankelijkheidseigenschap op een type dat daarvan kan die afhankelijkheidseigenschap niet in eerste instantie registreren.       Deze handtekening is niet toegestaan voor het opgeven van metagegevens.  Wanneer u deze methode gebruikt, de metagegevens wordt automatisch gegenereerd voor de nieuwe <xref:System.Windows.DependencyProperty>en het eigenaarstype.</xref:System.Windows.DependencyProperty> De metagegevens van de automatisch gegenereerde is het resultaat van de samengevoegde metagegevens uit alle van de basistypen waarvoor deze eigenschap is gedefinieerd. Als er geen samengevoegde metagegevens beschikbaar is, wordt de standaard-metagegevens voor de eigenschap gebruikt. Als de eigenschap is geregistreerd met behulp van de <xref:System.Windows.DependencyProperty.RegisterAttached%2A>methode en vervolgens de metagegevens van de standaardwaarde is hetzelfde als de metagegevens die wordt gemaakt wanneer <xref:System.Windows.DependencyProperty.RegisterAttached%2A>is aangeroepen.</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> Anders wordt de <xref:System.Windows.PropertyMetadata>object is gemaakt met de <xref:System.Windows.PropertyMetadata.DefaultValue%2A>eigenschap is ingesteld op het eigenschapstype standaard en alle andere eigenschappen van de <xref:System.Windows.PropertyMetadata>is ingesteld op `null`.</xref:System.Windows.PropertyMetadata> </xref:System.Windows.PropertyMetadata.DefaultValue%2A> </xref:System.Windows.PropertyMetadata> Gebruik de <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>handtekening als u wilt dat metagegevens op te geven voor de versie van de afhankelijkheidseigenschap toegevoegd aan het opgegeven type.</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>       De geretourneerde waarde van deze methode wordt doorgaans gebruikt voor declareren en maak de afhankelijkheidseigenschap zichtbaar doordat een afhankelijkheid eigenschaps-id. De id biedt toegang tot de afhankelijkheidseigenschap als u wilt aanroepen van de eigenschap system [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] tegen de afhankelijkheidseigenschap met name als bestaat op de eigenaar-klasse toe te voegen. De naam van de dezelfde eigenschap voor zowel de oorspronkelijke eigenaar en de toegevoegde eigenaar moet worden gebruikt om aan te geven van de vergelijkbare functionaliteit. Moet u de <xref:System.Windows.DependencyProperty>retourwaarde van de AddOwner-methode voor het definiëren van de eigenschap id van afhankelijkheid en om te declareren [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] eigenschap wrappers, voor afhankelijkheidseigenschappen die zijn toegevoegd aan de typen met behulp van AddOwner.</xref:System.Windows.DependencyProperty>       De hierboven aanbevolen AddOwner-methode wordt gebruikt bij het maken van de eigenschappen van de afhankelijkheid die zijn gedeclareerd binnen [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]. Bijvoorbeeld: beide <xref:System.Windows.Controls.Border>en <xref:System.Windows.Controls.Control>definiëren een `BorderBrush` afhankelijkheidseigenschap met vergelijkbare functionaliteit.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>definieert de `BorderBrush` eigenschap met de eigenschap systeem door het aanroepen van AddOwner op basis van de oorspronkelijke eigenaar <xref:System.Windows.Controls.Border>en de geregistreerde <xref:System.Windows.Controls.Border.BorderBrushProperty>eigenschap-id van afhankelijkheid.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border></xref:System.Windows.Controls.Control> De AddOwner retourneren waarde wordt vervolgens gebruikt voor het tot stand brengen van een nieuw statisch <xref:System.Windows.DependencyProperty>veld (<xref:System.Windows.Controls.Control.BorderBrushProperty>) voor die eigenschap in de toegevoegde eigenaar en een `BorderBrush` eigenschap wrapper wordt ook gedeclareerd.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty>"
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType);
    parameters:
    - id: ownerType
      type: System.Type
      description: "Het type moet worden toegevoegd als een eigenaar van deze afhankelijkheidseigenschap."
    return:
      type: System.Windows.DependencyProperty
      description: "Een verwijzing naar de oorspronkelijke <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> -id waarmee de afhankelijkheidseigenschap. Deze id moet worden weergegeven door de klasse toe te voegen als een <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> veld."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  id: AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Een ander type toegevoegd als een eigenaar van een afhankelijkheidseigenschap die al is geregistreerd, verstrekken die de metagegevens van de eigenschap afhankelijkheid voor de afhankelijkheidseigenschap bestaat deze op het type van de opgegeven eigenaar."
  remarks: "Deze methode kunt het systeem eigenschap voor het herkennen van een afhankelijkheidseigenschap op een type dat is dat bepaalde afhankelijkheidseigenschap niet in eerste instantie geregistreerd.       De geretourneerde waarde van deze methode wordt gebruikt voor declareren en de afhankelijkheidseigenschap weer te geven, met name als deze op de eigenaar-klasse toe te voegen bestaat. In het algemeen moet dezelfde eigenschapsnaam voor zowel de oorspronkelijke eigenaar en de toegevoegde eigenaar worden gebruikt om aan te geven van de vergelijkbare functionaliteit. Het is raadzaam om te kunnen stellen de-id&quot;s, ook als een nieuwe [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] eigenschap wrappers, voor afhankelijkheidseigenschappen die zijn toegevoegd aan de typen met behulp van <xref:System.Windows.DependencyProperty.AddOwner%2A>.</xref:System.Windows.DependencyProperty.AddOwner%2A>       De <xref:System.Windows.DependencyProperty.AddOwner%2A>hierboven aanbevolen methodologie wordt gebruikt bij het maken van [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] gedeclareerd binnen [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)].</xref:System.Windows.DependencyProperty.AddOwner%2A> Bijvoorbeeld: beide <xref:System.Windows.Controls.Border>en <xref:System.Windows.Controls.Control>definiëren een `BorderBrush` afhankelijkheidseigenschap met vergelijkbare functionaliteit.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>definieert de `BorderBrush` eigenschap met de eigenschap systeem door het aanroepen van <xref:System.Windows.DependencyProperty.AddOwner%2A>in de oorspronkelijke eigenaar <xref:System.Windows.Controls.Border>en de geregistreerde <xref:System.Windows.Controls.Border.BorderBrushProperty>afhankelijkheid eigenschap-id.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border> </xref:System.Windows.DependencyProperty.AddOwner%2A></xref:System.Windows.Controls.Control> De <xref:System.Windows.DependencyProperty.AddOwner%2A>retourneren waarde wordt vervolgens gebruikt voor het tot stand brengen van een statische <xref:System.Windows.DependencyProperty>veld (<xref:System.Windows.Controls.Control.BorderBrushProperty>) voor die eigenschap in de toegevoegde eigenaar en een `BorderBrush` eigenschap wrapper wordt ook gedeclareerd.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.AddOwner%2A>       De toegevoegde eigenaar afhankelijkheid eigenschaps-id moet worden gebruikt voor bewerkingen, zoals <xref:System.Windows.DependencyObject.GetValue%2A>.</xref:System.Windows.DependencyObject.GetValue%2A> Type-specifieke bewerkingen met betrekking tot typen of exemplaren van de klasse die is toegevoegd als eigenaar met andere metagegevens nog retourneert echter de verwachte resultaten zelfs als de oorspronkelijke (geen toegevoegde van de eigenaar) afhankelijkheid eigenschaps-id is opgegeven in aanroepen van methoden zoals <xref:System.Windows.DependencyObject.GetValue%2A>of <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</xref:System.Windows.DependencyProperty.GetMetadata%2A> </xref:System.Windows.DependencyObject.GetValue%2A> De metagegevens voor de eigenaar van de toegevoegde is door de AddOwner perpetuated aanroepen zelf niet noodzakelijkerwijs waarnaar wordt verwezen exclusief gebruik door het veld toe te voegen eigenaar klasse-id. Evenwel is het verstandig om de id, ook als een nieuwe weer te [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] eigenschap wrappers, voor afhankelijkheidseigenschappen die zijn toegevoegd aan de typen met behulp van AddOwner, omdat dit niet te doen verschillen tussen maakt de [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] en [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] representaties van uw eigenschappen.       De opgegeven metagegevens is samengevoegd met de metagegevens van de eigenschap voor de afhankelijkheidseigenschap zoals zich dit in de eigenaar van het basistype. Alle kenmerken die zijn opgegeven in de metagegevens van de oorspronkelijke base bewaard. De kenmerken van de metagegevens van de base wordt overschreven door kenmerken die specifiek zijn gewijzigd in de nieuwe metagegevens. Enkele kenmerken, zoals <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, worden vervangen als ze worden opgegeven in de nieuwe metagegevens.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Anderen, zoals <xref:System.Windows.PropertyChangedCallback>, worden gecombineerd.</xref:System.Windows.PropertyChangedCallback> Uiteindelijk het gedrag samenvoegen is afhankelijk van het metagegevenstype van eigenschap wordt gebruikt voor de onderdrukking, zodat het gedrag dat hier wordt beschreven voor de bestaande eigenschap metagegevens klassen die worden gebruikt door [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] afhankelijkheidseigenschappen. Zie voor meer informatie [metagegevens van de eigenschap afhankelijkheid](~/add/includes/ajax-current-ext-md.md) en [metagegevens van de eigenschap Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: ownerType
      type: System.Type
      description: "Het type om toe te voegen als de eigenaar van deze afhankelijkheidseigenschap."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "De metagegevens die in aanmerking de afhankelijkheidseigenschap komt zoals zich dit op het opgegeven type."
    return:
      type: System.Windows.DependencyProperty
      description: "Een verwijzing naar de oorspronkelijke <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> -id waarmee de afhankelijkheidseigenschap. Deze id moet worden weergegeven door de klasse toe te voegen als een <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> veld."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.DefaultMetadata
  id: DefaultMetadata
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hiermee haalt u de standaard-metagegevens van de afhankelijkheidseigenschap."
  remarks: "De metagegevens die standaard is de metagegevens van de eigenschap die beschikbaar is voor dit object of een object van een afgeleid type waarin geen alternatieve metagegevens is geleverd door een expliciete <xref:System.Windows.DependencyProperty.Register%2A>of <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>aanroepen.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.Register%2A>       Als de oorspronkelijke eigenaar metagegevens op de eerste toegepast <xref:System.Windows.DependencyProperty.Register%2A>oproep waarin de afhankelijkheidseigenschap tot stand worden gebracht en vervolgens de metagegevens wordt geretourneerd als DefaultMetadata.</xref:System.Windows.DependencyProperty.Register%2A>       Als er geen metagegevens is toegepast in de oorspronkelijke <xref:System.Windows.DependencyProperty.Register%2A>aanroep, standaard metagegevens worden gegenereerd vanuit de <xref:System.Windows.DependencyProperty.Register%2A>aanroep en deze waarde wordt geretourneerd als de DefaultMetadata.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.Register%2A>       Het belangrijkste doel van de standaard metagegevens gekoppeld aan een <xref:System.Windows.DependencyProperty>is het leveren van een standaardwaarde voor deze eigenschap op een <xref:System.Windows.DependencyObject>of een afgeleid type.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyProperty>       Voor nonattached eigenschappen de metagegevenstype dat is geretourneerd door deze eigenschap kan niet worden geconverteerd naar afgeleide typen <xref:System.Windows.PropertyMetadata>typt, zelfs als de eigenschap oorspronkelijk is geregistreerd met een afgeleide metagegevenstype.</xref:System.Windows.PropertyMetadata> Als u wilt dat de oorspronkelijk geregistreerde metagegevens, met inbegrip van de oorspronkelijke mogelijk afgeleide metagegevenstype, belt <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>in plaats daarvan het doorgeven van de oorspronkelijke registratie typt als parameter.</xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>       Voor de bijgevoegde eigenschappen, het type van de metagegevens die zijn geretourneerd door deze eigenschap komt overeen met het type dat is opgegeven in de oorspronkelijke <xref:System.Windows.DependencyProperty.RegisterAttached%2A>registratiemethode.</xref:System.Windows.DependencyProperty.RegisterAttached%2A>"
  example:
  - "[!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]\n[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]"
  syntax:
    content: public System.Windows.PropertyMetadata DefaultMetadata { get; }
    return:
      type: System.Windows.PropertyMetadata
      description: "De standaard-metagegevens van de afhankelijkheidseigenschap."
  overload: System.Windows.DependencyProperty.DefaultMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetHashCode
  id: GetHashCode
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retourneert een hashcode voor deze <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  remarks: "Het systeem eigenschap maakt gebruik van zijn eigen unieke id <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, en de waarde van deze eigenschap wordt geretourneerd door GetHashCode.</xref:System.Windows.DependencyProperty.GlobalIndex%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "De hash-code voor deze <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  overload: System.Windows.DependencyProperty.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  id: GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retourneert de metagegevens voor deze afhankelijkheidseigenschap zoals zich dit op een opgegeven bestaande type."
  remarks: "Het opgeven van het type of een verwijzing naar een object om te gebruiken als het type is nodig omdat de metagegevens kan afwijken van de registratie van de oorspronkelijke vervaldatum toekennen aan <xref:System.Windows.DependencyProperty.AddOwner%2A>of <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>aanroepen die de metagegevens van de afhankelijkheidseigenschap alter zoals dit zich op een type.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its type. The type is obtained by using a `typeof` operator.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatatype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (Type forType);
    parameters:
    - id: forType
      type: System.Type
      description: "Het specifieke type van waaruit de metagegevens van de eigenschap afhankelijkheid ophalen."
    return:
      type: System.Windows.PropertyMetadata
      description: "Het metagegevensobject voor een eigenschap."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  id: GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retourneert de metagegevens voor deze afhankelijkheidseigenschap zoals zich dit op het exemplaar van het opgegeven object."
  remarks: "Het opgeven van het type of een objectverwijzing is nodig omdat de metagegevens van een bepaalde afhankelijkheidseigenschap kan afwijken van de registratie van de oorspronkelijke vervaldatum toekennen aan <xref:System.Windows.DependencyProperty.AddOwner%2A>of <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>aanroepen die u de metagegevens van de eigenschap verfijnen kunnen zoals dit zich op een type.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>       Wanneer u de metagegevens van de eigenschap op basis van een exemplaar aanvraagt, doorgeeft u gewoon het exemplaar dat het type intern kan worden geëvalueerd. Metagegevens van de eigenschap afhankelijkheid komt niet verschillen per exemplaar; het is altijd consistent zijn voor elke combinatie van het gegeven type-eigenschap."
  example:
  - "The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);
    parameters:
    - id: dependencyObject
      type: System.Windows.DependencyObject
      description: "Een afhankelijkheidsobject dat wordt gecontroleerd op type om te bepalen welke specifieke versie van de afhankelijkheidseigenschap de metagegevens moet voortkomen uit."
    return:
      type: System.Windows.PropertyMetadata
      description: "Het metagegevensobject voor een eigenschap."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  id: GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retourneert de metagegevens voor deze afhankelijkheidseigenschap zoals zich dit op een bepaald type."
  remarks: "Het opgeven van het type of een objectverwijzing is nodig omdat de metagegevens van een bepaalde afhankelijkheidseigenschap kan afwijken van de registratie van de oorspronkelijke vervaldatum toekennen aan <xref:System.Windows.DependencyProperty.AddOwner%2A>of <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>aanroepen die u de metagegevens van de eigenschap verfijnen kunnen zoals dit zich op een type.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadotype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);
    parameters:
    - id: dependencyObjectType
      type: System.Windows.DependencyObjectType
      description: "Een specifiek object waarmee de afhankelijkheid van het type van waaruit de metagegevens van de eigenschap afhankelijkheid gewenst is vastgelegd."
    return:
      type: System.Windows.PropertyMetadata
      description: "Het metagegevensobject voor een eigenschap."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GlobalIndex
  id: GlobalIndex
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hiermee wordt een intern gegenereerde waarde die een unieke identificatie van de afhankelijkheidseigenschap."
  remarks: "Deze waarde is een geheel getal, niet een [!INCLUDE[TLA#tla_guid](~/add/includes/ajax-current-ext-md.md)]. In het algemeen met behulp van de waarde voor deze index is niet vereist en er is geen index toegang tot tabellen van alle eigenschappen van afhankelijkheid. Afhankelijkheidseigenschappen moeten in plaats daarvan worden verwezen door de id-velden.       GlobalIndex wordt intern gebruikt voor sneller toegang tot gegevensstructuren die de GlobalIndex als een index op nul gebaseerde matrix gebruiken. Een vergelijkbaar gebruik wellicht toepassingen voor ontwerpers of hulpprogramma&quot;s."
  syntax:
    content: public int GlobalIndex { get; }
    return:
      type: System.Int32
      description: "Een unieke numerieke id."
  overload: System.Windows.DependencyProperty.GlobalIndex*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  id: IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hiermee wordt bepaald of een bepaalde waarde aanvaardbaar is voor deze afhankelijkheidseigenschap type, zoals vergeleken met het eigenschapstype opgegeven in de oorspronkelijke eigenschap registratie van cacheafhankelijkheid."
  remarks: "Een waarde van `null` is een ongeldig type voor afhankelijkheidseigenschappen reference-type, of voor een <xref:System.Nullable%601>afhankelijkheidseigenschap, en zou retourneren `true` voor dergelijke gevallen.</xref:System.Nullable%601> In gevallen waarin de afhankelijkheidseigenschap geen van beide een verwijzing is noch een <xref:System.Nullable%601>type, IsValidType retourneert `false` voor een null-waarde plaats van een uitzondering wilt verhogen.</xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidType as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvalue)]\n [!code-vb[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]"
  syntax:
    content: public bool IsValidType (object value);
    parameters:
    - id: value
      type: System.Object
      description: "De waarde om te controleren."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de opgegeven waarde het geregistreerde type of een acceptabele afgeleid type is; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  id: IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hiermee wordt bepaald of de opgegeven waarde voor het type eigenschap door middel van controle van het algemene type wordt geaccepteerd en mogelijk ook als deze zich binnen het toegestane bereik van waarden voor dat type."
  remarks: "Voor een afhankelijkheidseigenschap een toegestane waardenbereik voor dat type kan worden opgegeven via een <xref:System.Windows.ValidateValueCallback>die is opgegeven in de eigenschap registratie van cacheafhankelijkheid.</xref:System.Windows.ValidateValueCallback>       Deze methode aanroept <xref:System.Windows.DependencyProperty.IsValidType%2A>intern.</xref:System.Windows.DependencyProperty.IsValidType%2A> Als de desbetreffende afhankelijkheidseigenschap geen <xref:System.Windows.ValidateValueCallback>vervolgens aanroepen met deze methode is effectief gelijk is aan het aanroepen van <xref:System.Windows.DependencyProperty.IsValidType%2A>.</xref:System.Windows.DependencyProperty.IsValidType%2A> heeft</xref:System.Windows.ValidateValueCallback> Als de afhankelijkheidseigenschap beschikt over een <xref:System.Windows.ValidateValueCallback>, en als <xref:System.Windows.DependencyProperty.IsValidType%2A>zouden hebben geretourneerd `true`, wordt de waarde geretourneerd worden geïmplementeerd in de callback.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback>       Een null-waarde is een geldige waarde voor afhankelijkheidseigenschappen reference-type, of voor een <xref:System.Nullable%601>afhankelijkheidseigenschap, en zou retourneren `true` voor dergelijke gevallen.</xref:System.Nullable%601> In gevallen waarin de afhankelijkheidseigenschap geen van beide een verwijzing is noch een <xref:System.Nullable%601>type, <xref:System.Windows.DependencyProperty.IsValidType%2A>retourneert `false` voor een null-waarde plaats van een uitzondering wilt verhogen.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidValue as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]\n [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]"
  syntax:
    content: public bool IsValidValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "De waarde om te controleren."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de waarde acceptabel is en van het juiste type of een afgeleid type is; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Name
  id: Name
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hiermee haalt u de naam van de afhankelijkheidseigenschap."
  remarks: "Deze eigenschap wordt de naam die is opgegeven als de `name` parameter tijdens de registratie van cacheafhankelijkheid-eigenschap. Deze naam is onveranderbaar en kan niet worden `null` of een lege tekenreeks. Dubbele naamregistraties van hetzelfde eigenaarstype als zijn niet toegestaan en genereert een uitzondering opgetreden bij het registreren van het duplicaat.      > [!IMPORTANT] > De naam van een afhankelijkheidseigenschap moet voldoen aan de overeenkomst van die overeenkomt met de naam van de id van de eigenschap afhankelijkheid minus het achtervoegsel &quot;Eigenschap&quot;. Zie voor meer informatie [aangepaste afhankelijkheidseigenschappen](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the Name.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "De naam van de eigenschap."
  overload: System.Windows.DependencyProperty.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hiermee geeft u alternatieve metagegevens voor deze afhankelijkheidseigenschap wanneer dit zich op exemplaren van een bepaald type, de metagegevens die beschikbaar voor de afhankelijkheidseigenschap bevindt waren zoals deze is overgenomen van de basistypen te overschrijven."
  remarks: "Metagegevens van de eigenschap afhankelijkheid moet worden vervangen voordat het systeem eigenschap maakt gebruik van de afhankelijkheidseigenschap. Dit is gelijk aan de tijd die specifieke exemplaren worden gemaakt met behulp van de klasse die de afhankelijkheidseigenschap registreert. Aanroepen naar OverrideMetadata moeten alleen worden uitgevoerd binnen de statische constructors van het type waarmee zelf als de `forType` parameter van deze methode of via vergelijkbare instantiëring. Probeert metagegevens wijzigen nadat de exemplaren van het eigenaarstype bestaan niet uitzonderingen verhoogt, maar zal leiden tot inconsistent gedrag in het systeem eigenschap.       Nadat de metagegevens voor een onderdrukking bepaalde afgeleide klasse is gemaakt met deze methode, wordt in daaropvolgende pogingen worden gedaan voor het onderdrukken van metagegevens voor deze dezelfde afgeleide klasse een uitzondering veroorzaakt.       De opgegeven metagegevens is samengevoegd met de metagegevens van de eigenschap voor de afhankelijkheidseigenschap zoals zich dit in de eigenaar van het basistype. Alle kenmerken die zijn opgegeven in de metagegevens van de oorspronkelijke base bewaard; de kenmerken van de metagegevens van de base wordt overschreven door kenmerken die specifiek zijn gewijzigd in de nieuwe metagegevens. Enkele kenmerken zoals <xref:System.Windows.PropertyMetadata.DefaultValue%2A>worden vervangen als opgegeven in de nieuwe metagegevens.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Anderen, zoals <xref:System.Windows.PropertyChangedCallback>, worden gecombineerd.</xref:System.Windows.PropertyChangedCallback> Uiteindelijk het gedrag samenvoegen is afhankelijk van het metagegevenstype van eigenschap wordt gebruikt voor de onderdrukking, zodat het gedrag dat hier wordt beschreven voor de bestaande eigenschap metagegevens klassen die worden gebruikt door [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] afhankelijkheidseigenschappen. Zie voor meer informatie [metagegevens van de eigenschap afhankelijkheid](~/add/includes/ajax-current-ext-md.md) en [metagegevens van de eigenschap Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: forType
      type: System.Type
      description: "Het type waar deze afhankelijkheidseigenschap is overgenomen en waar u de opgegeven alternatieve metagegevens worden toegepast."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "De metagegevens toe te passen aan de afhankelijkheidseigenschap voor de overschrijvende type."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Er is een poging gedaan voor het onderdrukken van metagegevens voor een alleen-lezen afhankelijkheidseigenschap (dat de bewerking kan niet worden uitgevoerd met deze handtekening)."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Metagegevens is al ingesteld voor de afhankelijkheidseigenschap zoals zich dit op het opgegeven type."
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Leveringen alternatieve metagegevens voor een alleen-lezen afhankelijkheidseigenschap wanneer dit zich op exemplaren van een bepaald type bevindt, de metagegevens die is opgegeven in de registratie van de eigenschap initiële afhankelijkheid te overschrijven. U moet doorgeven de <xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref> voor de alleen-lezen afhankelijkheidseigenschap om te voorkomen dat een uitzondering."
  remarks: "Deze handtekening bevat onderliggende implementatie voor een afhankelijkheid voor alleen-lezen eigenschap-id (<xref:System.Windows.DependencyPropertyKey>) methode.</xref:System.Windows.DependencyPropertyKey> Als de metagegevens voor een van de alleen-lezen afhankelijkheidseigenschap te overschrijven, gebruikt u <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>       Metagegevens van de eigenschap afhankelijkheid moet worden vervangen voordat het systeem eigenschap maakt gebruik van de afhankelijkheidseigenschap. Dit is gelijk aan de tijd die specifieke objecten zijn gemaakt voor de klasse die de afhankelijkheidseigenschap registreert. Aanroepen naar <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>moet alleen worden uitgevoerd binnen de statische constructors van het type waarmee zelf als de `forType` parameter van deze methode of via vergelijkbare instantiëring.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Probeert metagegevens wijzigen nadat de exemplaren van het eigenaarstype bestaan niet uitzonderingen verhoogt, maar zal leiden tot inconsistent gedrag in het systeem eigenschap.       Nadat de metagegevens voor een onderdrukking bepaalde afgeleide klasse is gemaakt met deze methode, wordt in daaropvolgende pogingen worden gedaan voor het onderdrukken van metagegevens voor deze dezelfde afgeleide klasse een uitzondering veroorzaakt.       De opgegeven metagegevens is samengevoegd met de metagegevens van de eigenschap voor de afhankelijkheidseigenschap zoals zich dit in de eigenaar van het basistype. Alle kenmerken die zijn opgegeven in de metagegevens van de oorspronkelijke base bewaard; de kenmerken van de metagegevens van de base wordt overschreven door kenmerken die specifiek zijn gewijzigd in de nieuwe metagegevens. Enkele kenmerken zoals <xref:System.Windows.PropertyMetadata.DefaultValue%2A>worden vervangen als opgegeven in de nieuwe metagegevens.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Anderen, zoals <xref:System.Windows.PropertyChangedCallback>, worden gecombineerd.</xref:System.Windows.PropertyChangedCallback> Het gedrag samenvoegen, is afhankelijk van het metagegevenstype van eigenschap wordt gebruikt voor de onderdrukking. Zie voor meer informatie [metagegevens van de eigenschap afhankelijkheid](~/add/includes/ajax-current-ext-md.md) en [metagegevens van de eigenschap Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);
    parameters:
    - id: forType
      type: System.Type
      description: "Het type waar deze afhankelijkheidseigenschap is overgenomen en waar u de opgegeven alternatieve metagegevens worden toegepast."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "De metagegevens toe te passen aan de afhankelijkheidseigenschap voor de overschrijvende type."
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "De toegangssleutel voor een alleen-lezen afhankelijkheidseigenschap."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OwnerType
  id: OwnerType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hiermee wordt het type van het object dat de afhankelijkheidseigenschap geregistreerd bij de eigenschap system of zelf als eigenaar van de eigenschap toegevoegd."
  remarks: "Deze waarde is opgegeven tijdens de registratie van eigenschap. De eigenaar is het oorspronkelijke registreren dat in het geval van een <xref:System.Windows.DependencyProperty>id gegenereerd op basis van een <xref:System.Windows.DependencyProperty.Register%2A>aanroep of het type dat zelf toegevoegd als eigenaar in het geval van een <xref:System.Windows.DependencyProperty>id gegenereerd op basis van een <xref:System.Windows.DependencyProperty.AddOwner%2A>aanroepen.</xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty>       De OwnerType op een gegeven <xref:System.Windows.DependencyProperty>is onveranderbaar en kan niet worden `null` in een geldige <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty>"
  example:
  - "The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier. This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]"
  syntax:
    content: public Type OwnerType { get; }
    return:
      type: System.Type
      description: "Het type van het object dat de eigenschap is geregistreerd of zelf als eigenaar van de eigenschap toegevoegd."
  overload: System.Windows.DependencyProperty.OwnerType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.PropertyType
  id: PropertyType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hiermee wordt het type dat de afhankelijkheidseigenschap voor de waarde ervan gebruikt."
  remarks: "Deze eigenschap het type van de eigenschap waarde zoals opgegeven door de oorspronkelijke registratie van de eigenschap via rapporten de `propertyType` parameter. Net als bij de <xref:System.Windows.DependencyProperty.Name%2A>, het eigenschapstype van een afhankelijkheidseigenschap na de registratie is onveranderbaar.</xref:System.Windows.DependencyProperty.Name%2A>"
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the PropertyType. The type name string of the PropertyType is obtained from the returned <xref:System.Type>.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public Type PropertyType { get; }
    return:
      type: System.Type
      description: "De <xref:System.Type>van de eigenschapswaarde.</xref:System.Type>"
  overload: System.Windows.DependencyProperty.PropertyType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ReadOnly
  id: ReadOnly
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hiermee wordt een waarde die aangeeft of de afhankelijkheidseigenschap geïdentificeerd door dit <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> exemplaar is een alleen-lezen afhankelijkheidseigenschap."
  remarks: "Alleen-lezen afhankelijkheidseigenschappen zijn geregistreerd in het systeem eigenschap door het aanroepen van de <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>methode niet de <xref:System.Windows.DependencyProperty.Register%2A>methode.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> De bijgevoegde eigenschappen kunnen ook worden geregistreerd als alleen-lezen. Zie <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>       Alleen-lezen afhankelijkheidseigenschappen vereisen een <xref:System.Windows.DependencyPropertyKey>id in plaats van een <xref:System.Windows.DependencyProperty>id metagegevensbewerkingen zoals het onderdrukken van de metagegevens of als u de waarde uit te voeren.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey> Als u een verzameling hebt aangeschaft <xref:System.Windows.DependencyProperty>id&quot;s via een aanroep van <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>of een andere [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] die beschrijft de id&quot;s, controleert u de waarde van het kenmerk alleen-lezen voordat u probeert aan te roepen <xref:System.Windows.DependencyObject.SetValue%2A>of <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>met behulp van deze afhankelijkheid eigenschaps-id als invoerparameter, om te controleren of de afhankelijkheidseigenschap met de id is niet alleen-lezen.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyObject.SetValue%2A> </xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> </xref:System.Windows.DependencyProperty> Als de waarde van het kenmerk alleen-lezen `true` op een afhankelijkheidseigenschap is geen manier om op te halen van een verwijzing naar de <xref:System.Windows.DependencyPropertyKey>id van die afhankelijkheidseigenschap van de metagegevens of van de <xref:System.Windows.DependencyProperty>id; van de id moet beschikbaar zijn als een statisch veld om aan te roepen <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>tegen een alleen-lezen afhankelijkheidseigenschap.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey>       Wanneer u een aangepaste afhankelijkheidseigenschap maken en als alleen-lezen registreren, moet u alleen een get-accessor voor definiëren de [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] wrapper-eigenschap. Anders wordt hebben uw klasse een verwarrend objectmodel voor de eigenschap wrapper in vergelijking met de toegang tot de afhankelijkheidseigenschap back-ups maken. Zie voor meer informatie [aangepaste afhankelijkheidseigenschappen](~/add/includes/ajax-current-ext-md.md) of [alleen-lezen-Dependency Properties](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public bool ReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de afhankelijkheidseigenschap alleen-lezen is. anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.ReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  id: Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registreert een afhankelijkheidseigenschap met de opgegeven eigenschapsnaam, eigenschapstype en eigenaarstype."
  remarks: "Zie voor meer informatie over registratie van cacheafhankelijkheid eigenschap <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - >-
    [!code-cs[WPFAquariumSln#Register3Param](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#register3param)]
     [!code-vb[WPFAquariumSln#Register3Param](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#register3param)]
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de afhankelijkheidseigenschap te registreren. De naam moet uniek zijn binnen de naamruimte van de registratie van het eigenaarstype."
    - id: propertyType
      type: System.Type
      description: "Het type van de eigenschap."
    - id: ownerType
      type: System.Type
      description: "Het eigenaarstype die de afhankelijkheidseigenschap registreert."
    return:
      type: System.Windows.DependencyProperty
      description: "Een afhankelijkheid eigenschaps-id die moet worden gebruikt om de waarde van een <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> veld in uw klasse. Deze id wordt vervolgens gebruikt om te verwijzen naar de afhankelijkheidseigenschap later voor bewerkingen, zoals de waarde ervan programmatisch instellen of ophalen van metagegevens."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registreert een afhankelijkheidseigenschap met de opgegeven eigenschapsnaam, eigenschapstype, eigenaarstype en metagegevens van de eigenschap."
  remarks: "Zie voor meer informatie over registratie van cacheafhankelijkheid eigenschap <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de afhankelijkheidseigenschap te registreren."
    - id: propertyType
      type: System.Type
      description: "Het type van de eigenschap."
    - id: ownerType
      type: System.Type
      description: "Het eigenaarstype die de afhankelijkheidseigenschap registreert."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "De metagegevens van de eigenschap voor de afhankelijkheidseigenschap."
    return:
      type: System.Windows.DependencyProperty
      description: "Een afhankelijkheid eigenschaps-id die moet worden gebruikt om de waarde van een <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> veld in uw klasse. Deze id wordt vervolgens gebruikt om te verwijzen naar de afhankelijkheidseigenschap later voor bewerkingen, zoals de waarde ervan programmatisch instellen of ophalen van metagegevens."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registreert een afhankelijkheidseigenschap met de opgegeven eigenschapsnaam, eigenschapstype eigenaarstype, metagegevens van de eigenschap en een waarde validatie retouraanroep voor de eigenschap."
  remarks: "Zie voor meer informatie over registratie van cacheafhankelijkheid eigenschap <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).  \n  \n [!code-cs[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/csharp/DPCallbackOverride/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/visualbasic/DPCallbackOverride.sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de afhankelijkheidseigenschap te registreren."
    - id: propertyType
      type: System.Type
      description: "Het type van de eigenschap."
    - id: ownerType
      type: System.Type
      description: "Het eigenaarstype die de afhankelijkheidseigenschap registreert."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "De metagegevens van de eigenschap voor de afhankelijkheidseigenschap."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Een verwijzing naar een callback die moet worden uitgevoerd door een aangepaste validatie van de eigenschapswaarde afhankelijkheid dan typische typevalidatie."
    return:
      type: System.Windows.DependencyProperty
      description: "Een afhankelijkheid eigenschaps-id die moet worden gebruikt om de waarde van een <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> veld in uw klasse. Deze id wordt vervolgens gebruikt om te verwijzen naar de afhankelijkheidseigenschap later voor bewerkingen, zoals de waarde ervan programmatisch instellen of ophalen van metagegevens."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  id: RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registreert een gekoppelde eigenschap met de opgegeven eigenschapsnaam, eigenschapstype en eigenaarstype."
  remarks: "Een gekoppelde eigenschap is een eigenschap concept gedefinieerd door [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]Implements eigenschappen als afhankelijkheidseigenschappen gekoppeld. Omdat de [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] de bijgevoegde eigenschappen zijn afhankelijkheidseigenschappen, metagegevens toegepast die door de algemene eigenschap systeem kan worden gebruikt voor bewerkingen, zoals rapportage indeling kenmerken hebben. Zie voor meer informatie [gekoppeld eigenschappen overzicht](~/add/includes/ajax-current-ext-md.md).       Zie voor meer informatie over registratie van cacheafhankelijkheid eigenschap <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de afhankelijkheidseigenschap te registreren."
    - id: propertyType
      type: System.Type
      description: "Het type van de eigenschap."
    - id: ownerType
      type: System.Type
      description: "Het eigenaarstype die de afhankelijkheidseigenschap registreert."
    return:
      type: System.Windows.DependencyProperty
      description: "Een afhankelijkheid eigenschaps-id die moet worden gebruikt om de waarde van een <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> veld in uw klasse. Deze id wordt vervolgens gebruikt om te verwijzen naar de afhankelijkheidseigenschap later voor bewerkingen, zoals de waarde ervan programmatisch instellen of ophalen van metagegevens."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registreert een gekoppelde eigenschap met de opgegeven eigenschapsnaam, eigenschapstype, eigenaarstype en metagegevens van de eigenschap."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with RegisterAttached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with RegisterAttached even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use RegisterAttached to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de afhankelijkheidseigenschap te registreren."
    - id: propertyType
      type: System.Type
      description: "Het type van de eigenschap."
    - id: ownerType
      type: System.Type
      description: "Het eigenaarstype die de afhankelijkheidseigenschap registreert."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "De metagegevens van de eigenschap voor de afhankelijkheidseigenschap. Dit kunnen bijvoorbeeld de standaardwaarde, evenals andere kenmerken."
    return:
      type: System.Windows.DependencyProperty
      description: "Een afhankelijkheid eigenschaps-id die moet worden gebruikt om de waarde van een <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> veld in uw klasse. Deze id wordt vervolgens gebruikt om te verwijzen naar de afhankelijkheidseigenschap later voor bewerkingen, zoals de waarde ervan programmatisch instellen of ophalen van metagegevens."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registreert een gekoppelde eigenschap met het opgegeven eigenschapstype, eigenaarstype, metagegevens van de eigenschap en waarde validatie retouraanroep voor de eigenschap."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature. This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de afhankelijkheidseigenschap te registreren."
    - id: propertyType
      type: System.Type
      description: "Het type van de eigenschap."
    - id: ownerType
      type: System.Type
      description: "Het eigenaarstype die de afhankelijkheidseigenschap registreert."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "De metagegevens van de eigenschap voor de afhankelijkheidseigenschap. Dit kunnen bijvoorbeeld de standaardwaarde, evenals andere kenmerken."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Een verwijzing naar een callback die moet worden uitgevoerd door een aangepaste validatie van de eigenschapswaarde afhankelijkheid dan typische typevalidatie."
    return:
      type: System.Windows.DependencyProperty
      description: "Een afhankelijkheid eigenschaps-id die moet worden gebruikt om de waarde van een <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> veld in uw klasse. Deze id wordt vervolgens gebruikt om te verwijzen naar de afhankelijkheidseigenschap later voor bewerkingen, zoals de waarde ervan programmatisch instellen of ophalen van metagegevens."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registreert een alleen-lezen gekoppelde eigenschap, met het opgegeven eigenschapstype, eigenaarstype en metagegevens van de eigenschap."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de afhankelijkheidseigenschap te registreren."
    - id: propertyType
      type: System.Type
      description: "Het type van de eigenschap."
    - id: ownerType
      type: System.Type
      description: "Het eigenaarstype die de afhankelijkheidseigenschap registreert."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "De metagegevens van de eigenschap voor de afhankelijkheidseigenschap."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Een sleutel van de afhankelijkheid eigenschap die moet worden gebruikt om de waarde van een statisch veld voor de alleen-lezen instellen in uw klasse, vervolgens gebruikt wordt voor de afhankelijkheidseigenschap later naar verwijzen."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registreert een alleen-lezen gekoppelde eigenschap, met het opgegeven eigenschapstype, eigenaarstype, metagegevens van de eigenschap en een retouraanroep voor validatie."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de afhankelijkheidseigenschap te registreren."
    - id: propertyType
      type: System.Type
      description: "Het type van de eigenschap."
    - id: ownerType
      type: System.Type
      description: "Het eigenaarstype die de afhankelijkheidseigenschap registreert."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "De metagegevens van de eigenschap voor de afhankelijkheidseigenschap."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Een verwijzing naar een gebruiker gemaakte callbackfunctie die moet worden uitgevoerd door een aangepaste validatie van de eigenschapswaarde afhankelijkheid dan typische typevalidatie."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Een sleutel van de afhankelijkheid eigenschap die moet worden gebruikt om de waarde van een statisch veld voor de alleen-lezen instellen in uw klasse, die vervolgens wordt gebruikt om te verwijzen naar de afhankelijkheidseigenschap."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registreert een alleen-lezen afhankelijkheidseigenschap met het opgegeven eigenschapstype, eigenaarstype en metagegevens van de eigenschap."
  remarks: "Deze methode retourneert het type <xref:System.Windows.DependencyPropertyKey>, terwijl <xref:System.Windows.DependencyProperty.RegisterAttached%2A>retourneert het type <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Normaal gesproken worden de sleutels die alleen-lezen eigenschappen vertegenwoordigen niet openbaar gemaakt, omdat de sleutels kunnen worden gebruikt om de waarde van de eigenschap afhankelijkheid door het aanroepen van <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> Het ontwerp van de klasse is van invloed op uw behoeften, maar het is raadzaam om te beperken van de toegang en de zichtbaarheid van een <xref:System.Windows.DependencyPropertyKey>alleen de delen van uw code die nodig zijn voor die afhankelijkheidseigenschap instellen als onderdeel van de klasse of toepassing logica.</xref:System.Windows.DependencyPropertyKey> Het is ook raadzaam een afhankelijkheid eigenschaps-id voor de afhankelijkheidseigenschap alleen-lezen-beschikbaar te stellen bij het blootstellen van de waarde van <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>als een `public static readonly` op uw klasse</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       Alleen-lezen afhankelijkheidseigenschappen zijn een vrij normale scenario beide in de bestaande [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] en voor scenario&quot;s voor aanpassingen, omdat andere [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] -functies vereisen mogelijk een afhankelijkheidseigenschap zelfs als die eigenschap is niet bedoeld als worden ingesteld door aanroepfuncties. U kunt de waarde van een alleen-lezen afhankelijkheidseigenschap gebruiken als basis voor andere systeembewerkingen eigenschap die een afhankelijkheidseigenschap zoals als uitgangspunt nemen een <xref:System.Windows.Trigger>op de afhankelijkheidseigenschap in een style.</xref:System.Windows.Trigger>       Zie voor meer informatie over registratie van cacheafhankelijkheid eigenschap <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an `AquariumSize` dependency property as read-only. The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`. Also, a wrapper is created for `AquariumSize`, with only a get accessor.  \n  \n [!code-cs[WPFAquariumSln#RODP](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#rodp)]\n [!code-vb[WPFAquariumSln#RODP](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#rodp)]"
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de afhankelijkheidseigenschap te registreren."
    - id: propertyType
      type: System.Type
      description: "Het type van de eigenschap."
    - id: ownerType
      type: System.Type
      description: "Het eigenaarstype die de afhankelijkheidseigenschap registreert."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "De metagegevens van de eigenschap voor de afhankelijkheidseigenschap."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Een sleutel van de afhankelijkheid eigenschap die moet worden gebruikt om de waarde van een statisch veld voor de alleen-lezen instellen in uw klasse, die vervolgens wordt gebruikt om te verwijzen naar de afhankelijkheidseigenschap."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Registreert een alleen-lezen afhankelijkheidseigenschap met het opgegeven eigenschapstype, eigenaarstype, metagegevens van de eigenschap en een retouraanroep voor validatie."
  remarks: "Deze methode retourneert het type <xref:System.Windows.DependencyPropertyKey>, terwijl <xref:System.Windows.DependencyProperty.RegisterAttached%2A>retourneert het type <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Normaal gesproken worden de sleutels die alleen-lezen eigenschappen vertegenwoordigen niet openbaar gemaakt, omdat de sleutels kunnen worden gebruikt om de waarde van de eigenschap afhankelijkheid door het aanroepen van <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> Het ontwerp van de klasse is van invloed op uw behoeften, maar het is raadzaam om te beperken van de toegang en de zichtbaarheid van een <xref:System.Windows.DependencyPropertyKey>alleen de delen van uw code die nodig zijn voor die afhankelijkheidseigenschap instellen als onderdeel van de klasse of toepassing logica.</xref:System.Windows.DependencyPropertyKey> Het is ook raadzaam een afhankelijkheid eigenschaps-id voor de afhankelijkheidseigenschap alleen-lezen-beschikbaar te stellen bij het blootstellen van de waarde van <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>als een `public static readonly` op uw klasse</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       Alleen-lezen afhankelijkheidseigenschappen zijn een vrij normale scenario. U kunt de waarde van een alleen-lezen afhankelijkheidseigenschap gebruiken als basis voor andere systeembewerkingen eigenschap die een afhankelijkheidseigenschap zoals als uitgangspunt nemen een <xref:System.Windows.Trigger>op de afhankelijkheidseigenschap in een style.</xref:System.Windows.Trigger>       Zie voor meer informatie over registratie van cacheafhankelijkheid eigenschap <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>       Validatie van een alleen-lezen afhankelijkheidseigenschap mogelijk minder belangrijk zijn. De niet-openbare toegangsniveau dat u voor de sleutel opgeeft vermindert de kans voor willekeurige ongeldige invoer."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "De naam van de afhankelijkheidseigenschap te registreren."
    - id: propertyType
      type: System.Type
      description: "Het type van de eigenschap."
    - id: ownerType
      type: System.Type
      description: "Het eigenaarstype die de afhankelijkheidseigenschap registreert."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "De metagegevens van de eigenschap voor de afhankelijkheidseigenschap."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Een verwijzing naar een gebruiker gemaakte callbackfunctie die moet worden uitgevoerd door een aangepaste validatie van de eigenschapswaarde afhankelijkheid dan typische typevalidatie."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Een sleutel van de afhankelijkheid eigenschap die moet worden gebruikt om de waarde van een statisch veld voor de alleen-lezen instellen in uw klasse, vervolgens gebruikt wordt voor de afhankelijkheidseigenschap later naar verwijzen."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ToString
  id: ToString
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Retourneert de tekenreeksrepresentatie van de afhankelijkheidseigenschap."
  remarks: "Deze implementatie retourneert de <xref:System.Windows.DependencyProperty.Name%2A>eigenschapswaarde.</xref:System.Windows.DependencyProperty.Name%2A>"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "De tekenreeksrepresentatie van de afhankelijkheidseigenschap."
  overload: System.Windows.DependencyProperty.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.UnsetValue
  id: UnsetValue
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
  type: Field
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hiermee geeft u een statische waarde die wordt gebruikt door de [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] eigenschap system plaats <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> om aan te geven dat de eigenschap bestaat, maar geen bijbehorende waarde door het systeem eigenschap ingesteld heeft."
  remarks: "UnsetValue is een sentinel-waarde die wordt gebruikt voor scenario&quot;s waar de [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] eigenschap systeem kan niet vaststellen een aangevraagde <xref:System.Windows.DependencyProperty>waarde.</xref:System.Windows.DependencyProperty> UnsetValue wordt gebruikt in plaats `null`omdat `null` kan de waarde van een geldige eigenschap, evenals een geldige (en vaak gebruikte) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       UnsetValue wordt nooit buiten de <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>.</xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> geretourneerd Als u aanroept <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>op een afhankelijkheidseigenschap op een <xref:System.Windows.DependencyObject>exemplaar, een van de volgende van toepassing is: - een afhankelijkheidseigenschap heeft een standaardwaarde tot stand gebracht in metagegevens en dat de waarde wordt geretourneerd.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> Deze waarde kan afkomstig zijn van <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</xref:System.Windows.DependencyProperty.DefaultMetadata%2A>      -Een andere waarde door het systeem eigenschap tot stand is gebracht en de standaardwaarde niet langer relevant is. Zie voor meer informatie [afhankelijkheid eigenschap waarde prioriteit](~/add/includes/ajax-current-ext-md.md).       Instellen van een <xref:System.Windows.PropertyMetadata.DefaultValue%2A>van UnsetValue is specifiek niet toegestaan.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>retourneert UnsetValue wanneer de aangevraagde eigenschap niet lokaal is ingesteld.</xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>       UnsetValue heeft een speciale betekenis als gebruikt als de retourwaarde van een <xref:System.Windows.CoerceValueCallback>.</xref:System.Windows.CoerceValueCallback> Zie voor meer informatie [afhankelijkheid eigenschap retouraanroepen en validatie](~/add/includes/ajax-current-ext-md.md).       Als u een database afhankelijk, houd er rekening mee UnsetValue komt niet overeen met <xref:System.DBNull.Value>, op soortgelijke wijze aan de <xref:System.DBNull.Value>komt niet overeen met een null-waarde true.</xref:System.DBNull.Value> </xref:System.DBNull.Value>"
  syntax:
    content: public static readonly object UnsetValue;
    return:
      type: System.Object
      description: "Moet worden toegevoegd."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  id: ValidateValueCallback
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Hiermee wordt de waarde validatie retouraanroep voor de afhankelijkheidseigenschap."
  remarks: "Deze eigenschap bevat `null` voor elke afhankelijkheidseigenschap met geen geregistreerde validatie-callback.       Waarde retouraanroepen in een statische zin moeten fungeren niet valideren: validatie toegepast via de <xref:System.Windows.ValidateValueCallback>kan niet bepalen of de opgegeven waarde ongeldig voor een bepaalde instantie is.</xref:System.Windows.ValidateValueCallback> De callback kan alleen bepalen of alle objecten die beschikken over de afhankelijkheidseigenschap moeten of moeten niet akkoord met de opgegeven waarde als geldig. Als u valideren die afhankelijk is wilt van de waarden van andere afhankelijkheidseigenschappen van een bepaalde instantie, gebruik weten een <xref:System.Windows.CoerceValueCallback>in plaats daarvan.</xref:System.Windows.CoerceValueCallback> De <xref:System.Windows.CoerceValueCallback>is geregistreerd als onderdeel van de metagegevens van de eigenschap afhankelijkheid, in plaats van rechtstreeks in de eigenschaps-id van afhankelijkheid.</xref:System.Windows.CoerceValueCallback> Zie voor meer informatie [afhankelijkheid eigenschap retouraanroepen en validatie](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.ValidateValueCallback ValidateValueCallback { get; }
    return:
      type: System.Windows.ValidateValueCallback
      description: "De waarde validatie retouraanroep voor deze afhankelijkheidseigenschap als in de <code> validateValueCallback </code> parameter in de oorspronkelijke eigenschap registratie van cacheafhankelijkheid."
  overload: System.Windows.DependencyProperty.ValidateValueCallback*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty.DefaultMetadata
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
- uid: System.Windows.DependencyObjectType
  parent: System.Windows
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObjectType
  fullName: System.Windows.DependencyObjectType
- uid: System.Windows.DependencyProperty.GlobalIndex
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
- uid: System.Windows.DependencyProperty.Name
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
- uid: System.Windows.DependencyPropertyKey
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyKey
  nameWithType: DependencyPropertyKey
  fullName: System.Windows.DependencyPropertyKey
- uid: System.Windows.DependencyProperty.OwnerType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.ValidateValueCallback
  parent: System.Windows
  isExternal: false
  name: ValidateValueCallback
  nameWithType: ValidateValueCallback
  fullName: System.Windows.ValidateValueCallback
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.ToString
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
- uid: System.Windows.DependencyProperty.UnsetValue
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
- uid: System.Windows.DependencyProperty.AddOwner*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner
  nameWithType: DependencyProperty.AddOwner
- uid: System.Windows.DependencyProperty.DefaultMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode
  nameWithType: DependencyProperty.GetHashCode
- uid: System.Windows.DependencyProperty.GetMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata
  nameWithType: DependencyProperty.GetMetadata
- uid: System.Windows.DependencyProperty.GlobalIndex*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType
  nameWithType: DependencyProperty.IsValidType
- uid: System.Windows.DependencyProperty.IsValidValue*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue
  nameWithType: DependencyProperty.IsValidValue
- uid: System.Windows.DependencyProperty.Name*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
- uid: System.Windows.DependencyProperty.OverrideMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata
  nameWithType: DependencyProperty.OverrideMetadata
- uid: System.Windows.DependencyProperty.OwnerType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register
  nameWithType: DependencyProperty.Register
- uid: System.Windows.DependencyProperty.RegisterAttached*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached
  nameWithType: DependencyProperty.RegisterAttached
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly
  nameWithType: DependencyProperty.RegisterAttachedReadOnly
- uid: System.Windows.DependencyProperty.RegisterReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly
  nameWithType: DependencyProperty.RegisterReadOnly
- uid: System.Windows.DependencyProperty.ToString*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString
  nameWithType: DependencyProperty.ToString
- uid: System.Windows.DependencyProperty.ValidateValueCallback*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
