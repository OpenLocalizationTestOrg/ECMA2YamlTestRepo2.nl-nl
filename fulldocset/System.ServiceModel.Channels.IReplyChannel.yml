### YamlMime:ManagedReference
items:
- uid: System.ServiceModel.Channels.IReplyChannel
  id: IReplyChannel
  children:
  - System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)
  - System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  - System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  - System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  - System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)
  - System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)
  - System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)
  - System.ServiceModel.Channels.IReplyChannel.LocalAddress
  - System.ServiceModel.Channels.IReplyChannel.ReceiveRequest
  - System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)
  - System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)
  - System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)
  langs:
  - csharp
  name: IReplyChannel
  nameWithType: IReplyChannel
  fullName: System.ServiceModel.Channels.IReplyChannel
  type: Interface
  summary: "Hiermee definieert u de interface die een kanaal moet worden geïmplementeerd op de ontvangende zijde van een aanvraag-/ antwoordcommunicatie tussen de messaging-eindpunten."
  remarks: "De interface bieden voor IReplyChannel bevat synchrone en asynchrone varianten van een <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>methode retourneren een <xref:System.ServiceModel.Channels.RequestContext>die kan worden gebruikt voor het maken van antwoorden op aanvragen ontvangen.</xref:System.ServiceModel.Channels.RequestContext> </xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>       Het contract bevat synchrone en asynchrone varianten van functionaliteit probeer te ontvangen en de wachttijd voor een bericht ontvangen.       Een IReplyChannel is niet noodzakelijkerwijs gebonden aan één afzender. Andere kanalen en kanaal interfaces bieden correlatie tussen de afzender en de antwoord-kanaal, maar de basiscontract maakt geen dergelijke beperking.       Het pull-model wordt gebruikt met een IReplyChannel om berichten te ontvangen. Dit model bestaat uit aanroepen <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>(of een van de varianten) en vervolgens wachten op een bericht moet worden uitgevoerd.</xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>"
  syntax:
    content: 'public interface IReplyChannel : System.ServiceModel.Channels.IChannel'
  implements:
  - System.ServiceModel.Channels.IChannel
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)
  id: BeginReceiveRequest(System.AsyncCallback,System.Object)
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: BeginReceiveRequest(AsyncCallback,Object)
  nameWithType: IReplyChannel.BeginReceiveRequest(AsyncCallback,Object)
  fullName: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(AsyncCallback,Object)
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "Een asynchrone bewerking voor het ontvangen van een beschikbare aanvraag met een standaardtime-out begint."
  remarks: "De methode BeginReceiveRequest implementeert het standaardpatroon voor het aanroepen van <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest>asynchroon.</xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest> De standaardtime-out is 1 minuut. Als een time-out receive op de binding die is gebruikt voor het configureren van de verbinding is ingesteld, wordt die waarde gebruikt. Gebruik <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>Als u wilt een expliciete time-out opgeven met de aanroep die deze andere waarden vervangt.</xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>       Als het request-bericht ontvangen groter dat de maximale toegestaan door de binding wordt gebruikt berichtgrootte, is een <xref:System.ServiceModel.QuotaExceededException>gegenereerd.</xref:System.ServiceModel.QuotaExceededException> De maximale berichtgrootte is ingesteld door de <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A>eigenschap.</xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> De standaardwaarde is 65536 bytes."
  example:
  - "The following code illustrates how to implement this method:  \n  \n [!code-cs[S_UE_MessageInterceptor#1](~/add/codesnippet/csharp/b714b94c-13fc-4c03-a779-_1.cs)]"
  syntax:
    content: public IAsyncResult BeginReceiveRequest (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "De <xref:System.AsyncCallback>gemachtigde die de melding van de asynchrone ontvangt ontvangen dat een aanvraag is voltooid.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Een object dat is opgegeven door de toepassing die informatie over de status die is gekoppeld aan de asynchrone ontvangst van een aanvraagbewerking bevat."
    return:
      type: System.IAsyncResult
      description: "De <xref:System.IAsyncResult>dat verwijst naar de asynchrone ontvangst van de aanvraag.</xref:System.IAsyncResult>"
  overload: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  id: BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: BeginReceiveRequest(TimeSpan,AsyncCallback,Object)
  nameWithType: IReplyChannel.BeginReceiveRequest(TimeSpan,AsyncCallback,Object)
  fullName: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(TimeSpan,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "Een asynchrone bewerking voor het ontvangen van een beschikbare aanvraag met een opgegeven time-out begint."
  remarks: "De methode BeginReceiveRequest implementeert het standaardpatroon voor het aanroepen van <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29>asynchroon.</xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29> De ingestelde time-out voor deze methode overschrijft een time-out receive is ingesteld op de binding die wordt gebruikt voor de verbinding wordt geconfigureerd.       Als het request-bericht ontvangen groter dat de maximale toegestaan door de binding wordt gebruikt berichtgrootte, is een <xref:System.ServiceModel.QuotaExceededException>gegenereerd.</xref:System.ServiceModel.QuotaExceededException> De maximale berichtgrootte is ingesteld door de <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A>eigenschap.</xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> De standaardwaarde is 65536 bytes."
  example:
  - "The following code illustrates how to implement this method:  \n  \n [!code-cs[S_UE_MessageInterceptor#2](~/add/codesnippet/csharp/6f48cd8d-c63c-4708-86c4-_1.cs)]"
  syntax:
    content: public IAsyncResult BeginReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "De <xref:System.TimeSpan>die aangeeft dat het interval van de wachttijd voor de ontvangst van een aanvraag beschikbaar.</xref:System.TimeSpan>"
    - id: callback
      type: System.AsyncCallback
      description: "De <xref:System.AsyncCallback>gemachtigde die de melding van de asynchrone ontvangt ontvangen dat een aanvraag is voltooid.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Een object dat is opgegeven door de toepassing die informatie over de status die is gekoppeld aan de asynchrone ontvangst van een aanvraagbewerking bevat."
    return:
      type: System.IAsyncResult
      description: "De <xref:System.IAsyncResult>dat verwijst naar de asynchrone ontvangst van de aanvraag.</xref:System.IAsyncResult>"
  overload: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  id: BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: BeginTryReceiveRequest(TimeSpan,AsyncCallback,Object)
  nameWithType: IReplyChannel.BeginTryReceiveRequest(TimeSpan,AsyncCallback,Object)
  fullName: System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(TimeSpan,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "Een asynchrone bewerking voor het ontvangen van een aanvraagbericht met een opgegeven time-out en een object met de status gekoppeld begint."
  remarks: "De asynchrone methode voor BeginTryReceiveRequest gebruikt als u de verwerking van de toepassing om door te gaan zonder te wachten. Gebruik een van de synchrone <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29>methoden wanneer het is acceptabel voor de huidige thread geblokkeerd tijdens het antwoorden op het request-bericht of totdat de time-outinterval is overschreden.</xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29>       Deze methode ontvangt een melding via een retouraanroep van de identiteit van de gebeurtenis-handler voor de bewerking. De bewerking is niet voltooid, totdat een bericht beschikbaar in het kanaal of time-out optreedt."
  example:
  - "The following code illustrates how to implement this method:  \n  \n [!code-cs[S_UE_MessageInterceptor#5](~/add/codesnippet/csharp/cdb71277-0f0f-4e22-85af-_1.cs)]"
  syntax:
    content: public IAsyncResult BeginTryReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "De <xref:System.TimeSpan>die aangeeft hoe lang de bewerking receive-aanvraag heeft voltooid voordat een time-out opgetreden en het retourneren van <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.TimeSpan>"
    - id: callback
      type: System.AsyncCallback
      description: "De <xref:System.AsyncCallback>gemachtigde die de melding van de asynchrone ontvangt ontvangen dat een aanvraag is voltooid.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Een object dat is opgegeven door de toepassing die informatie over de status die is gekoppeld aan de asynchrone ontvangst van een aanvraagbewerking bevat."
    return:
      type: System.IAsyncResult
      description: "De <xref:System.IAsyncResult>dat verwijst naar de asynchrone aanvraag ontvangstbewerking.</xref:System.IAsyncResult>"
  overload: System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  id: BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: BeginWaitForRequest(TimeSpan,AsyncCallback,Object)
  nameWithType: IReplyChannel.BeginWaitForRequest(TimeSpan,AsyncCallback,Object)
  fullName: System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(TimeSpan,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "Een asynchrone aanvraagbewerking met een opgegeven time-out en een object met de status gekoppeld begint."
  remarks: "Gebruik de synchrone <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29>methode wanneer het is acceptabel voor de huidige thread geblokkeerd tijdens het wachten op een aanvraagbericht moet worden uitgevoerd in de wachtrij.</xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> De thread is geblokkeerd om aan de opgegeven `timeout`.       Deze methode ontvangt een melding via een retouraanroep van de identiteit van de gebeurtenis-handler voor de bewerking. De bewerking is niet voltooid, totdat u een bericht beschikbaar in het kanaal of time-out optreedt."
  example:
  - "The following code illustrates how to implement this method:  \n  \n [!code-cs[S_UE_MessageInterceptor#10](~/add/codesnippet/csharp/80573a5a-f5c0-4be0-a875-_1.cs)]"
  syntax:
    content: public IAsyncResult BeginWaitForRequest (TimeSpan timeout, AsyncCallback callback, object state);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "De <xref:System.TimeSpan>die aangeeft dat het interval van de wachttijd voor de ontvangst van een aanvraag beschikbaar.</xref:System.TimeSpan>"
    - id: callback
      type: System.AsyncCallback
      description: "De <xref:System.AsyncCallback>gemachtigde die de melding van de asynchrone ontvangt ontvangen dat een aanvraag is voltooid.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Een object dat is opgegeven door de toepassing die informatie over de status die is gekoppeld aan de asynchrone ontvangst van een aanvraagbewerking bevat."
    return:
      type: System.IAsyncResult
      description: "De <xref:System.IAsyncResult>dat verwijst naar de asynchrone bewerking moet worden gewacht op een aanvraagbericht moet worden uitgevoerd.</xref:System.IAsyncResult>"
  overload: System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)
  id: EndReceiveRequest(System.IAsyncResult)
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: EndReceiveRequest(IAsyncResult)
  nameWithType: IReplyChannel.EndReceiveRequest(IAsyncResult)
  fullName: System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(IAsyncResult)
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "Een asynchrone bewerking voor het ontvangen van een beschikbare aanvraag voltooid."
  remarks: "Als het request-bericht ontvangen groter dat de maximale toegestaan door de binding wordt gebruikt berichtgrootte, is een <xref:System.ServiceModel.QuotaExceededException>gegenereerd.</xref:System.ServiceModel.QuotaExceededException> De maximale berichtgrootte is ingesteld door de <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A>eigenschap.</xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> De standaardwaarde is 65536 bytes."
  example:
  - "The following code illustrates how to implement this method:  \n  \n [!code-cs[S_UE_MessageInterceptor#3](~/add/codesnippet/csharp/c3561a14-d2f1-46f1-99c2-_1.cs)]"
  syntax:
    content: public System.ServiceModel.Channels.RequestContext EndReceiveRequest (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "De <xref:System.IAsyncResult>geretourneerd door een aanroep naar de <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive*>methode.</xref:System.ServiceModel.Channels.IInputChannel.BeginReceive*> </xref:System.IAsyncResult>"
    return:
      type: System.ServiceModel.Channels.RequestContext
      description: "De <xref:System.ServiceModel.Channels.RequestContext>gebruikt voor het opstellen van een antwoord op de aanvraag.</xref:System.ServiceModel.Channels.RequestContext>"
  overload: System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)
  id: EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: EndTryReceiveRequest(IAsyncResult,RequestContext)
  nameWithType: IReplyChannel.EndTryReceiveRequest(IAsyncResult,RequestContext)
  fullName: System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(IAsyncResult,RequestContext)
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "De opgegeven asynchrone bewerking voor het ontvangen van een aanvraagbericht voltooit."
  remarks: ''
  example:
  - "The following code illustrates how to implement this method:  \n  \n [!code-cs[S_UE_MessageInterceptor#6](~/add/codesnippet/csharp/2c432ec9-bfc6-46e4-8a1c-_1.cs)]"
  syntax:
    content: public bool EndTryReceiveRequest (IAsyncResult result, out System.ServiceModel.Channels.RequestContext context);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "De <xref:System.IAsyncResult>geretourneerd door een aanroep naar de &lt;xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt; methode.</xref:System.IAsyncResult>"
    - id: context
      type: System.ServiceModel.Channels.RequestContext
      description: "De <xref:System.ServiceModel.Channels.RequestContext>ontvangen.</xref:System.ServiceModel.Channels.RequestContext>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als u een bericht wordt ontvangen voordat het opgegeven interval is verstreken tijd; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)
  id: EndWaitForRequest(System.IAsyncResult)
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: EndWaitForRequest(IAsyncResult)
  nameWithType: IReplyChannel.EndWaitForRequest(IAsyncResult)
  fullName: System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(IAsyncResult)
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "De bewerking opgegeven asynchrone bericht in de wachttijd voor een aanvraag voltooid."
  remarks: ''
  example:
  - "The following code illustrates how to implement this method:  \n  \n [!code-cs[S_UE_MessageInterceptor#11](~/add/codesnippet/csharp/fc7d466d-2acc-417f-aa1b-_1.cs)]"
  syntax:
    content: public bool EndWaitForRequest (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "De <xref:System.IAsyncResult>die identificeert de &lt;xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt; bewerking is voltooid, en vanaf welke u wilt ophalen van een eindresultaat.</xref:System.IAsyncResult>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als een aanvraag wordt ontvangen voordat het opgegeven interval is verstreken tijd; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.LocalAddress
  id: LocalAddress
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: LocalAddress
  nameWithType: IReplyChannel.LocalAddress
  fullName: System.ServiceModel.Channels.IReplyChannel.LocalAddress
  type: Property
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "Hiermee haalt u het adres waarop dit kanaal antwoord berichten ontvangt."
  remarks: ''
  example:
  - "The following code illustrates how to implement this property:  \n  \n [!code-cs[S_UE_MessageInterceptor#0](~/add/codesnippet/csharp/p-system.servicemodel.ch_2_1.cs)]"
  syntax:
    content: public System.ServiceModel.EndpointAddress LocalAddress { get; }
    return:
      type: System.ServiceModel.EndpointAddress
      description: "De <xref:System.ServiceModel.EndpointAddress>waarop dit kanaal antwoord ontvangt berichten.</xref:System.ServiceModel.EndpointAddress>"
  overload: System.ServiceModel.Channels.IReplyChannel.LocalAddress*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest
  id: ReceiveRequest
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: ReceiveRequest()
  nameWithType: IReplyChannel.ReceiveRequest()
  fullName: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest()
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "Retourneert de context van de aanvraag is ontvangen, indien beschikbaar. Als u een context die niet beschikbaar is, wacht totdat er een beschikbaar is."
  remarks: "<xref:System.ServiceModel.Channels.RequestContext>het aanvraagbericht en een mechanisme voor het bericht beantwoorden ingekapseld.</xref:System.ServiceModel.Channels.RequestContext>       ReceiveRequest kan meerdere keren worden aangeroepen of gelijktijdig. Er is slechts één aanroep van ReceiveRequest voltooid per aanvraag ontvangen.       Als het request-bericht ontvangen groter dat de maximale toegestaan door de binding wordt gebruikt berichtgrootte, is een <xref:System.ServiceModel.QuotaExceededException>gegenereerd.</xref:System.ServiceModel.QuotaExceededException> De maximale berichtgrootte is ingesteld door de <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A>eigenschap.</xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> De standaardwaarde is 65536 bytes."
  example:
  - "The following code illustrates how to implement this method:  \n  \n [!code-cs[S_UE_MessageInterceptor#7](~/add/codesnippet/csharp/m-system.servicemodel.ch_9_1.cs)]"
  syntax:
    content: public System.ServiceModel.Channels.RequestContext ReceiveRequest ();
    parameters: []
    return:
      type: System.ServiceModel.Channels.RequestContext
      description: "De <xref:System.ServiceModel.Channels.RequestContext>gebruikt voor het opstellen van antwoorden.</xref:System.ServiceModel.Channels.RequestContext>"
  overload: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)
  id: ReceiveRequest(System.TimeSpan)
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: ReceiveRequest(TimeSpan)
  nameWithType: IReplyChannel.ReceiveRequest(TimeSpan)
  fullName: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(TimeSpan)
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "Retourneert de context van de aanvraag is ontvangen, indien beschikbaar. Als u een context die niet beschikbaar is, wacht totdat er een beschikbaar is."
  remarks: "<xref:System.ServiceModel.Channels.RequestContext>het aanvraagbericht en een mechanisme voor het bericht beantwoorden ingekapseld.</xref:System.ServiceModel.Channels.RequestContext>       <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>kan meerdere keren worden aangeroepen of gelijktijdig.</xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> Slechts één <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>aanroep is voltooid per aanvraag ontvangen.</xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>       Als het request-bericht ontvangen groter dat de maximale toegestaan door de binding wordt gebruikt berichtgrootte, is een <xref:System.ServiceModel.QuotaExceededException>gegenereerd.</xref:System.ServiceModel.QuotaExceededException> De maximale berichtgrootte is ingesteld door de <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A>eigenschap.</xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> De standaardwaarde is 65536 bytes."
  example:
  - "The following code illustrates how to implement this method:  \n  \n [!code-cs[S_UE_MessageInterceptor#8](~/add/codesnippet/csharp/m-system.servicemodel.ch_3_1.cs)]"
  syntax:
    content: public System.ServiceModel.Channels.RequestContext ReceiveRequest (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "De <xref:System.TimeSpan>die aangeeft hoe lang de ontvangst van een aanvraagbewerking heeft voltooid voordat een time-out opgetreden en het retourneren van <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.TimeSpan>"
    return:
      type: System.ServiceModel.Channels.RequestContext
      description: "De <xref:System.ServiceModel.Channels.RequestContext>gebruikt voor het opstellen van antwoorden.</xref:System.ServiceModel.Channels.RequestContext>"
  overload: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)
  id: TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: TryReceiveRequest(TimeSpan,RequestContext)
  nameWithType: IReplyChannel.TryReceiveRequest(TimeSpan,RequestContext)
  fullName: System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(TimeSpan,RequestContext)
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "Retourneert een waarde die aangeeft of een aanvraag wordt ontvangen voor een opgegeven interval tijd is verstreken."
  remarks: "Gebruik TryReceiveRequest wanneer het is acceptabel voor de huidige thread geblokkeerd tijdens het wachten op een aanvraagbericht moet worden uitgevoerd in de wachtrij. De thread is geblokkeerd om aan de opgegeven `timeout`. Als u de verwerking van de toepassing om door te gaan zonder te wachten moet, gebruikt u de asynchrone <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>methode.</xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>"
  example:
  - "The following code illustrates how to implement this method:  \n  \n [!code-cs[S_UE_MessageInterceptor#4](~/add/codesnippet/csharp/78581c5e-1028-4e54-ba3b-_1.cs)]"
  syntax:
    content: public bool TryReceiveRequest (TimeSpan timeout, out System.ServiceModel.Channels.RequestContext context);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "De <xref:System.TimeSpan>die aangeeft hoe lang de ontvangst van een aanvraagbewerking heeft voltooid voordat een time-out opgetreden en het retourneren van <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.TimeSpan>"
    - id: context
      type: System.ServiceModel.Channels.RequestContext
      description: "De <xref:System.ServiceModel.Channels.RequestContext>ontvangen.</xref:System.ServiceModel.Channels.RequestContext>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als u een bericht wordt ontvangen voordat het opgegeven interval is verstreken tijd; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)
  id: WaitForRequest(System.TimeSpan)
  parent: System.ServiceModel.Channels.IReplyChannel
  langs:
  - csharp
  name: WaitForRequest(TimeSpan)
  nameWithType: IReplyChannel.WaitForRequest(TimeSpan)
  fullName: System.ServiceModel.Channels.IReplyChannel.WaitForRequest(TimeSpan)
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel.Channels
  summary: "Retourneert een waarde die aangeeft of een bericht wordt ontvangen voordat een opgegeven interval is verstreken tijd."
  remarks: "Het aanroepen van WaitForRequest resulteert niet in een bericht wordt ontvangen of op een manier worden verwerkt.       De <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>methode bestaat voornamelijk voor transactionele scenario&quot;s waarbij de gebruiker wil het bericht met een transactie.</xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> Wanneer u het zojuist <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>Normaal gesproken voor dit door de gebruiker moet de transactie en vervolgens aanroepen <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>en hopen dat het bericht wordt ontvangen voordat de transactie een time-out optreedt, die misschien niet mogelijk.</xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> </xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>       In plaats daarvan de gebruiker kan aanroepen WaitForRequest en geef de time-out (zelfs oneindige) wanneer een bericht binnenkomt ze kunnen en open vervolgens de transactie aanroepen <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>en er zeker van te zijn dat ze het bericht krijgen kunnen terug voordat de transactie is verlopen.</xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A>       Gebruik WaitForRequest wanneer het is acceptabel voor de huidige thread geblokkeerd tijdens het wachten op een bericht moet worden uitgevoerd in de wachtrij. De thread is geblokkeerd om aan de opgegeven `timeout`. Als u de verwerking van de toepassing om door te gaan zonder te wachten moet, gebruikt u de asynchrone <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>methode.</xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>"
  example:
  - "The following code illustrates how to implement this method:  \n  \n [!code-cs[S_UE_MessageInterceptor#9](~/add/codesnippet/csharp/m-system.servicemodel.ch_6_1.cs)]"
  syntax:
    content: public bool WaitForRequest (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "De <xref:System.TimeSpan>die aangeeft hoe lang een aanvraag bewerking heeft voltooid voordat een time-out opgetreden en het retourneren van <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.TimeSpan>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als een aanvraag wordt ontvangen voordat het opgegeven interval is verstreken tijd; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.Channels.IReplyChannel.WaitForRequest*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: BeginReceiveRequest(AsyncCallback,Object)
  nameWithType: IReplyChannel.BeginReceiveRequest(AsyncCallback,Object)
  fullName: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: BeginReceiveRequest(TimeSpan,AsyncCallback,Object)
  nameWithType: IReplyChannel.BeginReceiveRequest(TimeSpan,AsyncCallback,Object)
  fullName: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(TimeSpan,AsyncCallback,Object)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: BeginTryReceiveRequest(TimeSpan,AsyncCallback,Object)
  nameWithType: IReplyChannel.BeginTryReceiveRequest(TimeSpan,AsyncCallback,Object)
  fullName: System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(TimeSpan,AsyncCallback,Object)
- uid: System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: BeginWaitForRequest(TimeSpan,AsyncCallback,Object)
  nameWithType: IReplyChannel.BeginWaitForRequest(TimeSpan,AsyncCallback,Object)
  fullName: System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(TimeSpan,AsyncCallback,Object)
- uid: System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: EndReceiveRequest(IAsyncResult)
  nameWithType: IReplyChannel.EndReceiveRequest(IAsyncResult)
  fullName: System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(IAsyncResult)
- uid: System.ServiceModel.Channels.RequestContext
  parent: System.ServiceModel.Channels
  isExternal: true
  name: RequestContext
  nameWithType: RequestContext
  fullName: System.ServiceModel.Channels.RequestContext
- uid: System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: EndTryReceiveRequest(IAsyncResult,RequestContext)
  nameWithType: IReplyChannel.EndTryReceiveRequest(IAsyncResult,RequestContext)
  fullName: System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(IAsyncResult,RequestContext)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: EndWaitForRequest(IAsyncResult)
  nameWithType: IReplyChannel.EndWaitForRequest(IAsyncResult)
  fullName: System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(IAsyncResult)
- uid: System.ServiceModel.Channels.IReplyChannel.LocalAddress
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: LocalAddress
  nameWithType: IReplyChannel.LocalAddress
  fullName: System.ServiceModel.Channels.IReplyChannel.LocalAddress
- uid: System.ServiceModel.EndpointAddress
  parent: System.ServiceModel
  isExternal: true
  name: EndpointAddress
  nameWithType: EndpointAddress
  fullName: System.ServiceModel.EndpointAddress
- uid: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: ReceiveRequest()
  nameWithType: IReplyChannel.ReceiveRequest()
  fullName: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest()
- uid: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: ReceiveRequest(TimeSpan)
  nameWithType: IReplyChannel.ReceiveRequest(TimeSpan)
  fullName: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(TimeSpan)
- uid: System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: TryReceiveRequest(TimeSpan,RequestContext)
  nameWithType: IReplyChannel.TryReceiveRequest(TimeSpan,RequestContext)
  fullName: System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(TimeSpan,RequestContext)
- uid: System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: WaitForRequest(TimeSpan)
  nameWithType: IReplyChannel.WaitForRequest(TimeSpan)
  fullName: System.ServiceModel.Channels.IReplyChannel.WaitForRequest(TimeSpan)
- uid: System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest*
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: BeginReceiveRequest
  nameWithType: IReplyChannel.BeginReceiveRequest
- uid: System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest*
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: BeginTryReceiveRequest
  nameWithType: IReplyChannel.BeginTryReceiveRequest
- uid: System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest*
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: BeginWaitForRequest
  nameWithType: IReplyChannel.BeginWaitForRequest
- uid: System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest*
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: EndReceiveRequest
  nameWithType: IReplyChannel.EndReceiveRequest
- uid: System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest*
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: EndTryReceiveRequest
  nameWithType: IReplyChannel.EndTryReceiveRequest
- uid: System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest*
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: EndWaitForRequest
  nameWithType: IReplyChannel.EndWaitForRequest
- uid: System.ServiceModel.Channels.IReplyChannel.LocalAddress*
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: LocalAddress
  nameWithType: IReplyChannel.LocalAddress
- uid: System.ServiceModel.Channels.IReplyChannel.ReceiveRequest*
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: ReceiveRequest
  nameWithType: IReplyChannel.ReceiveRequest
- uid: System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest*
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: TryReceiveRequest
  nameWithType: IReplyChannel.TryReceiveRequest
- uid: System.ServiceModel.Channels.IReplyChannel.WaitForRequest*
  parent: System.ServiceModel.Channels.IReplyChannel
  isExternal: false
  name: WaitForRequest
  nameWithType: IReplyChannel.WaitForRequest
