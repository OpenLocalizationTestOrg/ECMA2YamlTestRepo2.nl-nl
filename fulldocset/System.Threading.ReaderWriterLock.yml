### YamlMime:ManagedReference
items:
- uid: System.Threading.ReaderWriterLock
  id: ReaderWriterLock
  children:
  - System.Threading.ReaderWriterLock.#ctor
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  - System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.Finalize
  - System.Threading.ReaderWriterLock.IsReaderLockHeld
  - System.Threading.ReaderWriterLock.IsWriterLockHeld
  - System.Threading.ReaderWriterLock.ReleaseLock
  - System.Threading.ReaderWriterLock.ReleaseReaderLock
  - System.Threading.ReaderWriterLock.ReleaseWriterLock
  - System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.WriterSeqNum
  langs:
  - csharp
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock
  fullName: System.Threading.ReaderWriterLock
  type: Class
  summary: "Hiermee definieert u een vergrendeling die ondersteuning biedt voor één schrijvers en meerdere lezers."
  remarks: "> [!IMPORTANT]> De [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)] heeft twee lezer schrijver vergrendelingen, <xref:System.Threading.ReaderWriterLockSlim>en ReaderWriterLock.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>ontwikkeling van alle nieuwe wordt aanbevolen.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>is vergelijkbaar met ReaderWriterLock, maar deze regels voor recursie en voor het upgraden en downgraden lock-status heeft vereenvoudigd.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>veel gevallen van mogelijke deadlock voorkomt.</xref:System.Threading.ReaderWriterLockSlim> Daarnaast biedt de prestaties van <xref:System.Threading.ReaderWriterLockSlim>is aanzienlijk beter dan ReaderWriterLock.</xref:System.Threading.ReaderWriterLockSlim>       ReaderWriterLock wordt gebruikt voor toegang tot een bron te synchroniseren. Op elk gewenst kunt u gelijktijdige lees-toegang voor meerdere threads of schrijftoegang voor een enkele thread. In een situatie waarbij een bron is gewijzigd af en toe een `ReaderWriterLock` biedt betere doorvoer dan een eenvoudige één-op-een-time-vergrendeling, zoals <xref:System.Threading.Monitor>.</xref:System.Threading.Monitor>       `ReaderWriterLock`werkt het beste wanneer de meeste toegang zijn leesbewerkingen schrijfbewerkingen zijn incidentele en van korte duur. Lezers van meerdere alternatieve met één schrijvers, zodat lezers noch schrijvers gedurende lange periodes worden geblokkeerd.      > [!NOTE] > Houden lezer vergrendelingen of writer vergrendelingen voor lange periodes andere threads wordt stilleggen. Houd rekening met uw toepassing te minimaliseren, de duur van schrijfbewerkingen herstructureren voor de beste prestaties.       Een thread kan een lezer bevatten vergrendelen of een vergrendeling writer, maar niet beide op hetzelfde moment. In plaats van een lezer vergrendeling om de vergrendeling writer, kunt u <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>en <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> </xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>       Recursieve lock-aanvragen Verhoog het aantal op een vergrendeling.       En schrijfprogramma zijn in de wachtrij afzonderlijk. Wanneer een thread van de schrijver vergrendeling, krijgen alle threads staan in de wachtrij lezer op dat moment lezer vergrendelingen; Wanneer alle van deze reader vergrendelingen zijn vrijgegeven, de volgende thread wachten in de writer wachtrij, indien aanwezig, de writer vergrendeling wordt verleend, enzovoort. Met andere woorden, `ReaderWriterLock` schakelen tussen een verzameling van lezers en één writer.       Terwijl een thread in de wachtrij writer op actieve lezer vergrendelingen worden vrijgegeven wachten, verzamelt threads nieuwe lezer vergrendelingen aanvragen in de wachtrij voor de lezer. Hun aanvragen worden niet verleend, hoewel ze gelijktijdige toegang met bestaande lezervergrendeling houders delen kunnen; Dit beschermt u schrijvers tegen onbepaalde blokkeringen door lezers.       De meeste methoden voor het verkrijgen van vergrendelingen op een `ReaderWriterLock` time-outwaarden accepteren. Time-outs gebruiken om te voorkomen dat impassen in uw toepassing. Bijvoorbeeld, kan een thread vergrendelen voor de schrijver van één resource en vraag een lezervergrendeling op een tweede bron. een andere thread mogelijk in de tussentijd vergrendelen voor de schrijver van de tweede bron en een lezervergrendeling op de eerste aanvraag. Tenzij time-outs worden gebruikt, de impasse threads.       Als het time-outinterval is verlopen en de vergrendelingsaanvraag is niet verleend, de methode besturingselement naar de aanroepende thread geretourneerd door een <xref:System.ApplicationException>.</xref:System.ApplicationException> Een thread kan deze uitzondering onderschept en bepalen welke actie u nu moet uitvoeren.       Time-outs worden uitgedrukt in milliseconden. Als u een <xref:System.TimeSpan?displayProperty=fullName>om op te geven van de time-outwaarde is de waarde die het totale aantal hele milliseconden dat wordt vertegenwoordigd door de <xref:System.TimeSpan>.</xref:System.TimeSpan> </xref:System.TimeSpan?displayProperty=fullName> De volgende tabel toont de geldige time-outwaarden in milliseconden.      | Waarde | Beschrijving |   |-----------|-----------------|   | -1 | De thread wacht totdat de vergrendeling wordt verkregen, ongeacht hoe lang het duurt. Methoden die time-outs geheel getal opgeven, de constante <xref:System.Threading.Timeout.Infinite>kan worden gebruikt. |   |&0; | De thread wacht niet de vergrendeling.</xref:System.Threading.Timeout.Infinite> De methode retourneert als kan niet onmiddellijk de vergrendeling worden verkregen,. |   | >&0; | Het aantal milliseconden wachttijd. |       Met uitzondering van -1, zijn negatieve time-outwaarden niet toegestaan. Als u een negatief geheel getal dan -1 opgeeft, wordt een time-outwaarde van nul in plaats daarvan gebruikt. (Dat wil zeggen, de methode retourneert zonder te wachten, als de vergrendeling onmiddellijk kan niet worden opgehaald.) Als u een <xref:System.TimeSpan>die staat voor een negatief aantal milliseconden dan -1, <xref:System.ArgumentOutOfRangeException>gegenereerd.</xref:System.ArgumentOutOfRangeException> </xref:System.TimeSpan>"
  example:
  - "The following example demonstrates how to use a ReaderWriterLock to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads. Note that the ReaderWriterLock is declared at the class level so that it is visible to all threads.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#1](~/add/codesnippet/cpp/t-system.threading.reade_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#1](~/add/codesnippet/csharp/t-system.threading.reade_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#1](~/add/codesnippet/visualbasic/t-system.threading.reade_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.#ctor
  id: '#ctor'
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Initialiseert een nieuw exemplaar van de <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> klasse."
  remarks: ''
  example:
  - "The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_0_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_0_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_0_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_0_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_0_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_0_2.vb)]"
  syntax:
    content: public ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  id: AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Een lezer verkrijgt vergrendelt, met behulp van een <xref:System.Int32>waarde voor de time-outwaarde.</xref:System.Int32>"
  remarks: "AcquireReaderLock wordt geblokkeerd als een andere thread heeft de vergrendeling writer, of als ten minste één thread wacht tot de schrijververgrendeling.      > [!NOTE] > Als de huidige thread is al de vergrendeling writer, geen lezervergrendeling wordt verkregen. In plaats daarvan wordt het aantal op de writer vergrendeling verhoogd. Dit voorkomt dat een thread op een eigen writer vergrendeling worden geblokkeerd. Het resultaat is precies hetzelfde als het aanroepen <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, en een extra aanroep <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>is vereist bij het vrijgeven van de schrijververgrendeling.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`biedt ondersteuning voor recursieve reader-lock-aanvragen. Dat wil zeggen, kan een thread aanroepen AcquireReaderLock meerdere keren dat het aantal oploopt telkens wanneer de. U moet aanroepen <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>eenmaal voor elke keer dat u `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> U kunt ook aanroepen <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>om te beperken het aantal naar nul onmiddellijk.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Recursieve lock-aanvragen worden altijd onmiddellijk, zonder de aanvragende thread in de wachtrij lezer verleend. Recursieve vergrendelingen Wees voorzichtig, om te voorkomen dat gedurende lange periodes writer lock-aanvragen worden geblokkeerd.       Zie voor een geldige time-outwaarden <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_6_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_6_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_6_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_6_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_6_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_6_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_6_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_6_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_6_3.vb)]"
  syntax:
    content: public void AcquireReaderLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "De tijdsduur in milliseconden."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>is verstreken voordat de vergrendelingsaanvraag is verleend."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  id: AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Een lezer verkrijgt vergrendelt, met behulp van een <xref:System.TimeSpan>waarde voor de time-outwaarde.</xref:System.TimeSpan>"
  remarks: "<xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>Als een andere thread heeft de vergrendeling writer, of als ten minste één thread wacht tot de vergrendeling writer blokkeert.</xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>      > [!NOTE] > Als de huidige thread is al de vergrendeling writer, geen lezervergrendeling wordt verkregen. In plaats daarvan wordt het aantal op de writer vergrendeling verhoogd. Dit voorkomt dat een thread op een eigen writer vergrendeling worden geblokkeerd. Het resultaat is precies hetzelfde als het aanroepen <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, en een extra aanroep <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>is vereist bij het vrijgeven van de schrijververgrendeling.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`biedt ondersteuning voor recursieve reader-lock-aanvragen. Dat wil zeggen, kan een thread aanroepen AcquireReaderLock meerdere keren dat het aantal oploopt telkens wanneer de. U moet aanroepen <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>eenmaal voor elke keer dat u `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> U kunt ook aanroepen <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>om te beperken het aantal naar nul onmiddellijk.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Recursieve lock-aanvragen worden altijd onmiddellijk, zonder de aanvragende thread in de wachtrij lezer verleend. Recursieve vergrendelingen Wees voorzichtig, om te voorkomen dat gedurende lange periodes writer lock-aanvragen worden geblokkeerd.       Zie voor een geldige time-outwaarden <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireReaderLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Een <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> geven de time-outperiode."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>is verstreken voordat de vergrendelingsaanvraag is verleend."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Hiermee geeft u een negatieve waarde dan-1 milliseconden."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  id: AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "De writer verkrijgt vergrendelt, met behulp van een <xref:System.Int32>waarde voor de time-outwaarde.</xref:System.Int32>"
  remarks: "Deze methode wordt geblokkeerd als een andere thread een lezervergrendeling of writer vergrendelen heeft. De writer vergrendeling alternatieven met meerdere gelijktijdige lezer vergrendelingen Zie voor een beschrijving van de manier waarop de <xref:System.Threading.ReaderWriterLock>klasse.</xref:System.Threading.ReaderWriterLock>       Een thread die al een lezervergrendeling kunt vergrendelen voor de schrijver op twee manieren: door de lezer vergrendeling voordat u AcquireWriterLock aanroept of door het aanroepen van <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>      > [!CAUTION] > Als een thread aanroept `AcquireWriterLock` terwijl er nog een lezervergrendeling, wordt geblokkeerd op een eigen lezervergrendeling; als een oneindige time-out wordt opgegeven, de thread wordt impasse. Gebruiken om te voorkomen dat dergelijke impassen, <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>om te bepalen of de huidige thread is al een lezervergrendeling.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`biedt ondersteuning voor recursieve writer-lock-aanvragen. Dat wil zeggen, een thread kan aanroepen `AcquireWriterLock` meerdere keren dat het aantal telkens wanneer verhoogd. U moet aanroepen <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>eenmaal voor elke keer dat u `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> U kunt ook aanroepen <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>om te beperken het aantal naar nul onmiddellijk.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Recursieve lock-aanvragen worden altijd onmiddellijk, zonder de aanvragende thread in de wachtrij writer verleend.       Zie voor een geldige time-outwaarden <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_4_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_4_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_4_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_4_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_4_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_4_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_4_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_4_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_4_3.vb)]"
  syntax:
    content: public void AcquireWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "De tijdsduur in milliseconden."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>is verstreken voordat de vergrendelingsaanvraag is verleend."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  id: AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "De writer verkrijgt vergrendelt, met behulp van een <xref:System.TimeSpan>waarde voor de time-outwaarde.</xref:System.TimeSpan>"
  remarks: "Deze methode wordt geblokkeerd als een andere thread een lezervergrendeling of writer vergrendelen heeft. De writer vergrendeling alternatieven met meerdere gelijktijdige lezer vergrendelingen Zie voor een beschrijving van de manier waarop de <xref:System.Threading.ReaderWriterLock>klasse.</xref:System.Threading.ReaderWriterLock>       Een thread die al een lezervergrendeling kunt vergrendelen voor de schrijver op twee manieren: door de lezer voordat vergrendeling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, of door het aanroepen van <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>      > [!CAUTION] > Als een thread aanroept `AcquireWriterLock` terwijl er nog een lezervergrendeling, wordt geblokkeerd op een eigen lezervergrendeling; als een oneindige time-out wordt opgegeven, de thread wordt impasse. Gebruiken om te voorkomen dat dergelijke impassen, <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>om te bepalen of de huidige thread is al een lezervergrendeling.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`biedt ondersteuning voor recursieve writer-lock-aanvragen. Dat wil zeggen, een thread kan aanroepen `AcquireWriterLock` meerdere keren dat het aantal telkens wanneer verhoogd. U moet aanroepen <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>eenmaal voor elke keer dat u `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> U kunt ook aanroepen <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>om te beperken het aantal naar nul onmiddellijk.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Recursieve lock-aanvragen worden altijd onmiddellijk, zonder de aanvragende thread in de wachtrij writer verleend.       Zie voor een geldige time-outwaarden <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "De <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> geven de time-outperiode."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>is verstreken voordat de vergrendelingsaanvraag is verleend."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Hiermee geeft u een negatieve waarde dan-1 milliseconden."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  id: AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee wordt aangegeven of de schrijververgrendeling is toegekend aan een willekeurige thread sinds het volgnummer is verkregen."
  remarks: "U kunt <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>en `AnyWritersSince` voor het verbeteren van de prestaties van toepassingen.</xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> Een thread kan bijvoorbeeld de informatie die wordt verkregen terwijl een lezervergrendeling cache. Na vrijgeven en later uit de vergrendeling wordt de thread kunt `AnyWritersSince` om te bepalen of andere threads zijn geschreven naar de resource in de tussentijd; zo niet, de gegevens in cache kan worden gebruikt. Dit is handig wanneer Lees de informatie die wordt beveiligd door de vergrendeling is dure; bijvoorbeeld, een databasequery wordt uitgevoerd.       De aanroeper moet houdt een lezervergrendeling of een vergrendeling writer om het volgnummer nuttig."
  example:
  - "The following code example shows how to use the AnyWritersSince method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_8_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_8_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_8_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_8_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_8_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_8_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_8_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_8_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_8_3.vb)]"
  syntax:
    content: public bool AnyWritersSince (int seqNum);
    parameters:
    - id: seqNum
      type: System.Int32
      description: "Het volgnummer."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de writer vergrendeling is toegekend aan een willekeurige thread sinds het volgnummer is verkregen; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.AnyWritersSince*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  id: DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "De status van de activeringsvergrendeling van de thread herstelt die voordat was <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>is aangeroepen.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>"
  remarks: "DowngradeFromWriterLock de vergrendeling writer, ongeacht het aantal recursieve, en herstelt u de lezervergrendeling die vóór de upgrade naar de vergrendeling writer is veroorzaakt door de thread. Het aantal op de lezervergrendeling is hersteld.      > [!NOTE]  >   `DowngradeFromWriterLock` accepteert een <xref:System.Threading.LockCookie>door het aanroepen van <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> verkregen</xref:System.Threading.LockCookie> Gebruik niet een `LockCookie` geretourneerd door <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Een thread worden niet geblokkeerd wanneer het downgraden van de vergrendeling writer, zelfs als er andere threads wacht totdat de vergrendeling writer omdat alle lezervergrendeling aanvragen worden verleend als de writer vergrendeling wordt vrijgegeven."
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_3.vb)]"
  syntax:
    content: public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "Een <xref href=&quot;System.Threading.LockCookie&quot;> </xref> geretourneerd door <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>"
  overload: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "De thread heeft niet de vergrendeling writer."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Het adres van <code> lockCookie </code> is een null-aanwijzer."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.Finalize
  id: Finalize
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Zorgt ervoor dat resources zijn vrijgegeven en andere opschonen-bewerkingen worden uitgevoerd wanneer de garbage collector indexrijen de <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> object."
  remarks: "De garbage collector aanroepen voltooien wanneer de huidige <xref:System.Threading.ReaderWriterLock>object is gereed om te worden voltooid.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: ~ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  id: IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee wordt een waarde die aangeeft of de huidige thread een lezervergrendeling, opgehaald."
  remarks: ''
  example:
  - "The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_1_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_1_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_1_1.cs)]"
  syntax:
    content: public bool IsReaderLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de huidige thread een lezervergrendeling bevat; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  id: IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Haalt een waarde die aangeeft of de huidige thread de schrijververgrendeling bevat."
  remarks: ''
  example:
  - "The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_0_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_0_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_0_1.cs)]"
  syntax:
    content: public bool IsWriterLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Als de huidige thread de vergrendeling writer bevat; anders <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  id: ReleaseLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "De vergrendeling, ongeacht het aantal keren dat de thread de vergrendeling verkregen."
  remarks: "ReleaseLock versies de lezervergrendeling of writer vergrendelen, ongeacht het aantal recursieve. Voor het herstellen van de status van de vergrendeling, met inbegrip van het aantal, de doorgeven <xref:System.Threading.LockCookie>aan <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A> </xref:System.Threading.LockCookie>"
  example:
  - "The following code example shows how to use the ReleaseLock method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_1_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_1_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_1_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_1_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_1_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_1_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_1_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_1_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_1_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie ReleaseLock ();
    parameters: []
    return:
      type: System.Threading.LockCookie
      description: "Een <xref href=&quot;System.Threading.LockCookie&quot;> </xref> -waarde voor de uitgebrachte vergrendeling."
  overload: System.Threading.ReaderWriterLock.ReleaseLock*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  id: ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Vermindert de vergrendeling tellen."
  remarks: "ReleaseReaderLock verlaagt de vergrendeling tellen. Wanneer het aantal nul is, wordt de vergrendeling wordt vrijgegeven.      > [!NOTE] > Aanroepen als een thread de vergrendeling writer heeft, `ReleaseReaderLock` heeft hetzelfde effect als het aanroepen van <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Als een thread geen vergrendelingen heeft, aanroepen van `ReleaseReaderLock` genereert een <xref:System.ApplicationException>.</xref:System.ApplicationException>"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_5_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_5_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_5_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_5_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_5_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_5_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_5_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_5_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_5_3.vb)]"
  syntax:
    content: public void ReleaseReaderLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "De thread heeft geen een lezer of writer vergrendelingen."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  id: ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Vermindert de vergrendeling count voor de schrijververgrendeling."
  remarks: "ReleaseWriterLock verlaagt de vergrendeling writer tellen. Wanneer het aantal nul is, wordt de vergrendeling writer vrijgegeven.      > [!NOTE] > Aanroepen als een thread een lezervergrendeling of geen vergrendelingen heeft, `ReleaseWriterLock` genereert een <xref:System.ApplicationException>.</xref:System.ApplicationException>"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_3_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_3_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_3_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_3_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_3_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_3_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_3_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_3_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_3_3.vb)]"
  syntax:
    content: public void ReleaseWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "De thread heeft niet de vergrendeling writer."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  id: RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "De status van de activeringsvergrendeling van de thread herstelt die was voordat u <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*>"
  remarks: "De status hersteld door `RestoreLock` bevat het aantal recursieve.       Een thread-blokken als deze probeert een lezervergrendeling herstellen nadat de vergrendeling writer heeft verkregen door een andere thread of als deze probeert de vergrendeling writer herstellen nadat een andere thread heeft een lezervergrendeling of writer vergrendeling verkregen. Omdat `RestoreLock` accepteert geen is een time-out u om te voorkomen dat mogelijk impassen moet behandelen.      > [!CAUTION] > Voordat `RestoreLock`, zorg ervoor dat u alle vergrendelingen sinds de aanroep naar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> zijn beschikbaar Bijvoorbeeld, een thread impassen indien een lezervergrendeling verkrijgt, en vervolgens probeert te herstellen van een eerdere writer-vergrendeling. Gebruik <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>en <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A>voor het detecteren van dergelijke vergrendelingen.</xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> </xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       Gebruik niet een <xref:System.Threading.LockCookie>geretourneerd vanuit <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> </xref:System.Threading.LockCookie>"
  example:
  - "The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_2_3.vb)]"
  syntax:
    content: public void RestoreLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "Een <xref href=&quot;System.Threading.LockCookie&quot;> </xref> geretourneerd door <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*>"
  overload: System.Threading.ReaderWriterLock.RestoreLock*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Het adres van <code> lockCookie </code> is een null-aanwijzer."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  id: UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Upgrades een lezervergrendeling naar de writer vergrendelt, met behulp van een <xref uid=&quot;langword_csharp_Int32&quot; name=&quot;Int32&quot; href=&quot;&quot;> </xref> waarde voor de time-outwaarde."
  remarks: "Wanneer wordt aangeroepen door een thread `UpgradeToWriterLock` de lezervergrendeling wordt uitgebracht, ongeacht het aantal vergrendelingen en de thread wordt aan het einde van de wachtrij voor de schrijververgrendeling. Dus mogelijk andere threads schrijven naar de bron voordat de thread die de upgrade krijgt de vergrendeling writer aangevraagd.      > [!IMPORTANT] > De time-outwaarde niet uitzondering totdat de thread die de methode UpgradeToWriterLock aangeroepen opnieuw van de lezervergrendeling ophalen kunt. Als er geen andere threads wachten op de vergrendeling writer, wordt dit direct gebeurt. Echter, als een andere thread zich in de wachtrij voor de schrijver vergrendelen, de thread die de UpgradeToWriterLock-methode aangeroepen kan niet opnieuw ophalen de lezervergrendeling totdat alle huidige lezers hun vergrendelingen zijn vrijgegeven en één thread heeft verkregen en de vergrendeling writer uitgebracht. Dit geldt zelfs als de thread die de vergrendeling writer aangevraagd het aangevraagd nadat de huidige thread heeft de methode UpgradeToWriterLock aangeroepen.       Aanroepen voor het herstellen van de status van de vergrendeling <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>met behulp van de <xref:System.Threading.LockCookie>geretourneerd door `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Gebruik dit niet `LockCookie` <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       Wanneer een thread geen lezervergrendeling heeft, gebruik geen `UpgradeToWriterLock`. Gebruik <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>in plaats daarvan.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       Zie voor een geldige time-outwaarden <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_7_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_7_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_7_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/m-system.threading.reade_7_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/m-system.threading.reade_7_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/m-system.threading.reade_7_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_7_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_7_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_7_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "De tijdsduur in milliseconden."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>is verstreken voordat de vergrendelingsaanvraag is verleend."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  id: UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Upgrades een lezervergrendeling naar de writer vergrendelt, met behulp van een <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> waarde voor de time-outwaarde."
  remarks: "Wanneer wordt aangeroepen door een thread `UpgradeToWriterLock` de lezervergrendeling wordt uitgebracht, ongeacht het aantal vergrendelingen en de thread wordt aan het einde van de wachtrij voor de schrijververgrendeling. Dus mogelijk andere threads schrijven naar de bron voordat de thread die de upgrade krijgt de vergrendeling writer aangevraagd.      > [!IMPORTANT] > De time-outwaarde niet uitzondering totdat de thread die aangeroepen de <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>methode opnieuw kunt ophalen van de lezervergrendeling.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> Als er geen andere threads wachten op de vergrendeling writer, wordt dit direct gebeurt. Echter, als een andere thread zich in de wachtrij voor de schrijververgrendeling, de thread die wordt aangeroepen de <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>kan geen methode opnieuw ophalen van de lezervergrendeling totdat alle huidige lezers hun vergrendelingen zijn vrijgegeven en één thread heeft verkregen en de writer vergrendeling wordt vrijgegeven.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> Dit geldt zelfs wanneer de thread die de vergrendeling writer aangevraagd het aangevraagd nadat de huidige thread aangeroepen de <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>methode.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>       Aanroepen voor het herstellen van de status van de vergrendeling <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>met behulp van de <xref:System.Threading.LockCookie>geretourneerd door `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Gebruik dit niet `LockCookie` <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       Wanneer een thread geen lezervergrendeling heeft, gebruik geen `UpgradeToWriterLock`. Gebruik <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>in plaats daarvan.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       Zie voor een geldige time-outwaarden <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "De <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> geven de time-outperiode."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>is verstreken voordat de vergrendelingsaanvraag is verleend."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Hiermee geeft u een negatieve waarde dan-1 milliseconden."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  id: WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Hiermee wordt het huidige volgnummer opgehaald."
  remarks: "De volgorde worden verhoogd telkens wanneer een thread de schrijververgrendeling verkrijgt. U kunt het volgnummer opslaan en doorgegeven aan <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>op een later tijdstip, als u bepalen wilt of andere threads in de tussentijd de vergrendeling writer hebt aangeschaft.</xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>       U kunt `WriterSeqNum` voor het verbeteren van de prestaties van toepassingen. Een thread kan bijvoorbeeld de informatie die wordt verkregen terwijl een lezervergrendeling cache. Na vrijgeven en later uit de vergrendeling wordt de thread kan bepalen of andere threads op de resource hebt geschreven door het aanroepen van `AnyWritersSince`; als niet zo is, de gegevens in cache kan worden gebruikt. Deze methode is handig wanneer Lees de informatie die wordt beveiligd door de vergrendeling dure; bijvoorbeeld, een databasequery wordt uitgevoerd.       De aanroeper moet houdt een lezervergrendeling of een vergrendeling writer om het volgnummer nuttig."
  example:
  - "The following code example shows how to use the WriterSeqNum property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/p-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/p-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/p-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/p-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/p-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/p-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/p-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/p-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/p-system.threading.reade_2_3.vb)]"
  syntax:
    content: public int WriterSeqNum { get; }
    return:
      type: System.Int32
      description: "Het huidige volgnummer."
  overload: System.Threading.ReaderWriterLock.WriterSeqNum*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.Threading.ReaderWriterLock.#ctor
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
- uid: System.Threading.LockCookie
  parent: System.Threading
  isExternal: false
  name: LockCookie
  nameWithType: LockCookie
  fullName: System.Threading.LockCookie
- uid: System.Threading.ReaderWriterLock.Finalize
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
- uid: System.Threading.ReaderWriterLock.#ctor*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock.ReaderWriterLock
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock
  nameWithType: ReaderWriterLock.AcquireReaderLock
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock
  nameWithType: ReaderWriterLock.AcquireWriterLock
- uid: System.Threading.ReaderWriterLock.AnyWritersSince*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince
  nameWithType: ReaderWriterLock.AnyWritersSince
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock
- uid: System.Threading.ReaderWriterLock.Finalize*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize
  nameWithType: ReaderWriterLock.Finalize
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock
  nameWithType: ReaderWriterLock.ReleaseLock
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock
  nameWithType: ReaderWriterLock.ReleaseReaderLock
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock
  nameWithType: ReaderWriterLock.ReleaseWriterLock
- uid: System.Threading.ReaderWriterLock.RestoreLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock
  nameWithType: ReaderWriterLock.RestoreLock
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock
  nameWithType: ReaderWriterLock.UpgradeToWriterLock
- uid: System.Threading.ReaderWriterLock.WriterSeqNum*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
